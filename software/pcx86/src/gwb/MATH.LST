Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-1
                                                            

                             C  	include	math1.asm 
                             C  ; [ This translation created 10-Feb-83 by Versi
				on 4.3 ] 
                             C   
 0008                        C  	.RADIX	8		; To be safe 
                             C   
 0000                        C  CSEG	SEGMENT PUBLIC 'CODESG' 
                             C  	ASSUME	CS:CSEG 
                             C   
                             C  INCLUDE OEM.INC 
                             C  ; [ This translation created 10-Feb-83 by Versi
				on 4.3 ] 
                             C   
                             C  	SUBTTL  Common file to produce 2-segment 8086 
				GW-CPM BASIC 
                             C   
                             C  	.SALL 
                             C   
 000A                        C  	.RADIX	10 
 = 0000                      C  	OEMRAM=0D 
                             C  ;Pascal program HFILE searches for the followin
				g line - DO NOT MODIFY 
                             C  ;** (VERSION SPECIFIC VALUES) *****************
				******************************* 
 = 0019                      C  	NMLINE=25		;Max screen display text lines 
 = 0001                      C  	NBANKS=1		;Number of graphic planes 
 = 0000                      C  	PALSIZ=0		;Size of OEM color palette 
 = 0000                      C  	DBLCHR=0		;Editor support for KANJI chars 
 = 0000                      C  	KANABS=0		;Kana BASIC (Japanese JIS codes) 
 = 0000                      C  	KANJFN=0		;KANJI String Functions KPOS, KLEN .
				. 
 = 0000                      C  	JISKTN=0		;&K, &J constants (KANJI) 
 = 0001                      C  	SUPRSH=1		;1=super shift key feature 
 = 000A                      C  	NMKEYF=10		;number of function keys 
 = 000E                      C  	NMKEYT=14		;number of function key traps 
 = 0001                      C  	FKEYON=1		;yes=display function keys 
 = 0001                      C  	SCROLT=1		;Line 25 allocated for status only 
 = 0001                      C  	PLAYSW=1		;for PLAY statement 
 = 0001                      C  	BEEPSW=1		;for SOUND, BEEP statements 
 = 0003                      C  	NMLPT=3			;number of line printers 
 = 0001                      C  	CONSSW=1		;Device CONS: 
 = 0002                      C  	NMCOMT=2		;number of COMmunications ports 
 = 0001                      C  	NMPENT=1		;number of light pens 
 = 0004                      C  	NMSTRT=4		;number of joysticks 
 = 0000                      C  	GWCASS=0		;Cassette switch (CSAVE,CLOAD,MOTOR)
				 
 = 0001                      C  	IBMLIK=1		;IBM compatibility package 
 = 0001                      C  	IBMTOK=1		;IBM token compatibility 
 = 0001                      C  	DYNCOM=1		;Dynamic communication buffers 
                             C  ;** (END OF VERSION SPECIFIC VALUES) **********
				******************************* 
                             C  ;Pascal program HFILE searches for the previous
				 line - DO NOT MODIFY 
                             C  ; 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-2
Common file to produce 2-segment 8086 GW-CPM BASIC          

 = 0015                      C  	NUMTRP=NMKEYT+NMCOMT+NMPENT+NMSTRT 
 = 0001                      C  	GW=1			;GW BASIC 
 = 0000                      C  	ESCCTL=0		;Escape Sequence processing in SCROU
				T 
 = 0000                      C  	GWDBUG=0		;DEBUG statement (TEST VERSIONS ONLY
				) 
                             C  				; Support is in BINTRP.MAC and GWSTS.MAC 
 = 0000                      C  	SIXDIG=0		;# of digits of accuracy assumed whe
				n formatting 
                             C  				;single precision numbers for output. 
                             C  				; 0 := 7 digits 
                             C  				; 1 := 6 digits 
 = 0000                      C  	CASSW=0			;CASSETTE SWITCH 
 = 0001                      C  	LABKEY=1		;^T (LABEL) key capability 
 = 0001                      C  	HGHBIT=1		;8-bit characters (ASCII & Graphics)
				 
 = 0001                      C  	QUEUE=1			;Queued painting algorithm (vs. stac
				k) 
 = 0001                      C  	GIO86=1			;BASIC-86 Generalized I/O 
 = 0001                      C  	SCRNIO=1		;Screen editor 
 = 0001                      C  	SCRN86=1		;8086 Screen editor 
 = 0001                      C  	I8086=1			;CROSS ASSEMBLING FOR 8086 
 = 0001                      C  	MULSEG=1		;MULTI-SEGMENT 8086 BASIC 
 = 0000                      C  	SMALL=0			;"SMALL" VERSION OF 8086 BASIC IF SE
				T 
 = 0001                      C  	TRUROM=1 
 = 0000                      C  	SBC86=0			;SBC 86/02 BOARD? 
 = 0001                      C  	SHORTJ=1		;USE INTRA-SEGMENT SHORT JUMPS 
                             C  				;IN 8086 CODE 
 = 0001                      C  	LNGVAR=1		;LONG VARIABLE NAME SUPPORT (EXTENDE
				D ONLY) 
 = 0000                      C  	SHTERR=0		;SHORT (2 CHAR) ERROR MESSAGES 
 = 0000                      C  	SHTINS=0		;INSTR IN NON-FAST LEN2 VERSIONS 
 = 0000                      C  	SHTLHM=0		;LEFT HAND SIDE MID IN NON FAST LEN2
				 VERSIONS 
 = 0000                      C  	SHTCHN=0		;ALLOW CHAIN IN NON-5.0 
 = 0000                      C  	SHTPRO=0		;ALLOW PROTECTED FILES IN NON-FIVDSK
				 
 = 0000                      C  	SHTLIN=0		;ALLOW LINE INPUT IN NON-EXTENDED NO
				N-FAST 
 = 0000                      C  	SHTREN=0		;ALLOW RENUM IN NON-FST VERSIONS 
 = 0001                      C  	INKEYF=1		;ADDS INKEY$ FUNCTION 
 = 0000                      C  	NOIOS=0			;NO I/O STATMENTS (INP,OUT, WAIT) 
 = 0000                      C  	NOPEKS=0		;NO PEEK, POKE 
 = 0000                      C  	NOUSR=0			;NO USR 
 = 0000                      C  	NOCTLA=0		;NO CONTROL-A IN EXTENDED 
 = 0000                      C  	NORUBT=0		;NO RUBOUT 
 = 0000                      C  	NOROMP=0		;NO ROM PROGRAM FEATURE 
 = 0000                      C  	NOATDL=0		;NO AUTO DELETE IN NON-FAST EXTENDED
				 
 = 0000                      C  	NODOT=0			;NO DOT IN LEN2 
 = 0000                      C  	NOEDIT=0		;NO EDIT COMMAND 
 = 0000                      C  	CRONLY=0		;ONLY PUT OUT CR, NOT CRLF TO TERMIN
				AL 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-3
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  				;AND FILES 
 = 0000                      C  	NONULL=0		;NO NULL COMMAND, PUT OUT NULLS IN C
				RDO & OUTCH1 
 = 0000                      C  	NOVARP=0		;NO VARPTR FUNCTION 
 = 0001                      C  	FIVEO=1			;GENERATE VERSION WITH RELEASE 5.0 F
				EATURES 
 = 0001                      C  	FIVMEM=1 
 = 0001                      C  	ANSI=1 
 = 0001                      C  	FIVDSK=1		;5.0 NEW DSK CODE 
 = 0001                      C  	FIVLPT=1		;WIDTH LPRINT AND 255 FEATURE 
 = 0001                      C  	HEXOCT=1		;&H..., HEX$, &O..., OCT$ 
 = 0000                      C  	BINCSW=0		;&B..., BIN$ 
 = 0001                      C  	BLODSW=1		;BLOAD, BSAVE COMMANDS 
 = 0001                      C  	MEMIMG=1		;MEMORY IMAGE FILES 
 = 0001                      C  	GENBIN=1 
                             C   
 = 0000                      C  	TRUANS=0		;TRUE ANSI VERSION (STATIC SCAN, ON 
				ERROR) 
 = 0000                      C  	COMMNT=0		;DONT WANT BIG COMMENT 
 = 0000                      C  	INTEL=0			;INTEL PROPRIETARY 
 = 0000                      C  	INTFSW=0		;INTEL FLOATING POINT 
 = 0000                      C  	INTFHW=0 
 = 0000                      C  	RMX=0			;INTEL RMX VERSION 
 = 0000                      C  	EDIT80=0		;FOR EDIT80 I/O ROUTINES 
 = 0000                      C  	RSHACK=0 
 = 0000                      C  	INTLEC=0 
 = 0002                      C  	LENGTH=2		;  1 MEANS 8K, 2 MEANS 12K 
 = 0000                      C  	BASDEB=0		;WHETHER DBG WILL BE LOADED WITH BAS
				IC 
 = 0001                      C  	RSTLES=1		;WHETHER BASIC WILL USE RST LOCATION
				S 
                             C  				;TO MAKE ITSELF SMALLER & QUICKER 
 = 0001                      C  	REALIO=1		;WHETHER SIMULATE (=0) OR ON MACHINE
				 (=1) 
 = 0001                      C  	GENIO=1			;USE G/P ROUTINES 
 = 0001                      C  	CHSEAT=1		;CHSNS eats chars 
 = 0000                      C  	GENDSK=0		;USE G/P DSK CODE 
 = 0000                      C  	LONGI=0			;WHETHER WE ASK "TERMINAL WIDTH?" 
                             C  				;AND WANT SIN-TAN-COS-ATN? 
 = 0000                      C  	INSTSW=0		;FOR INSTR INSTRUCTION 
 = 0001                      C  	SWAPSW=1		;FOR SWAP STATEMENT 
 = 0000                      C  	MDS=0			;FOR INTEL MDS SYSTEMS 
 = 0000                      C  	SBC=0			;FOR INTEL SINGLE BOARD COMPUTER 
                             C  				;1=SBC 80/10, 2=SBC 80/20 
 = 0001                      C  	PURE=1			;ON FOR PURE CODE 
 = 0000                      C  	KILLER=0		;FOR ROM VERSION THAT WONT RUN IN RA
				M 
 = 0000                      C  	INTROM=0 
 = 0001                      C  	LPTSW=1 
 = 0001                      C  	NCRLPT=1 
 = 0000                      C  	NCRCAS=0 
 = 0000                      C  	ISC=0			;FOR ISC VERSION 
 = 0000                      C  	LPT3=0			;THREE LPT DRIVER VERSION(QUME,OKIA,C
				ENT) 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-4
Common file to produce 2-segment 8086 GW-CPM BASIC          

 = 0000                      C  	TSLPT=0 
                             C   
 = 0000                      C  	DOS=0			;ON TO GEN ROUTINES FOR DOS 
 = 0001                      C  	DISK=1			;FILE I/O FEATURES 
 = 0000                      C  	TIMSHR=0		;NO TIME-SHARING DISK 
 = 0000                      C  	TSDISK=0		;NO TIME-SHARING DISK FOR US 
 = 0000                      C  	SPCDSK=0		;MAY HAVE MM'S DISK CODE 
 = 0000                      C  	SPCNDS=0 
 = 0001                      C  	FAST=1			;CONSTANT COMPRESSION, RENUM & FRIEND
				S 
 = 0000                      C  	KEYSTA=0 
 = 0000                      C  	ISIS=0			;FOR VERSION TO RUN UNDER INTEL'S ISI
				S II DOS 
 = 0000                      C  	MDSISS=0		;FOR MDS VERSION THAT RUNS UNDER ISI
				S-II 
 = 0001                      C  	CPM=1			;FOR CPM compatible operating systems 
 = 0001                      C  	CPM2=1			;VERSION 2. CPM 
 = 0000                      C  	CPM86=0			;FOR CP/M-86 operating system 
 = 0001                      C  	SCP=1			;MS-DOS operating system 
 = 0000                      C  	CPMCON=0 
 = 0000                      C  	CPMSER=0		;CHECK CPM SERIAL #'S 
 = 0000                      C  	CPMADD=0		;FOR VERSION TO RUN ON ADDS CPM 
 = 0000                      C  	CPMA75=0		;FOR VERSION TO RUN ON ADDS SYSTEM 7
				5 
                             C  				;CP/M 
 = 0000                      C  	CPMRSH=0		;FOR RADIO SHACK CPM/M 
 = 0000                      C  	CPM110=0		;FOR CP/M @1100 HEX (INTERALIA) 
 = 0000                      C  	CPMSBC=0		;FOR VERSION TO RUN ON SBC CP/M AT 4
				100H 
 = 0000                      C  	CPMPER=0		;FOR PERTEC VERSION OF CPM 
 = 0000                      C  	CPMLIF=0		;LIFEBOAT CP/M AT 4200H 
 = 0000                      C  	CPMMDS=0		;MOHAWK DATA SYSTEMS CP/M 
 = 0000                      C  	CPMCON=0 
 = 0000                      C  	Z80=0 
 = 0001                      C  	DISK=1 
 = 0001                      C  	NCRLPT=1 
 = 0001                      C  	RSTLES=1 
 = 0000                      C  	DRVPOS=CPMADD 
 = 0000                      C  	TRNCHR=CPMADD 
 = 0000                      C  	INLADD=CPMADD 
 = 0001                      C  	LISTEN=1		;ON MEANS LISTEN FOR ^C 
 = 0001                      C  	LISTEN=1 
 = 0000                      C  	LEN2=0 
 = 0001                      C  	LEN2=1 
 = 0001                      C  	HEXOCT=1 
 = 0002                      C  	LENGTH=2 
 = 0001                      C  	RSTLES=1 
 = 0001                      C  	FIVLPT=1 
 = 0000                      C  	I8251=0			;THIS SWITCH IS USED FOR ROSEMOUNT V
				ERSION 
 = 0001                      C  	CONTRO=1		;ALLOW ^O 
 = 0001                      C  	LEN3=LEN2 OR CASSW 
                             C   
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-5
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C   
 = 0001                      C  	STRING=1 
 = 0001                      C  	NCRLPT=1 
                             C   
                             C  ; *** OEM Switches which need to be defaulted t
				o 0 
                             C  ; 
 = 0000                      C  	CMPUTN=0 
 = 0000                      C  	DUPONT=0 
 = 0000                      C  	EXIDY=0 
 = 0000                      C  	GESBC=0 
 = 0000                      C  	HEATH=0 
 = 0000                      C  	LOKHED=0 
 = 0000                      C  	MOSTEK=0 
 = 0000                      C  	TEK=0 
 = 0000                      C  	TRSER2=0 
 = 0000                      C  	NASCOM=0 
 = 0000                      C  	NATROM=0 
 = 0000                      C  	NCRBAS=0 
 = 0000                      C  	NCRDEB=0 
 = 0000                      C  	NCRDEB=0 
 = 0000                      C  	NCRELS=0 
 = 0000                      C  	ONTEL=0 
 = 0000                      C  	PCS=0 
 = 0000                      C  	SGSATS=0 
 = 0000                      C  	ALTAIR=0 
 = 0000                      C  	DMC=0 
 = 0000                      C  	PANBAS=0 
 = 0000                      C  	XTNSYS=0 
 = 0000                      C  	NECBAS=0 
                             C  ;**********************************************
				********************* 
                             C  ; Z80 related macros 
                             C  ;**********************************************
				********************* 
 = 0001                      C  	Z80=1			;FOR VERSION THAT RUNS ON BOTH 
                             C  				;8080'S AND ZILOG Z-80'S 
 = 0001                      C  	Z80MAC=1		;USE 8080 MACROS INSTEAD OF Z80 INST
				RUCTIONS 
 = 0000                      C  	Z80=0 
 = 0001                      C  	Z80=1 
                             C  LDIR	MACRO 
                             C  	MOV	WORD PTR A,WORD PTR M 
                             C  	STAX	D 
                             C  	INXF	H 
                             C  	INXF	D 
                             C  	DCXF	B 
                             C  	MOV	WORD PTR A,WORD PTR B 
                             C  	ORA	C 
                             C  	JNZ	_-8D 
                             C  ENDM 
                             C  LDDR	MACRO 
                             C  	MOV	WORD PTR A,WORD PTR M 
                             C  	STAX	D 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-6
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  	DCXF	H 
                             C  	DCXF	D 
                             C  	DCXF	B 
                             C  	MOV	WORD PTR A,WORD PTR B 
                             C  	ORA	C 
                             C  	JNZ	_-8D 
                             C  ENDM 
                             C  DJNZ	MACRO	    DEST 
                             C  	DCR	B 
                             C  	JNZ	DEST 
                             C  ENDM 
                             C  ;**********************************************
				********************* 
                             C  ; Define reset routines. 
                             C  ;**********************************************
				********************* 
                             C  FSIGN	MACRO 
                             C  	CALL	SIGN 
                             C  ENDM 
                             C  PUSHM	MACRO 
                             C  	MOV	WORD PTR C,WORD PTR M 
                             C  	INX	H 
                             C  	MOV	WORD PTR B,WORD PTR M 
                             C  	INX	H 
                             C  	PUSH	WORD PTR B 
                             C  ENDM 
                             C  SYNCHK	MACRO	X 
                             C  	CALL	SYNCHR 
                             C  	DB	OFFSET X 
                             C  ENDM 
                             C  OUTCHR	MACRO 
                             C  	CALL	OUTDO 
                             C  ENDM 
                             C  CHRGET	MACRO 
                             C  	CALL	CHRGTR 
                             C  ENDM 
                             C  COMPAR	MACRO 
                             C  	CALL	DCOMPR 
                             C  ENDM 
                             C  GETYPE	MACRO 
                             C  	CALL	GETYPR 
                             C  ENDM 
                             C  COMPAR	MACRO 
                             C  	DB	73O 
                             C  	DB	332O 
                             C   ENDM 
                             C  ACRLF	MACRO 
                             C  	DB	13D 
                             C  	DB	10D 
                             C  ENDM 
                             C  PUSHR	MACRO 
                             C  	PUSH	WORD PTR D 
                             C  	PUSH	WORD PTR B 
                             C  ENDM 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-7
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  POPR	MACRO 
                             C  	POP	WORD PTR B 
                             C  	POP	WORD PTR D 
                             C  ENDM 
                             C  MOVRI	MACRO	B,C,D,E 
                             C  	DB	1O		; "LXI  B" 
                             C  	DB	OFFSET C 
                             C  	DB	OFFSET B 
                             C  	DB	21O		; "LXI  D" 
                             C  	DB	OFFSET E 
                             C  	DB	OFFSET D 
                             C  ENDM 
                             C  INST	MACRO	X 
                             C  	DB	OX 
                             C  ENDM 
                             C   
                             C   
 = 000F                      C  	CONTO=15		;CHARACTER TO SUPRESS OUTPUT (USUALL
				Y CONTROL-O) 
 = 0000                      C  	DBLTRN=0		;FOR DOUBLE PRECISION TRANSCENDENTAL
				S 
                             C   
 = 000E                      C  	CLMWID=14D		;MAKE COMMA COLUMNS FOURTEEN CHARA
				CTERS 
 = 0080                      C  	DATPSC=128D		;NUMBER OF DATA BYTES IN DISK SEC
				TOR 
 = 0050                      C  	LINLN=80D		;TERMINAL LINE LENGTH 
 = 0084                      C  	LPTLEN=132D 
 = 00FF                      C  	BUFLEN=255		;LONG LINES 
 = 0028                      C  	NAMLEN=40D		;MAXIMUM LENGTH NAME -- 3 TO 127 
                             C   
 = 006E                      C  	NUMLEV=110D		;NUMBER OF STACK LEVELS RESERVED 
                             C  				;BY AN EXPLICIT CALL TO GETSTK 
 = 0004                      C  	STRSIZ=4 
 = 0003                      C  	STRSIZ=3 
 = 0003                      C  	NUMTMP=3		;NUMBER OF STRING TEMPORARIES 
 = 000A                      C  	NUMTMP=10 
                             C   
 0008                        C  	.RADIX	8 
                             C  ; 
                             C  ; Useful macros 
                             C  ; 
                             C   
                             C  ACRLF   MACRO 
                             C          DB      13D 
                             C          DB      10D 
                             C  ENDM 
                             C   
                             C  INS86   MACRO   A,B,C,D 
                             C          DB      A&O 
                             C  IFNB    <B> 
                             C          DB      B&O 
                             C  ENDIF 
                             C  IFNB    <D> 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-8
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C          DB      C&O 
                             C          DB      D&O 
                             C  ENDIF 
                             C  IFB     <D> 
                             C   IFNB   <C> 
                             C          DW      C 
                             C    ENDIF 
                             C   ENDIF 
                             C  ENDM 
                             C   
                             C  CALLOS  MACRO 
                             C          CALL    CPMENT 
                             C  ENDM 
                             C   
                             C  POPR    MACRO 
                             C          POP     CX 
                             C          POP     DX 
                             C  ENDM 
                             C   
                             C  ADR     MACRO   X 
                             C          DW      X 
                             C  ENDM 
                             C   
                             C  DC      MACRO   ARG 
                             C          IRPC    ZZ,<ARG> 
                             C              IFDIF       <ZZ>,<">
                             C                  DB      "&ZZ&" 
                             C                  _A="&ZZ&" 
                             C              ENDIF 
                             C          ENDM 
                             C  ENDM 
                             C  ; 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-9
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C          PAGE 
                             C   
                             C   
                             C   
                             C  	TITLE MATH86 8086 MATH PACK 
                             C   
                             C  	.SALL 
 0008                        C  	.RADIX	8 
                             C   
 = 0000                      C  SIXDIG=0			;Floating pnt output 6 bit S.P. numb
				ers 
                             C   
                             C  	PUBLIC	ABSFN,ATN,COS,DADD 
                             C  	PUBLIC	DDIV,DMULT,EXP,FINDBL,FIN,FOUT,FRCDBL 
                             C  	PUBLIC	FRCINT,FRCSNG,INEG,INEG2,INT,LOG,LOPFND
				,NEG 
                             C  	PUBLIC	PUFOUT,RND,SIGN,SIN,SQR,TAN 
                             C  	PUBLIC	VALINT,VINT,VNEG,ZERO,$CDS,$CSD,$CSI 
                             C  	PUBLIC	$DCMPA,$DIV0S,$DZERO,$EXPCN,$FADDS,$FCO
				MP,$FDIVS 
                             C  	PUBLIC	$FI,$FLT,$FMULS,$FOUTH,$FOUTO,$FOUT2,$F
				PWR 
                             C  	PUBLIC	$FSUBD,$FSUBS,$FS,$GETYP,$LOGP,$MOVFA,$
				MOVFM 
                             C  	PUBLIC	$MOVFR,$MOVMF,$MOVRF,$NEG,$NORMD,$NORMS
				,$POPA 
                             C  	PUBLIC	$SIGNS,$VINT,$VPSHF 
                             C   
                             C  	PUBLIC	SIGNS,DCXBRT,FADD,VSIGN,MOVFR,ISIGN,INE
				G2 
                             C  	PUBLIC	IMOD,GETBCD,ISUB,FPWRQ,INRART,MOVRF,DCO
				MP 
                             C  	PUBLIC	VDFACS,MOVFM,FDIVT,ICOMP,VMOVAF,UMULT,F
				OUTH,FSUB 
                             C  	PUBLIC	ICMPA,VMOVFA,IDIV,VMOVFM,IMULT,RNDMN2,B
				LTU,FMULT 
                             C  	PUBLIC	FRCSTR,POPHRT,MOVE,MOVMF,CONIA,VMOVE,RN
				DMON,CHKSTR 
                             C  	PUBLIC	LOPFD1,INPRT,MAKINT,FDIV,SGN,SIGNC,FCOM
				P,INXHRT 
                             C  	PUBLIC	IADD,FOUTO,DSUB,VALSNG,BLTUC,FIXER,MOVR
				M 
                             C  	PUBLIC	FADDS,LINPRT,MOVE1,CONSIH,PUSHF,VMOVMF 
                             C   
                             C  	PUBLIC	STROUT 
                             C  	EXTRN	CRFIN:NEAR,OUTDO:NEAR 
                             C   
                             C   
                             C  	EXTRN	ARYEXT:NEAR,BSERR:NEAR,CHRGTR:NEAR,DV0ER
				R:NEAR,FRQINT:NEAR 
                             C  	EXTRN	INTXT:NEAR,NOTFDD:NEAR,NOTFNS:NEAR,OVERR
				:NEAR 
                             C  	EXTRN	REASON:NEAR,STROUI:NEAR,TMERR:NEAR 
                             C  	EXTRN	$CATTY:NEAR,$CLROV:NEAR,$DIV0M:NEAR,$FLG
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-10
Common file to produce 2-segment 8086 GW-CPM BASIC          

				OC:NEAR 
                             C  	EXTRN	$OHCNS:NEAR,$OVERR:NEAR,$OVMSG:NEAR,$FCE
				RR:NEAR 
                             C  	EXTRN	$SNERR:NEAR,$STPRN:NEAR,$TMERR:NEAR 
                             C   
 0000                        C  DSEG	SEGMENT PUBLIC 'DATASG' 
                             C  	ASSUME DS:DSEG 
                             C  	EXTRN	ARYTA2:WORD,NAMBUF:WORD,NAMCNT:WORD,ONEL
				IN:WORD 
                             C  	EXTRN	STREND:WORD,TEMP3:WORD,VALTYP:WORD 
                             C  	EXTRN	$ARG:WORD,$ARGLO:WORD,$DBUFF:WORD,$DFACL
				:WORD 
                             C  	EXTRN	$DPADR:WORD,$FAC:WORD,$FACLO:WORD,$FACM1
				:WORD,$FBUFF:WORD 
                             C  	EXTRN	$FLGOV:WORD,$FMTAL:WORD,$FMTAX:WORD,$FMT
				CX:WORD,$RNDX:WORD 
                             C  	EXTRN	$VALTP:WORD,$ZLO:WORD,$Z1LO:WORD,$Z1:WOR
				D 
 0000                        C  DSEG	ENDS 
                             C   
                             C   
                             C  	SUBTTL	 $FOTCI  CONVERT INTEGER IN (FACLO) TO 
				ASCII DIGITS 
                             C  ;**********************************************
				*************** 
                             C  ; 
                             C  ;       $FOTCI  CONVERT THE INTEGER IN (FACLO)-
				TWO BYTES TO 
                             C  ;               ASCII DIGITS. 
                             C  ;       CALLING SEQUENCE:       CALL    $FOTCI 
                             C  ;               WITH DECIMAL POINT AND COMMA CO
				UNTS IN (CX) 
                             C  ;       $FOUTO  CONVERT INTEGER IN $FACLO:FACLO
				+1 TO OCTAL 
                             C  ;       $FOUTH  CONVERT INTEGER IN $FACLO:FACLO
				+1 TO HEXIDECIMAL 
                             C  ;       CALLING SEQUENCE:       CALL    $FOUTO/
				$FOUTH 
                             C  ;               WITH $FACLO:FACLO+1 CONTAINING 
				INTEGER TO BE 
                             C  ;               PRINTED. RETURNS WITH (BX) POIN
				TING TO $FBUFF 
                             C  ; 
                             C  ;**********************************************
				**************** 
                             C  	PUBLIC	$FOTCI 
 0000  B4 05                 C  $FOTCI: MOV	AH,LOW 5	;MAX DIGITS TO CONVERT 
 0002  BD 0524 R             C  	MOV	BP,OFFSET $FOITB 
 0005                        C  $FCI4:				;ENTRY FOR FOTCV SO WE WILL ONLY CONV
				ERT 4 DIGITS 
 0005  E8 19A5 R             C  FCI10:	CALL	$FOTED		;CHECK FOR NEEDED D.P. OR "
				," 
                             C  				;TABLE IN CODE SEGMENT 
 0008  2E: 8B 56 00          C  	MOV	DX,WORD PTR CS:0[BP]	;FETCH POWER OF TEN T
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-11
$FOTCI  CONVERT INTEGER IN (FACLO) TO ASCII DIGITS          

				O DX 
 000C  45                    C  	INC	BP		;POINT (BP) TO NEXT PWR 10 
 000D  45                    C  	INC	BP 
 000E  8B 36 0000 E          C  	MOV	SI,WORD PTR $FACLO	;FETCH INTEGER TO BE CO
				NVERTED 
 0012  B0 2F                 C  	MOV	AL,LOW OFFSET "0"-1     ;WILL BUILD DIGIT 
				IN (AL) 
 0014  FE C0                 C  FCI20:	INC	AL 
 0016  2B F2                 C  	SUB	SI,DX		;SUBTRACT OUT POWER OF TEN 
 0018  73 FA                 C  	JNB	FCI20		;CONTINUE UNTIL DIGIT FORMED 
 001A  03 F2                 C  	ADD	SI,DX		;SUBTRACTED OUT ONE TOO MANY 
 001C  88 07                 C  	MOV	BYTE PTR 0[BX],AL	;MOVE DIGIT TO BUFFER 
 001E  43                    C  	INC	BX		;POINT (BX) TO NEXT BUFF POS. 
 001F  89 36 0000 E          C  	MOV	WORD PTR $FACLO,SI	;SAVE UPDATED INTEGER 
 0023  FE CC                 C  	DEC	AH		;LOOP TILL DIGITS FORMED 
 0025  75 DE                 C  	JNZ	FCI10 
 0027  E8 19A5 R             C  	CALL	$FOTED		;SEE IF DECIMAL POINT NEEDED 
 002A  C6 07 00              C  	MOV	BYTE PTR 0[BX],LOW 0	;AND PUT BINARY 
 002D  C3                    C  	RET			;ZERO AFTER. 
 002E                        C  $FOUTO:			;OCTAL OUTPUT OF INTEGER IN $FACLO:FA
				CLO+1 
 002E  B9 0301               C  	MOV	CX,OFFSET 3*400+1	;WILL PROCESS 3 BITS AT 
				A TIME 
 0031  BE 0006               C  	MOV	SI,6		;OCTAL DIGITS 
 0034  EB 06                 C  	JMP	SHORT FTH10 
 0036                        C  $FOUTH:			;HEXIDECIMAL OUTPUT OF INTEGER IN FAC
				LO:FACLO+1 
 0036  B9 0404               C  	MOV	CX,OFFSET 4*400+4	;WILL PROCESS 4 BITS AT 
				A TIME 
 0039  BE 0004               C  	MOV	SI,4		;HEX DIGITS 
 003C  BF 0000 E             C  FTH10:	MOV	DI,OFFSET $FBUFF	;POINT DI TO OUTPUT
				 LOCATION 
 003F  FC                    C  	CLD			;SO SUBSEQUENT STOC WILL INC 
 0040  BB 05A3 R             C  	MOV	BX,OFFSET $NUMB 
 0043  8B 16 0000 E          C  	MOV	DX,WORD PTR $FACLO	;FETCH INTEGER 
 0047  56                    C  	PUSH	SI		;SAVE FOR ZERO SUPPRESS CODE 
 0048  8A C6                 C  FTH20:	MOV	AL,DH		;GET INTEGER 
 004A  32 E4                 C  	XOR	AH,AH		;CLEAR UPPER AX 
 004C  D3 E0                 C  	SHL	AX,CL		;SHIFT HIGH ORDER BITS INTO AH 
 004E  86 E0                 C  	XCHG	AH,AL		;NOW IN AL 
                             C  				;LOOK FROM CODE SEGMENT 
 0050                        C  ?CSLAB:			; Code segment dummy label 
 0050  2E: D7                C  	XLAT	BYTE PTR ?CSLAB ;LOOK-UP ASCII 
 0052  AA                    C  	STOSB 
 0053  D3 E2                 C  	SHL	DX,CL		;SHIFT NUMBER 
 0055  8A CD                 C  	MOV	CL,CH		;GET NO. BITS TO SHIFT 
 0057  4E                    C  	DEC	SI		;DECREMENT NO. OF DIGITS 
 0058  75 EE                 C  	JNZ	FTH20 
 005A  C6 05 00              C  	MOV	BYTE PTR 0[DI],LOW 0	;DENOTE END OF NO. 
 005D  BB 0000 E             C  	MOV	BX,OFFSET $FBUFF 
 0060  59                    C  	POP	CX		;RECALL FOR ZERO SUPPRESS 
 0061  FE C9                 C  	DEC	CL		;CAN'T DELETE ALL THE ZEROS 
 0063  80 3F 30              C  FTH40:	CMP	BYTE PTR 0[BX],LOW "0"  ;DO ZERO SUP
				PRESS 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-12
$FOTCI  CONVERT INTEGER IN (FACLO) TO ASCII DIGITS          

 0066  75 03                 C  	JNZ	FTH50		;NO MORE SUPPRESS 
 0068  43                    C  	INC	BX 
 0069  E2 F8                 C  	LOOP	FTH40 
 006B  C3                    C  FTH50:	RET 
                             C   
                             C  	SUBTTL	 $PUFXE  PRINT USING FIX-UP CODE 
                             C  ;**********************************************
				****************** 
                             C  ; 
                             C  ;       $PUFXE  THIS CODE IS CALLED ONCE PRINT-
				USING ROUTINES 
                             C  ;               HAVE BUILT THE NUMBER IN THE OU
				TPUT BUFFER (FBUFF) 
                             C  ;               ITS JOB IS TO ASSURE THE NUMBER
				 MEETS OUTPUT 
                             C  ;               SPECIFICATIONS. IF THE NUMBER T
				RULY OVERFLOWS THE 
                             C  ;               OUTPUT BUFFER A "%" SIGN WILL B
				E INSERTED AS THE 
                             C  ;               LEADING CHARACTER. 
                             C  ;       CALLING SEQUENCE:       CALL    $PUFXE 
                             C  ;               WITH $FBUFF CONTAINING THE FORM
				ATTED NUMBER 
                             C  ; 
                             C  ;**********************************************
				******************* 
                             C   
 = 0024                      C  	CURNCY="$"	      ;Default floating currency is
				 dollars. 
 006C  53                    C  $PUFXE: PUSH	BX		;SAVE END OF BUFFER POINTER 
 006D  E8 00D4 R             C  	CALL	$FOTZS		;DO ZERO SUPPRESSION 
                             C  				;$FOTZS WILL LEAVE ZF=0 IF THERE IS 
                             C  				;TO BE A TRAILING SIGN AND THE SIGN 
                             C  				;WILL BE LEFT IN (CH) 
 0070  5B                    C  	POP	BX		;RECALL END-OF-BUFFER POINTER 
 0071  74 03                 C  	JZ	PFX10		;IF NO TRAILING SIGN PROCEED 
 0073  88 2F                 C  	MOV	BYTE PTR 0[BX],CH	;PUT IN TRAILING SIGN 
 0075  43                    C  	INC	BX		;MUST NOW PUT IN BINARY ZERO 
 0076  C6 07 00              C  PFX10:	MOV	BYTE PTR 0[BX],LOW 0	;TO SIGNIFY END
				 OF PRINT 
 0079  BB 0000 E             C  	MOV	BX,OFFSET $FBUFF	;FETCH START OF BUFFER AD
				DRESS 
 007C  43                    C  PFX20:	INC	BX		;INCREMENT (BX) TO NEXT BUFFER P
				OSITION 
 007D  8B 3E 0000 E          C  PFX30:	MOV	DI,WORD PTR $DPADR	;GET DECIMAL POIN
				T ADDRESS 
 0081  8B 16 0000 E          C  	MOV	DX,WORD PTR $FMTCX	;FETCH DECIMAL POINT IN
				FO. 
 0085  A0 0001 E             C  	MOV	AL,BYTE PTR $FMTCX+1	;FETCH NO. DIGITS TO 
				LEFT OF D.P. 
 0088  32 E4                 C  	XOR	AH,AH		;(AX) = DIGITS LEFT OF DECIMAL POIN
				T 
 008A  2B FB                 C  	SUB	DI,BX		;WILL FORM THE SUBTRACTION: 
 008C  2B F8                 C  	SUB	DI,AX		;D.P. ADDR.-BUFF PTR-DIGITS LEFT OF
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-13
$PUFXE  PRINT USING FIX-UP CODE                             

				 D.P 
 008E  74 43                 C  	JZ	PFX90		;RETURN IF ALL IS OK. 
                             C  ;**********************************************
				********************** 
                             C  ;FIELD IS CURRENTLY TOO LARGE. WE CAN SHORTEN T
				HE FIELD BY ELIMINATING 
                             C  ;LEADING " " AND "*" CHARACTERS AND A LEADING "
				0" IF THE CHARACTER 
                             C  ;FOLLOWING THE DECIMAL POINT IS A NUMERIC DIGIT
				. DOING THIS ANALYSIS 
                             C  ;WILL BE WHAT THE FOLLOWING SONG & DANCE IS ALL
				 ABOUT 
                             C  ;THE INCREMENT OF (BX) AT PFX20 IN EFFECT SHORT
				ENS THE FIELD BECAUSE 
                             C  ;(BX) WILL POINT TO THE STARTING LOCATION FOR P
				RINTOUT UPON RETURN 
                             C  ;FROM THIS ROUTINE. 
                             C  ;**********************************************
				******************** 
 0090  8A 07                 C  	MOV	AL,BYTE PTR 0[BX]	;FETCH NEXT CHARACTER IN
				 BUFFER 
 0092  3C 20                 C  	CMP	AL,LOW " "      ;SPACE? 
 0094  74 E6                 C  	JZ	PFX20		;IF SO ELIMINATE AND SEE IF NOW OK 
 0096  3C 2A                 C  	CMP	AL,LOW "*"      ;IF ASTERISK FILL THEN AST
				ERISK? 
 0098  74 E2                 C  	JZ	PFX20 
 009A  B4 01                 C  	MOV	AH,LOW 1	;TO SIGNAL END OF CHARACTERS IN 
                             C  				;THE FOLLOWING CODE 
 009C  4B                    C  	DEC	BX		;BECAUSE $CHRGT WILL DO INC BX FIRST 
 009D  53                    C  	PUSH	BX		;SAVE THIS LOCATION FOR POSSIBLE "%" 
 009E  50                    C  PFX40:	PUSH	AX 
 009F  E8 0E5B R             C  	CALL	$CHRGT		;GET NEXT CHARACTER( NOTE THAT TH
				IS 
                             C  				;RE-FETCHES THE PREVIOUS FAILING 
                             C  				;CHARACTER THE FIRST TIME THROUGH) 
 00A2  32 E4                 C  	XOR	AH,AH		;CLEAR (AH) 
 00A4  3C 2D                 C  	CMP	AL,LOW "-"      ;IF EQUAL NEED TO SAVE THI
				S GUY 
 00A6  74 F6                 C  	JZ	PFX40		;GO SAVE AND GET NEXT CHAR. 
 00A8  3C 2B                 C  	CMP	AL,LOW "+" 
 00AA  74 F2                 C  	JZ	PFX40		;GO SAVE THIS GUY IF EQUAL 
 00AC  3C 24                 C  	CMP	AL,LOW OFFSET CURNCY 
 00AE  74 EE                 C  	JZ	PFX40		;GO SAVE IF EQUAL 
 00B0  3C 30                 C  	CMP	AL,LOW "0"      ;IF EQUAL POSSIBLE TO ELIM
				INATE 
 00B2  75 16                 C  	JNZ	PFX70		;MUST GIVE UP AND PUT LEADING "%" 
                             C  ;**********************************************
				**************** 
                             C  ;AT THIS POINT WE HAVE A LEADING ZERO. IT CAN B
				E ELIMINATED 
                             C  ;ONLY IF THERE ARE DIGITS BEYOND THE DECIMAL PO
				INT. IF THIS 
                             C  ;IS THE CASE WE HAVE POSITIONED TO THE CORRECT 
				PLACE AND 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-14
$PUFXE  PRINT USING FIX-UP CODE                             

                             C  ;HAVE CHARACTERS TO MOVE DOWN IN THE STACK AND 
				CAN ELIMINATE 
                             C  ;THE ZERO BY NOT PUSHING IT ON THE STACK SINCE 
				ALL 
                             C  ;CHARACTERS TO BE RE-INSERTED WILL COME FROM TH
				E STACK. 
                             C  ;**********************************************
				***************** 
 00B4  43                    C  	INC	BX		;THIS WILL CAUSE ELIMINATION OF "0" 
 00B5  E8 0E5B R             C  	CALL	$CHRGT		;GET CHARACTER AFTER DECIMAL POIN
				T 
 00B8  73 10                 C  	JNB	PFX70		;NO HOPE GIVE UP AND PUT IN "%" 
 00BA  4B                    C  	DEC	BX		;(BX) NOW POINTS TO DECIMAL POINT 
 00BB  EB 03                 C  	JMP	SHORT PFX60 
 00BD  4B                    C  PFX50:	DEC	BX		;NEXT CHARACTER POSITION TO MOVE
				 INTO 
 00BE  88 07                 C  	MOV	BYTE PTR 0[BX],AL	;MOVE IT IN 
 00C0  58                    C  PFX60:	POP	AX		;FETCH CHARACTER OFF THE STACK 
 00C1  0A E4                 C  	OR	AH,AH		;ONCE (AH)=1 IS REACHED CHARS. 
                             C  				;HAVE BEEN RE-ENSTATED 
 00C3  74 F8                 C  	JZ	PFX50		;KEEP GOING IF (AH)=0 
 00C5  83 C4 02              C  	ADD	SP,2		;GET OLD START OF BUFFER ADDRESS OFF
				 
                             C  				;THE STACK 
 00C8  EB B3                 C  	JMP	SHORT PFX30	;AND SEE IF WE NOW FIT INTO TH
				E 
                             C  				;REQUIRED SPACE 
 00CA                        C  PFX70: 
                             C  ;**********************************************
				******************** 
                             C  ;WE COULD NOT FIT THE NUMBER INTO THE BUFFER DE
				SPITE OUR VALIENT 
                             C  ;EFFORTS WE MUST POP ALL THE CHARACTERS BACK OF
				F THE STACK AND 
                             C  ;POP OFF THE BEGINNING BUFFER PRINT LOCATION AN
				D INPUT A "%" SIGN 
                             C  ;THERE 
                             C  ;**********************************************
				******************** 
 00CA  58                    C  	POP	AX		;GET CHARACTER OFF THE STACK 
 00CB  0A E4                 C  	OR	AH,AH		;IF ZF=1 AFTER THIS-MORE CHARS. 
 00CD  74 FB                 C  	JZ	PFX70 
 00CF  5B                    C  	POP	BX		;GET BEGINNING BUFFER POINTER 
 00D0  C6 07 25              C  	MOV	BYTE PTR 0[BX],LOW "%"  ;INSERT OVERFLOW F
				LAG 
 00D3  C3                    C  PFX90:	RET 
                             C   
                             C  	SUBTTL	 $FOTZS  ZERO SUPRESSION UPON OUTPUT RO
				UTINE 
                             C  ;**********************************************
				*************** 
                             C  ; 
                             C  ;       $FOTZS  THIS ROUTINE WILL LOOK AT THE O
				UTPUT GENERATED 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-15
$FOTZS  ZERO SUPRESSION UPON OUTPUT ROUTINE                 

                             C  ;               BY THE REST OF THE PUFOT ROUTIN
				ES AND SUPRESS 
                             C  ;               LEADING ZEROES. 
                             C  ;       CALLING SEQUENCE:       CALL    $FOTZS 
                             C  ;               ONLY PREREQUISITE IS THAT OTHER
				 PUFOT ROUTINES 
                             C  ;               HAVE EXECUTED TO PROVIDE FOTZS 
				WITH $FBUFF 
                             C  ;               CONTAINING OUTPUT TEXT. 
                             C  ; 
                             C  ;       $FOTZ   THIS ROUTINE PUTS IN (AL) LEADI
				NG ZEROS 
                             C  ;       CALLING SEQUENCE:       CALL    $FOTZ 
                             C  ;               WITH (AL) SET TO NO. OF LEADING
				 ZEROS DESIRED 
                             C  ;       $FOTZC  THIS ROUTINE PUTS IN (AL) LEADI
				NG ZEROS AND 
                             C  ;               PAYS ATTENTION TO DECIMAL POINT
				 AND COMMA COUNTS 
                             C  ;               AND FURTHER PUTS IN COMMAS AND 
				A D.P. AS NECESSARY 
                             C  ;       CALLING SEQUENCE:       CALL    $FOTZC 
                             C  ;               WITH (CX) SET TO NO. PLACES TO 
				LEFT/RIGHT OF D.P. 
                             C  ;               AND (AL) TO NO. LEADING ZEROS 
                             C  ;**********************************************
				*************** 
                             C   
                             C   
 = 0024                      C  	CURNCY="$"	      ;Default floating currency is
				 dollars. 
                             C   
 00D4  BB 0001 E             C  $FOTZS: MOV	BX,OFFSET $FBUFF+1	;ADDRESS OF SIGN
				(IF LEADING) 
 00D7  8A 2F                 C  	MOV	CH,BYTE PTR 0[BX]	;FETCH LEADING CHARACTER
				 
 00D9  B1 20                 C  	MOV	CL,LOW " "      ;SPACE TO CL 
 00DB  8A 26 0000 E          C  	MOV	AH,BYTE PTR $FMTAL	;FETCH FORMAT SPECIFICA
				TIONS 
                             C  				;BIT    76543210        OF AH 
                             C  				;       ABCDEFGH        WHERE 
                             C  				;A=FREE FORMAT FLAG 
                             C  				;B=GROUP INTEGER DIGITS IN 3'S AND 
                             C  				;  SEPARATE WITH COMMAS 
                             C  				;C=FILL LEADING SPACES WITH "*" 
                             C  				;D=OUTPUT WITH FLOATING "$" 
                             C  				;E=PRINT SIGN WITH "+" INSTEAD OF" " 
                             C  				;F=PRINT SIGN AS TRAILING 
                             C  				;G=UNUSED 
                             C  				;H=USE SCIENTIFIC NOTATION 
 00DF  F6 C4 20              C  	TEST	AH,LOW 40	;WILL TEST FOR LEADING "*" FIRS
				T 
 00E2  74 0D                 C  	JZ	FZ10		;LEADING ASTERISKS NOT DESIRED IF JMP
				 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-16
$FOTZS  ZERO SUPRESSION UPON OUTPUT ROUTINE                 

 00E4  3A E9                 C  	CMP	CH,CL		;SPACE? 
 00E6  B1 2A                 C  	MOV	CL,LOW "*"      ;SINCE IT'S ASTERISK FILL 
				DESIRED 
 00E8  75 07                 C  	JNZ	FZ10		;JUMP IF NOT SPACE 
 00EA  F6 C4 04              C  	TEST	AH,LOW 4	;WILL NOW CHECK FOR TRAILING SIG
				N 
 00ED  75 02                 C  	JNZ	FZ10 
 00EF  8A E9                 C  	MOV	CH,CL 
 00F1  88 0F                 C  FZ10:	MOV	BYTE PTR 0[BX],CL	;REPLACE SIGN AS NE
				CESSARY 
 00F3  E8 0E5B R             C  	CALL	$CHRGT		;GET NEXT CHARACTER AND SET CONDI
				TION 
 00F6  74 31                 C  	JZ	FZ50		;CODES. JUMP IF END OF NUMBER 
 00F8  BD 04D4 R             C  	MOV	BP,OFFSET $FINCH+11 
 00FB                        C  FZ20: 
 00FB  2E: 3A 46 00          C  	CMP	AL,BYTE PTR CS:0[BP]	;SEE IF SPECIAL CHARA
				CTER 
 00FF  74 09                 C  	JZ	FZ30		; 
 0101  81 FD 04CB R          C  	CMP	BP,OFFSET $FINCH	;SEE IF         SEARCHED 
				ALL TABLE 
 0105  74 26                 C  	JZ	FZ60		;IF SO GO CHECK FOR FLOATING "$" 
 0107  4D                    C  	DEC	BP		;POINT TO NEXT SPECIAL CHARACTER 
 0108  EB F1                 C  	JMP	SHORT FZ20	;AND CONTINUE   SEARCH 
 010A  81 ED 04CB R          C  FZ30:	SUB	BP,OFFSET $FINCH	;CALCULATE TABLE OFF
				SET 
 010E  D1 E5                 C  	SHL	BP,1		;TO ACCOUNT FOR 2 BYTE TABLE ENTRY 
                             C  				;ADD BASE ADDRESS (BP) NOW HAS ADDR. 
 0110                        C  FZ40: 
                             C  				;CODE SEGMENT OVERRIDE 
 0110  2E: FF A6 0115 R      C  	JMP	 WORD PTR CS:FZ45[BP] 
 0115                        C  FZ45  LABEL WORD 
 0115  0129 R                C  	DW	OFFSET FZ50	;"." 
 0117  0129 R                C  	DW	OFFSET FZ50	;"E" 
 0119  012D R                C  	DW	OFFSET FZ60	;"E"+40 
 011B  012D R                C  	DW	OFFSET FZ60	;"%" 
 011D  012D R                C  	DW	OFFSET FZ60	;"#" 
 011F  012D R                C  	DW	OFFSET FZ60	;"!" 
 0121  0129 R                C  	DW	OFFSET FZ50	;"D" 
 0123  012D R                C  	DW	OFFSET FZ60	;"D"+40 
 0125  00F1 R                C  	DW	OFFSET FZ10	;"," 
 0127  00F1 R                C  	DW	OFFSET FZ10	;"0" 
 0129  4B                    C  FZ50:	DEC	BX		;NEED TO PUT IN LEADING "0" 
 012A  C6 07 30              C  	MOV	BYTE PTR 0[BX],LOW "0" 
 012D  8A 26 0000 E          C  FZ60:	MOV	AH,BYTE PTR $FMTAL	;GET FORMAT SPECS 
				AGAIN 
 0131  F6 C4 10              C  	TEST	AH,LOW 20	;TEST FOR FLOATING "$" 
                             C  				;FLOATING "$" DESIRED? 
 0134  74 04                 C  	JZ	FZ70		;IF NOT PROCEED 
 0136  4B                    C  	DEC	BX		; 
 0137  C6 07 24              C  	MOV	BYTE PTR 0[BX],LOW OFFSET CURNCY	;PUT IN F
				LOATING "$" 
 013A  F6 C4 04              C  FZ70:	TEST	AH,LOW 4	;RECALL FORMAT SPECS 
                             C  				;SEE IF TRAILING SIGN 
 013D  75 05                 C  	JNZ	FZ90		;IF SO RETURN 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-17
$FOTZS  ZERO SUPRESSION UPON OUTPUT ROUTINE                 

 013F  4B                    C  	DEC	BX 
 0140  88 2F                 C  	MOV	BYTE PTR 0[BX],CH	;PUT IN SIGN 
 0142  32 ED                 C  	XOR	CH,CH		;MUST RETURN ZF=1 IF NOT TRAILING 
                             C  				;SIGN. 
 0144  C3                    C  FZ90:	RET 
 0145                        C  $FOTZ:				;PUT (AL) LEADING ZEROS IN BUFFER POI
				NTED TO BY (BX) 
 0145  0A C0                 C  	OR	AL,AL		;SEE IF FURTHER WORK TO DO 
 0147  EB 06                 C  	JMP	SHORT FTZ15 
 0149  C6 07 30              C  FTZ10:	MOV	BYTE PTR 0[BX],LOW "0"  ;PUT IN LEAD
				ING ZERO 
 014C  43                    C  	INC	BX		;NEXT BUFFER POSITION 
 014D  FE C8                 C  	DEC	AL 
 014F  75 F8                 C  FTZ15:	JNZ	FTZ10 
 0151  C3                    C  	RET 
                             C   
 0152  E8 19A5 R             C  FTZC10: CALL	$FOTED		;PUT IN COMMA AND DECIMAL 
				POINT AS 
                             C  				;NECESSARY 
 0155  C6 07 30              C  $FOTZC: MOV	BYTE PTR 0[BX],LOW "0"  ;PUT IN LEA
				DING ZERO 
 0158  43                    C  	INC	BX		;NEXT BUFFER POSITION 
 0159  FE C8                 C  	DEC	AL		; 
 015B  75 F5                 C  	JNZ	FTZC10 
 015D  C3                    C  	RET 
                             C   
                             C   
                             C  	SUBTTL	 $PUFE	 PRINT USING FLOATING IN "E" TYP
				E FORMAT 
                             C  ;**********************************************
				************** 
                             C  ; 
                             C  ;       $PUFE   THIS ROUTINE IS CALLED TO FORMA
				T A SINGLE 
                             C  ;               OR DOUBLE PRECISION NUMBER WITH
				 A DESIRED 
                             C  ;               "E" TYPE OUTPUT FORMAT. FURTHER
				 SPECIFICATIONS 
                             C  ;               CAN BE THE NUMBER DESIRED PRINT
				 POSITIONS 
                             C  ;               TO THE LEFT AND RIGHT OF THE DE
				CIMAL POINT. 
                             C  ;       CALLING SEQUENCE:       CALL    $PUFE 
                             C  ;               WITH (BX) POINTING TO THE CURRE
				NT OUTPUT POSITION 
                             C  ;               AND ZF=1 IF THE OUTPUT NUMBER I
				S SINGLE 
                             C  ;               PRECISION, ZF=0 IF DOUBLE PRECI
				SION. 
                             C  ; 
                             C  ;**********************************************
				*************** 
                             C   
 015E  E8 08EE R             C  $PUFE:	CALL	$GETYP		;SET CONDITION CODES ACCORD
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-18
$PUFE	 PRINT USING FLOATING IN "E" TYPE FORMAT              

				ING TO TYPE 
                             C   
                             C   
 0161  B4 07                 C  	MOV	AH,LOW 7	;7 print positions if single prec
				ision 
                             C   
 0163  72 02                 C  	JB	PFE10		;AND JUMP IF SINGLE PRECISION 
 0165  B4 10                 C  	MOV	AH,LOW 20	;IT'S DOUBLE 
 0167  E8 08BE R             C  PFE10:	CALL	$SIGNS		;SET COND CODES ACCORDING T
				O NO. 
 016A  5B                    C  	POP	BX		;GET BUFFER PTR IN CASE NO. IS ZERO 
 016B  F9                    C  	STC			;CF WILL BE OUR FLAG TO REMEMBER 
 016C  74 09                 C  	JZ	PFE20		;IF THE NO. WAS ZERO SINCE $FOTNV 
                             C  				;WILL RETURN WITH CF=0 
 016E  53                    C  	PUSH	BX		;SAVE BUFFER PTR 
 016F  50                    C  	PUSH	AX		;SAVE NO. DIGITS IN NUMBER 
 0170  E8 1AC0 R             C  	CALL	$FOTNV		;BRACKET NO. SO DIGITS TO PRINT A
				RE 
                             C  				;IN THE INTEGER PART 
 0173  5A                    C  	POP	DX		;$FOTNV ALSO RETURNS WITH EXPONENT 
                             C  				;IN (AL) 
 0174  5B                    C  	POP	BX		;CF=0 
 0175  8A E6                 C  	MOV	AH,DH		;(AH)=NO DIGITS RETURNED FROM $FOTN
				V 
 0177  9C                    C  PFE20:	PUSHF			;SAVE CF FLAG IN CASE NO. IS ZER
				O 
 0178  50                    C  	PUSH	AX		;SAVE EXP. AND NO. SIG. DIGITS 
 0179  8B 16 0000 E          C  	MOV	DX,WORD PTR $FMTCX	;DIG LEFT/RT.OF D.P. 
 017D  0A F6                 C  	OR	DH,DH		;WILL NEED TO KNOW IF SIGN DESIRED 
 017F  9C                    C  	PUSHF 
 0180  0A D2                 C  	OR	DL,DL		;SEE IF DECIMAL POINT DESIRED. 
 0182  74 02                 C  	JZ	PFE30		;IF NOT PROCEED 
 0184  FE CA                 C  	DEC	DL		; 
 0186  02 F2                 C  PFE30:	ADD	DH,DL		;NO. DIGITS DESIRED 
 0188  9D                    C  	POPF			;SEE IF SIGN DESIRED 
 0189  74 09                 C  	JZ	PFE40		;JUMP IF NOT DESIRED 
 018B  F6 06 0000 E 04       C  	TEST	BYTE PTR $FMTAX,LOW 4	;SEE IF TRAILING SI
				GN DESIRED 
 0190  75 02                 C  	JNZ	PFE40		;IF SO PROCEED 
 0192  FE CE                 C  	DEC	DH		;MUST USE ONE PRINT POSITION FOR SIGN 
 0194  2A F4                 C  PFE40:	SUB	DH,AH		;MUST SEE IF HAVE EXCESS DIGI
				TS AVAIL. 
 0196  8A E6                 C  	MOV	AH,DH		;IF TO MANY WE MUST DIVIDE NO BY 
                             C  				;10 UNTIL CORRECT DIGITS . 
 0198  50                    C  	PUSH	AX		;SAVE COMPAREISON OF DESIRED-AVAILABL
				E 
                             C  				;DIGITS. AH IS GREATER THAN 0 IF 
                             C  				;TRAILING ZEROS. 
 0199  78 03                 C  	JS	PFE45 
 019B  EB 4F 90              C  	JMP	PFE65		;IF NO INTERNAL ROUNDING PROCEED 
                             C  ;**********************************************
				*********************** 
                             C  ;WHAT IS HAPPENING HERE IS THAT IF WE HAVE MORE
				 DIGITS THAN REQUIRED 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-19
$PUFE	 PRINT USING FLOATING IN "E" TYPE FORMAT              

                             C  ;WE MUST DIVIDE OUT THE EXCESS DIGITS SO THAT W
				E CAN ROUND AT THE 
                             C  ;CORRECT PRINT POSITION. ONCE WE HAVE PERFORMED
				 THIS DIVISION WE 
                             C  ;WILL NEED TO CALCULATE THE CORRECT DECIMAL POI
				NT POSITION BY ADDING 
                             C  ;THE DESIRED PRINT POSITIONS TO THE LEFT TO THE
				 NUMBER OF POSITIONS 
                             C  ;WE SHIFTED OUT. THE REASON FOR THIS IS THAT RE
				GARDLESS OF THE SIZE 
                             C  ;OF THE NUMBER WE GO TO $FOTCV WITH , A FIXED N
				UMBER OF DIGITS 
                             C  ;WILL BE PLACED IN THE OUTPUT BUFFER. FOR EXAMP
				LE, SAY WE REQUESTED 
                             C  ;A PRINT LIKE ##.###^^^^  FOR A SINGLE PRECISIO
				N NUMBER. $FOTNV WILL 
                             C  ;PRODUCE AN INTEGER OF 7 DIGITS SAY AXXXXXX WHE
				RE A IS NON-ZERO 
                             C  ;USING THE LEADING POSITION FOR THE SIGN WE NEE
				D ONLY FOUR DIGITS 
                             C  ;PRINTED SO WE NEED IT ROUNDED AT THE FOURTH PO
				SITION. TO DO THIS WE 
                             C  ;DIVIDE THE AXXXXXX BY 10 THREE TIMES TO GET AX
				XX.XXX  ,  WHEN 
                             C  ;WE GO TO $FOTCV , HE WILL ROUND THIS NUMBER AN
				D PRODUCE AN OUTPUT 
                             C  ; OF   000AXXX  IN THE OUTPUT BUFFER. THE CORRE
				CT PRINT POSITION 
                             C  ;FOR THE DECIMAL POINT IS BETWEEN "A" AND "X". 
				THIS IS CALCULATED 
                             C  ;AS  PRINT POSITION= POSITIONS TO LEFT+SIGN+NO.
				 POSITIONS DIVIDED 
                             C  ;OFF. 
                             C  ;**********************************************
				******************* 
 019E  53                    C  PFE45:	PUSH	BX		;SAVE BUFFER PTR. 
 019F  50                    C  	PUSH	AX		;SAVE NO TIMES TO DIVIDE 
 01A0  50                    C  PFE50:	PUSH	AX		;SAVE DIVIDE COUNT 
 01A1  E8 0914 R             C  	CALL	$DIV10		;SHIFT NO TO GET CORRECT ROUNDING
				 
 01A4  58                    C  	POP	AX		;RECALL DIVIDE COUNT 
 01A5  FE C4                 C  	INC	AH		;INCREMENT TO REFLECT DIVIDE 
 01A7  75 F7                 C  	JNZ	PFE50		;CONTINUE UNTIL GET CORRECT NO. 
 01A9  E8 08FA R             C  	CALL	$VADDH		;ROUND UP AT THE CORRECT POSITION
				 
 01AC  E8 0BEE R             C  	CALL	$VINT		;AND MAKE INTEGER 
 01AF  58                    C  	POP	AX		;RECALL NO. DIVIDES 
 01B0  50                    C  	PUSH	AX		;SAVE # DIVIDES 
 01B1  B9 0003               C  	MOV	CX,3		;WILL SHIFT AH 3 BITS LEFT 
 01B4  D2 E4                 C  	SHL	AH,CL		;BECAUSE DP TABLE IS 8 BYTES/ENTRY 
 01B6  E8 08EE R             C  	CALL	$GETYP		;DETERMINE TYPE 
 01B9  72 10                 C  	JB	PFE55		;JUMP IF SINGLE PRECISION 
 01BB  8A C4                 C  	MOV	AL,AH		;WILL CONVERT AH TO WORD IN AX 
 01BD  98                    C  	CBW 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-20
$PUFE	 PRINT USING FLOATING IN "E" TYPE FORMAT              

 01BE  BB 03E1 R             C  	MOV	BX,OFFSET $DP16 ;ADDRESS OF 10^16 
 01C1  03 D8                 C  	ADD	BX,AX		;FAC SHOULD BE LESS THAN NO. POINTE
				D 
 01C3  E8 09BB R             C  	CALL	$MOVBF		;MOVE CODE SEG NO. TO DBUFF 
 01C6  E8 0AD2 R             C  	CALL	$DCMPM		;TO BY BX 
 01C9  EB 0E                 C  	JMP	SHORT PFE57 
 01CB                        C  PFE55: 
                             C   
                             C   
 01CB  BB 039D R             C  	MOV	BX,OFFSET $DP07+4	;address of 10^7 
                             C   
 01CE  8A C4                 C  	MOV	AL,AH		;WILL CONVERT AH TO WORD IN AX 
 01D0  98                    C  	CBW 
 01D1  03 D8                 C  	ADD	BX,AX		;FAC SHOULD BE LESS THAN THIS NO 
 01D3  E8 09B3 R             C  	CALL	$MOVBS		;MOVE CODE SEG NO. TO DBUFF 
 01D6  E8 0A80 R             C  	CALL	$COMPM		;UNLESS ROUND UP HAS OCCURRED 
 01D9  58                    C  PFE57:	POP	AX		;RECALL NO. DIVIDES. WE MAY NEED
				 
 01DA  5B                    C  	POP	BX		;GET BUFFER PTR BACK 
 01DB  78 11                 C  	JS	PFE66		;ROUND-UP DID NOT OCCUR 
 01DD  58                    C  	POP	AX		;MUST GET TO ORIGINAL COPY 
 01DE  59                    C  	POP	CX		;EXPONENT NOW IN CL 
 01DF  FE C1                 C  	INC	CL		;MUST INCREMENT EXPONENT 
 01E1  51                    C  	PUSH	CX		;SAVE EXP ON STACK 
 01E2  50                    C  	PUSH	AX		;SAVE FOR POSSIBLE TRAILING ZEROS 
 01E3  53                    C  	PUSH	BX		;SAVE BUFFER PTR 
 01E4  50                    C  	PUSH	AX		;SAVE DIVIDED OUT DIGITS & EXPONENT 
 01E5  E8 0914 R             C  	CALL	$DIV10		;SO CORRECT DIGITS TO RIGHT OF 
 01E8  58                    C  	POP	AX 
 01E9  5B                    C  	POP	BX		;DECIMAL POINT ARE PRINTED 
 01EA  EB 02                 C  	JMP	SHORT PFE66 
 01EC  32 E4                 C  PFE65:	XOR	AH,AH		;NO DIVIDES 
 01EE  F6 DC                 C  PFE66:	NEG	AH		;IF PREVIOUSLY NEGATIVE MAKE POS
				ITIVE 
 01F0  A0 0001 E             C  	MOV	AL,BYTE PTR $FMTCX+1	;GET DESIRED PLACES T
				O LEFT OF DEC. PT. 
 01F3  02 E0                 C  	ADD	AH,AL		;NEW TOTAL 
 01F5  FE C4                 C  	INC	AH		;BECAUSE FOTED DECREMENTS AT FIRST 
 01F7  0A C0                 C  	OR	AL,AL		;SEE IF PLACES LEFT DESIRED 
 01F9  74 09                 C  	JZ	PFE70 
 01FB  F6 06 0000 E 04       C  	TEST	BYTE PTR $FMTAX,LOW 4	;SEE IF TRAILING SI
				GN 
 0200  75 02                 C  	JNZ	PFE70		;IF TRAILING SIGN PROCEED 
 0202  FE CC                 C  	DEC	AH		;ALLOW PRINT POSITION FOR SIGN 
 0204  8A EC                 C  PFE70:	MOV	CH,AH		;SET DECIMAL POINT POSITION 
 0206  32 C9                 C  	XOR	CL,CL		;NO COMMAS FOR EXPONENTIAL PRINTOUT
				 
 0208  58                    C  	POP	AX		;RECALL SIG. DIGIT COMPARISON 
 0209  FF 36 0000 E          C  	PUSH	WORD PTR $FMTCX ;SAVE FORMAT SPECS 
 020D  50                    C  	PUSH	AX		;SAVE SIG. DIGIT COMPARISON 
 020E  88 2E 0001 E          C  	MOV	BYTE PTR $FMTCX+1,CH	;UPDATE DIGITS TO LEF
				T 
 0212  E8 19C4 R             C  	CALL	$FOTCV		;CONVERT TO ASCII DIGITS 
 0215  58                    C  	POP	AX		;RECALL SIG. DIGIT COMPARISON 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-21
$PUFE	 PRINT USING FLOATING IN "E" TYPE FORMAT              

 0216  0A E4                 C  	OR	AH,AH		;WILL SET SF=0 IF TRAILING ZEROS 
 0218  7E 08                 C  	JLE	PFE80		;IF TRAILING ZEROS NOT REQ. JUMP 
 021A  8A C4                 C  	MOV	AL,AH		;NO. TRAILING ZEROS TO AL 
 021C  E8 0155 R             C  	CALL	$FOTZC		;put in trailing zeros 
 021F  E8 19A5 R             C  	CALL	$FOTED		;put in decimal point (if necessa
				ry) 
 0222  58                    C  PFE80:	POP	AX		;FETCH DIGITS TO LEFT/RT. OF D.P
				. 
 0223  A3 0000 E             C  	MOV	WORD PTR $FMTCX,AX	;KEEP COPY FORMAT SPECS
				 
 0226  0A C0                 C  	OR	AL,AL		;SEE IF DECIMAL POINT DESIRED 
 0228  75 0C                 C  	JNZ	PFE100		;IF SO PROCEED 
 022A  4B                    C  	DEC	BX		;NOT DESIRED SEE IF CAN ELIMINATE 
 022B  8A 07                 C  	MOV	AL,BYTE PTR 0[BX]	;FETCH LAST PRINT POSITI
				ON 
 022D  3C 2E                 C  	CMP	AL,LOW "."      ;DECIMAL POINT? 
 022F  74 01                 C  	JZ	PFE90		;IF SO THIS JUMP WILL ELIMINATE 
 0231  43                    C  	INC	BX		;MUST RETAIN AS IS 
 0232  89 1E 0000 E          C  PFE90:	MOV	WORD PTR $DPADR,BX	;SAVE ADDRESS OF 
				DECIMAL POINT 
 0236  58                    C  PFE100: POP	AX		;RECALL EXPONENT 
 0237  9D                    C  	POPF			;RECALL CF (=1 IF NO. IS ZERO) 
 0238  72 15                 C  	JB	PFE110		;JUMP IF NO. IS ZERO 
 023A  02 C4                 C  	ADD	AL,AH		;ADD EXP. AND NO SIG. DIGITS 
 023C  8A 26 0001 E          C  	MOV	AH,BYTE PTR $FMTCX+1	;SUBTRACT OUT DIGITS 
				TO LEFT OF D.P. 
 0240  2A C4                 C  	SUB	AL,AH		;SUBTRACT DIGITS TO LEFT 
 0242  0A E4                 C  	OR	AH,AH		;IF NONE THEN NO SIGN 
 0244  74 09                 C  	JZ	PFE110 
 0246  F6 06 0000 E 04       C  	TEST	BYTE PTR $FMTAX,LOW 4	;IF SO WILL NEED TO
				 INCREMENT AL 
 024B  75 02                 C  	JNZ	PFE110 
 024D  FE C0                 C  	INC	AL		;MUST ACCOUNT FOR SIGN POSITION 
 024F  0A C0                 C  PFE110: OR	AL,AL 
 0251  E8 0860 R             C  	CALL	$PUEXP		;PUT EXPONENT IN BUFFER 
                             C  				;$PUEXP IS LOCATED IN THE FILE WITH 
                             C  				;$FOFMT. WHEN HE FINISHES BUILDING 
                             C  				;THE EXPONENT IN $FBUFF HE LEAVES 
                             C  				;THE END-OF-BUFFER POINTER IN CX 
                             C  				;AND START OF BUFFER IN BX. 
 0254  8B D9                 C  	MOV	BX,CX		;MUST GO TO PUFXE WITH END OF 
                             C  				;BUFFER PTR. IN BX 
 0256  E9 006C R             C  	JMP	$PUFXE		;DO FIX-UP 
                             C   
                             C  	SUBTTL	 CON86	 8086 BASIC CONSTANTS 
                             C  ;**********************************************
				******************* 
                             C  ; 
                             C  ;       THIS FILE CONTAINS 8086 CONSTANT TABLES
				 
                             C  ; 
                             C  ;**********************************************
				******************* 
 0259                        C  $FOTB: 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-22
CON86	 8086 BASIC CONSTANTS                                 

 000A                        C  	.RADIX	10 
 0259  26 26 26 26 26 26 26  C  	DB	38,38,38,38,38,38,38,38 
       26                    C  
 0261  26 26 26 26 26 26 26  C  	DB	38,38,38,38,38,38,38,38 
       26                    C  
 0269  26 26 26 26 26 26 26  C  	DB	38,38,38,38,38,38,38,38 
       26                    C  
 0271  26 25 25 25 24 24 24  C  	DB	38,37,37,37,36,36,36,35 
       23                    C  
 0279  23 23 22 22 22 22 21  C  	DB	35,35,34,34,34,34,33,33 
       21                    C  
 0281  21 20 20 20 1F 1F 1F  C  	DB	33,32,32,32,31,31,31,31 
       1F                    C  
 0289  1E 1E 1E 1D 1D 1D 1D  C  	DB	30,30,30,29,29,29,29,28 
       1C                    C  
 0291  1C 1C 1B 1B 1B 1A 1A  C  	DB	28,28,27,27,27,26,26,26 
       1A                    C  
 0299  19 19 19 19 18 18 18  C  	DB	25,25,25,25,24,24,24,23 
       17                    C  
 02A1  17 17 17 16 16 16 16  C  	DB	23,23,23,22,22,22,22,21 
       15                    C  
 02A9  15 15 14 14 14 13 13  C  	DB	21,21,20,20,20,19,19,19 
       13                    C  
 02B1  13 12 12 12 11 11 11  C  	DB	19,18,18,18,17,17,17,16 
       10                    C  
 02B9  10 10 10 0F 0F 0F 0E  C  	DB	16,16,16,15,15,15,14,14 
       0E                    C  
 02C1  0E 0D 0D 0D 0D 0C 0C  C  	DB	14,13,13,13,13,12,12,12 
       0C                    C  
 02C9  0B 0B 0B 0A 0A 0A 0A  C  	DB	11,11,11,10,10,10,10,09 
       09                    C  
 02D1  09 09 08 08 08 07 07  C  	DB	09,09,08,08,08,07,07,07 
       07                    C  
 02D9  06 06 06 06 05 05 05  C  	DB	06,06,06,06,05,05,05,04 
       04                    C  
 02E1  04 04 03 03 03 03 02  C  	DB	04,04,03,03,03,03,02,02 
       02                    C  
 02E9  02 01 01 01 00 00 00  C  	DB	02,01,01,01,00,00,00,00 
       00                    C  
 02F1  FF FF FF FE FE FE FD  C  	DB	-01,-01,-01,-02,-02,-02,-03,-03 
       FD                    C  
 02F9  FD FD FC FC FC FB FB  C  	DB	-03,-03,-04,-04,-04,-05,-05,-05 
       FB                    C  
 0301  FA FA FA FA F9 F9 F9  C  	DB	-06,-06,-06,-06,-07,-07,-07,-08 
       F8                    C  
 0309  F8 F8 F7 F7 F7 F7 F6  C  	DB	-08,-08,-09,-09,-09,-09,-10,-10 
       F6                    C  
 0311  F6 F5 F5 F5 F4 F4 F4  C  	DB	-10,-11,-11,-11,-12,-12,-12,-12 
       F4                    C  
 0319  F3 F3 F3 F2 F2 F2 F1  C  	DB	-13,-13,-13,-14,-14,-14,-15,-15 
       F1                    C  
 0321  F1 F1 F0 F0 F0 EF EF  C  	DB	-15,-15,-16,-16,-16,-17,-17,-17 
       EF                    C  
 0329  EE EE EE EE ED ED ED  C  	DB	-18,-18,-18,-18,-19,-19,-19,-20 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-23
CON86	 8086 BASIC CONSTANTS                                 

       EC                    C  
 0331  EC EC EB EB EB EB EA  C  	DB	-20,-20,-21,-21,-21,-21,-22,-22 
       EA                    C  
 0339  EA E9 E9 E9 E8 E8 E8  C  	DB	-22,-23,-23,-23,-24,-24,-24,-25 
       E7                    C  
 0341  E7 E7 E7 E6 E6 E6 E5  C  	DB	-25,-25,-25,-26,-26,-26,-27,-27 
       E5                    C  
 0349  E5 E4 E4 E4 E4 E3 E3  C  	DB	-27,-28,-28,-28,-28,-29,-29,-29 
       E3                    C  
 0351  E2 E2 E2 E1 E1 E1 E1  C  	DB	-30,-30,-30,-31,-31,-31,-31,-32 
       E0                    C  
                             C  ;**********************************************
				****************** 
                             C  ; 
                             C  ;TABLE DXX CONTAINS DOUBLE PRECISION POWERS OF 
				TEN 
                             C  ;FROM -38 TO +38 
                             C  ; 
                             C  ; 20-May-82 / MLC - Most of the negative powers
				 of ten have been 
                             C  ; removed.  Routines which used to multiply by 
				these negative powers of 
                             C  ; ten have been changed to divide by the corres
				ponding positive power 
                             C  ; of ten.  ($FINE and $FOTNV) 
                             C  ; 
                             C  ;**********************************************
				*************** 
 0008                        C  	.RADIX	8 
 0359  CD CC CC CC CC CC 4C  C  $DPM01: DB	315,314,314,314,314,314,114,175 ;10^
				-01 
       7D                    C  
 0361  00 00 00 00 00 00 00  C  $DP00:	DB	000,000,000,000,000,000,000,201 ;10^0
				0 
       81                    C  
 0369  00 00 00 00 00 00 20  C  $DP01:	DB	000,000,000,000,000,000,040,204 ;10^0
				1 
       84                    C  
 0371  00 00 00 00 00 00 48  C  	DB	000,000,000,000,000,000,110,207 ;10^02 
       87                    C  
 0379  00 00 00 00 00 00 7A  C  	DB	000,000,000,000,000,000,172,212 ;10^03 
       8A                    C  
 0381  00 00 00 00 00 40 1C  C  	DB	000,000,000,000,000,100,034,216 ;10^04 
       8E                    C  
 0389  00 00 00 00 00 50 43  C  	DB	000,000,000,000,000,120,103,221 ;10^05 
       91                    C  
 0391  00 00 00 00 00 24 74  C  $DP06:	DB	000,000,000,000,000,044,164,224 ;10^0
				6 
       94                    C  
 0399  00 00 00 00 80 96 18  C  $DP07:	DB	000,000,000,000,200,226,030,230 ;10^0
				7 
       98                    C  
 03A1  00 00 00 00 20 BC 3E  C  	DB	000,000,000,000,040,274,076,233 ;10^08 
       9B                    C  
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-24
CON86	 8086 BASIC CONSTANTS                                 

 03A9  00 00 00 00 28 6B 6E  C  $DP09:	DB	000,000,000,000,050,153,156,236 ;10^0
				9 
       9E                    C  
 03B1  00 00 00 00 F9 02 15  C  	DB	000,000,000,000,371,002,025,242 ;10^10 
       A2                    C  
 03B9  00 00 00 40 B7 43 3A  C  	DB	000,000,000,100,267,103,072,245 ;10^11 
       A5                    C  
 03C1  00 00 00 10 A5 D4 68  C  	DB	000,000,000,020,245,324,150,250 ;10^12 
       A8                    C  
 03C9  00 00 00 2A E7 84 11  C  	DB	000,000,000,052,347,204,021,254 ;10^13 
       AC                    C  
 03D1  00 00 80 F4 20 E6 35  C  	DB	000,000,200,364,040,346,065,257 ;10^14 
       AF                    C  
 03D9  00 00 A0 31 A9 5F 63  C  	DB	000,000,240,061,251,137,143,262 ;10^15 
       B2                    C  
 03E1  00 00 04 BF C9 1B 0E  C  $DP16:	DB	000,000,004,277,311,033,016,266 ;10^1
				6 
       B6                    C  
 03E9  00 00 C5 2E BC A2 31  C  	DB	000,000,305,056,274,242,061,271 ;10^17 
       B9                    C  
 03F1  00 40 76 3A 6B 0B 5E  C  	DB	000,100,166,072,153,013,136,274 ;10^18 
       BC                    C  
 03F9  00 E8 89 04 23 C7 0A  C  	DB	000,350,211,004,043,307,012,300 ;10^19 
       C0                    C  
 0401  00 62 AC C5 EB 78 2D  C  	DB	000,142,254,305,353,170,055,303 ;10^20 
       C3                    C  
 0409  80 7A 17 B7 26 D7 58  C  	DB	200,172,027,267,046,327,130,306 ;10^21 
       C6                    C  
 0411  90 AC 6E 32 78 86 07  C  	DB	220,254,156,062,170,206,007,312 ;10^22 
       CA                    C  
 0419  B4 57 0A 3F 16 68 29  C  	DB	264,127,012,077,026,150,051,315 ;10^23 
       CD                    C  
 0421  A1 ED CC CE 1B C2 53  C  	DB	241,355,314,316,033,302,123,320 ;10^24 
       D0                    C  
 0429  85 14 40 61 51 59 04  C  	DB	205,024,100,141,121,131,004,324 ;10^25 
       D4                    C  
 0431  A6 19 90 B9 A5 6F 25  C  	DB	246,031,220,271,245,157,045,327 ;10^26 
       D7                    C  
 0439  0F 20 F4 27 8F CB 4E  C  	DB	017,040,364,047,217,313,116,332 ;10^27 
       DA                    C  
 0441  0A 94 F8 78 39 3F 01  C  	DB	012,224,370,170,071,077,001,336 ;10^28 
       DE                    C  
 0449  0C B9 36 D7 07 8F 21  C  	DB	014,271,066,327,007,217,041,341 ;10^29 
       E1                    C  
 0451  4F 67 04 CD C9 F2 49  C  	DB	117,147,004,315,311,362,111,344 ;10^30 
       E4                    C  
 0459  23 81 45 40 7C 6F 7C  C  	DB	043,201,105,100,174,157,174,347 ;10^31 
       E7                    C  
 0461  B6 70 2B A8 AD C5 1D  C  	DB	266,160,053,250,255,305,035,353 ;10^32 
       EB                    C  
 0469  E3 4C 36 12 19 37 45  C  	DB	343,114,066,022,031,067,105,356 ;10^33 
       EE                    C  
 0471  1C E0 C3 56 DF 84 76  C  	DB	034,340,303,126,337,204,166,361 ;10^34 
       F1                    C  
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-25
CON86	 8086 BASIC CONSTANTS                                 

 0479  11 6C 3A 96 0B 13 1A  C  	DB	021,154,072,226,013,023,032,365 ;10^35 
       F5                    C  
 0481  16 07 C9 7B CE 97 40  C  	DB	026,007,311,173,316,227,100,370 ;10^36 
       F8                    C  
 0489  DB 48 BB 1A C2 BD 70  C  	DB	333,110,273,032,302,275,160,373 ;10^37 
       FB                    C  
 0491  89 0D B5 50 99 76 16  C  	DB	211,015,265,120,231,166,026,377 ;10^38 
       FF                    C  
 0499                        C  $DHALF:			;DOUBLE PRECISION .5D00 
 0499  00                    C  	DB	000		;.5D00 
 049A  00                    C  	DB	000 
 049B  00                    C  	DB	000 
 049C  00                    C  	DB	000 
 049D                        C  $SHALF:			;SINGLE PRECISION .5E00 
 049D  00                    C  	DB	000		;.5E00 
 049E  00                    C  	DB	000 
 049F  00                    C  	DB	000 
 04A0  80                    C  	DB	200 
 04A1  F1                    C  $SQRH:	DB	361		;SQR(.5) 
 04A2  04                    C  	DB	004 
 04A3  35                    C  	DB	065 
 04A4  80                    C  	DB	200 
                             C  ;**********************************************
				************ 
                             C  ;FOR LOG CALCULATIONS HART ALGORITHM 2524 WILL 
				BE USED 
                             C  ;IN THIS ALGORITHM WE WILL CALCULATE BASE 2 LOG
				 AS FOLLOWS 
                             C  ;LOG(X)=P(X)/Q(X) 
                             C  ;**********************************************
				***************** 
 04A5  04                    C  $LOGP:	DB	4 
 04A6  9A                    C  	DB	232		;4.8114746 
 04A7  F7                    C  	DB	367 
 04A8  19                    C  	DB	031 
 04A9  83                    C  	DB	203 
 04AA  24                    C  	DB	044		;6.105852 
 04AB  63                    C  	DB	143 
 04AC  43                    C  	DB	103 
 04AD  83                    C  	DB	203 
 04AE  75                    C  	DB	165		;-8.86266 
 04AF  CD                    C  	DB	315 
 04B0  8D                    C  	DB	215 
 04B1  84                    C  	DB	204 
 04B2  A9                    C  	DB	251		;-2.054667 
 04B3  7F                    C  	DB	177 
 04B4  83                    C  	DB	203 
 04B5  82                    C  	DB	202 
 04B6  04                    C  $LOGQ:	DB	4 
 04B7  00                    C  	DB	000		;1. 
 04B8  00                    C  	DB	000 
 04B9  00                    C  	DB	000 
 04BA  81                    C  	DB	201 
 04BB  E2                    C  	DB	342		;6.427842 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-26
CON86	 8086 BASIC CONSTANTS                                 

 04BC  B0                    C  	DB	260 
 04BD  4D                    C  	DB	115 
 04BE  83                    C  	DB	203 
 04BF  0A                    C  	DB	012		;4.545171 
 04C0  72                    C  	DB	162 
 04C1  11                    C  	DB	021 
 04C2  83                    C  	DB	203 
 04C3  F4                    C  	DB	364		;.3535534 
 04C4  04                    C  	DB	004 
 04C5  35                    C  	DB	065 
 04C6  7F                    C  	DB	177 
                             C  ;LOG BASE E OF 2.0 
 04C7  18                    C  $LN2:	DB	030 
 04C8  72                    C  	DB	162 
 04C9  31                    C  	DB	061 
 04CA  80                    C  	DB	200 
 04CB                        C  $FINCH:			;SPECIAL CHARACTERS FOR INPUT/OUTPUT 
 04CB  2E                    C  	DB	"." 
 04CC  65                    C  	DB	OFFSET "E"+40   ;LOWER CASE "E" 
 04CD  45                    C  	DB	"E" 
 04CE  25                    C  	DB	"%" 
 04CF  23                    C  	DB	"#" 
 04D0  21                    C  	DB	"!" 
 04D1  44                    C  	DB	"D" 
 04D2  64                    C  	DB	OFFSET "D"+40   ;LOWER CASE "D" 
 04D3  2C                    C  	DB	54		;COMMA 
 04D4  30                    C  	DB	"0" 
 04D5  00                    C  $FODTB: DB	000		; 1D15 
 04D6  80                    C  	DB	200 
 04D7  C6                    C  	DB	306 
 04D8  A4                    C  	DB	244 
 04D9  7E                    C  	DB	176 
 04DA  8D                    C  	DB	215 
 04DB  03                    C  	DB	003 
 04DC  00                    C  	DB	000		; 1D14 
 04DD  40                    C  	DB	100 
 04DE  7A                    C  	DB	172 
 04DF  10                    C  	DB	020 
 04E0  F3                    C  	DB	363 
 04E1  5A                    C  	DB	132 
 04E2  00                    C  	DB	000 
 04E3  00                    C  	DB	000		; 1D13 
 04E4  A0                    C  	DB	240 
 04E5  72                    C  	DB	162 
 04E6  4E                    C  	DB	116 
 04E7  18                    C  	DB	030 
 04E8  09                    C  	DB	011 
 04E9  00                    C  	DB	000 
 04EA  00                    C  	DB	000		; 1D12 
 04EB  10                    C  	DB	020 
 04EC  A5                    C  	DB	245 
 04ED  D4                    C  	DB	324 
 04EE  E8                    C  	DB	350 
 04EF  00                    C  	DB	000 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-27
CON86	 8086 BASIC CONSTANTS                                 

 04F0  00                    C  	DB	000 
 04F1  00                    C  	DB	000		; 1D11 
 04F2  E8                    C  	DB	350 
 04F3  76                    C  	DB	166 
 04F4  48                    C  	DB	110 
 04F5  17                    C  	DB	027 
 04F6  00                    C  	DB	000 
 04F7  00                    C  	DB	000 
 04F8  00                    C  	DB	000		; 1D10 
 04F9  E4                    C  	DB	344 
 04FA  0B                    C  	DB	013 
 04FB  54                    C  	DB	124 
 04FC  02                    C  	DB	002 
 04FD  00                    C  	DB	000 
 04FE  00                    C  	DB	000 
 04FF  00                    C  	DB	000		; 1D9 
 0500  CA                    C  	DB	312 
 0501  9A                    C  	DB	232 
 0502  3B                    C  	DB	073 
 0503  00                    C  	DB	000 
 0504  00                    C  	DB	000 
 0505  00                    C  	DB	000 
 0506  00                    C  	DB	000		; 1D8 
 0507  E1                    C  	DB	341 
 0508  F5                    C  	DB	365 
 0509  05                    C  	DB	005 
 050A  00                    C  	DB	000 
 050B  00                    C  	DB	000 
 050C  00                    C  	DB	000 
 050D  80                    C  	DB	200		; 1D7 
 050E  96                    C  	DB	226 
 050F  98                    C  	DB	230 
 0510  00                    C  	DB	000 
 0511  00                    C  	DB	000 
 0512  00                    C  	DB	000 
 0513  00                    C  	DB	000 
 0514  40                    C  	DB	100		; 1D6 
 0515  42                    C  	DB	102 
 0516  0F                    C  	DB	017 
 0517  00                    C  	DB	000 
 0518  00                    C  	DB	000 
 0519  00                    C  	DB	000 
 051A  00                    C  	DB	000 
                             C  ;SINGLE PRECISION POWER OF TEN TABLE 
 051B  40                    C  $FOSTB: DB	100		;1,000,000 
 051C  42                    C  	DB	102 
 051D  0F                    C  	DB	017 
 051E  A0                    C  	DB	240		; 1E5 
 051F  86                    C  	DB	206 
 0520  01                    C  	DB	001 
 0521  10                    C  	DB	020		; 1E4 
 0522  27                    C  	DB	047 
 0523  00                    C  	DB	000 
                             C  ;INTEGER POWER OF TEN TABLE 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-28
CON86	 8086 BASIC CONSTANTS                                 

 0524  10                    C  $FOITB: DB	020		; 10000 
 0525  27                    C  	DB	047 
 0526  E8                    C  	DB	350		; 1000 
 0527  03                    C  	DB	003 
 0528  64                    C  	DB	144		; 100 
 0529  00                    C  	DB	000 
 052A  0A                    C  	DB	012		; 10 
 052B  00                    C  	DB	000 
 052C  01                    C  	DB	001		; 1 
 052D  00                    C  	DB	000 
 052E  00                    C  $S32KM: DB	000		;SINGLE PRECISION -32768 
 052F  00                    C  	DB	000 
 0530  80                    C  	DB	200 
 0531  90                    C  	DB	220 
 0532  FF                    C  $INFPD: DB	377		;DOUBLE PRECISION +INFINITY 
 0533  FF                    C  	DB	377 
 0534  FF                    C  	DB	377 
 0535  FF                    C  	DB	377 
 0536  FF                    C  	DB	377		;SINGLE PREC. +INFINITY 
 0537  FF                    C  	DB	377 
 0538  7F                    C  	DB	177 
 0539  FF                    C  	DB	377 
                             C   
 053A  FF                    C  $INFMD: DB	377		;DOUBLE PRECISION -INFINITY 
 053B  FF                    C  	DB	377 
 053C  FF                    C  	DB	377 
 053D  FF                    C  	DB	377 
 053E  FF                    C  	DB	377		;SINGLE PREC. -INFINITY 
 053F  FF                    C  	DB	377 
 0540  FF                    C  	DB	377 
 0541  FF                    C  	DB	377 
 0542  3B                    C  $LG2E:	DB	073		;LOG BASE 2 OF E 
 0543  AA                    C  	DB	252 
 0544  38                    C  	DB	070 
 0545  81                    C  	DB	201 
                             C  ;**********************************************
				*********** 
                             C  ;$EXPCN CONTAINS THE COEFFICIENTS FOR POLYNOMIA
				L EVALUATION 
                             C  ;OF LOG BASE 2 OF X WHERE .5.LE.X.LE.1 
                             C  ;THE COEFFICIENTS ARE FROM HART #1302 
                             C  ;**********************************************
				************* 
 0546  07                    C  $EXPCN: DB	7		;DEGREE + 1 
 0547  7C                    C  	DB	174		;.00020745577403- 
 0548  88                    C  	DB	210 
 0549  59                    C  	DB	131 
 054A  74                    C  	DB	164 
 054B  E0                    C  	DB	340		;.00127100574569- 
 054C  97                    C  	DB	227 
 054D  26                    C  	DB	046 
 054E  77                    C  	DB	167 
 054F  C4                    C  	DB	304		;.00965065093202+ 
 0550  1D                    C  	DB	035 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-29
CON86	 8086 BASIC CONSTANTS                                 

 0551  1E                    C  	DB	036 
 0552  7A                    C  	DB	172 
 0553  5E                    C  	DB	136		;.05549656508324+ 
 0554  50                    C  	DB	120 
 0555  63                    C  	DB	143 
 0556  7C                    C  	DB	174 
 0557  1A                    C  	DB	032		;.24022713817633- 
 0558  FE                    C  	DB	376 
 0559  75                    C  	DB	165 
 055A  7E                    C  	DB	176 
 055B  18                    C  	DB	030		;.69314717213716+ 
 055C  72                    C  	DB	162 
 055D  31                    C  	DB	061 
 055E  80                    C  	DB	200 
 055F  00                    C  	DB	000		;1.0 
 0560  00                    C  	DB	000 
 0561  00                    C  	DB	000 
 0562  81                    C  	DB	201 
 0563                        C  $SINCN: 
                             C  ;       COEFFICIENTS FOR SINE FUNCTION 
                             C  ;       SEE HART'S #3341 
                             C  ;       RELATIVE ERROR 8.27 
                             C   
 0563  05                    C  	DB	5		;NUMBER OF CONSTANTS 
 0564  FB                    C  	DB	373		;39.71091766+ 
 0565  D7                    C  	DB	327 
 0566  1E                    C  	DB	036 
 0567  86                    C  	DB	206 
 0568  65                    C  	DB	145		;-76.57498378- 
 0569  26                    C  	DB	046 
 056A  99                    C  	DB	231 
 056B  87                    C  	DB	207 
 056C  58                    C  	DB	130		;81.60223119+ 
 056D  34                    C  	DB	064 
 056E  23                    C  	DB	043 
 056F  87                    C  	DB	207 
 0570  E1                    C  	DB	341		;-41.34167747+ 
 0571  5D                    C  	DB	135 
 0572  A5                    C  	DB	245 
 0573  86                    C  	DB	206 
 0574  DB                    C  	DB	333		;6.283185272+ 
 0575  0F                    C  	DB	017 
 0576  49                    C  	DB	111 
 0577  83                    C  	DB	203 
 0578                        C  $ATNC1:			;CONSTANTS FOR ARCTANGENT RANGE REDUC
				TION 
 0578  02                    C  	DB	2 
 0579  D7                    C  	DB	327		;SQR(3) 
 057A  B3                    C  	DB	263 
 057B  5D                    C  	DB	135 
 057C  81                    C  	DB	201 
 057D  00                    C  	DB	000		;-1.0 
 057E  00                    C  	DB	000 
 057F  80                    C  	DB	200 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-30
CON86	 8086 BASIC CONSTANTS                                 

 0580  81                    C  	DB	201 
 0581                        C  $ATNC2:			;HART ALGORITHM 4940 COEFFICIENTS 
 0581  04                    C  	DB	4 
 0582  62                    C  	DB	142		;-.1281333 
 0583  35                    C  	DB	065 
 0584  83                    C  	DB	203 
 0585  7E                    C  	DB	176 
 0586  50                    C  	DB	120		;.1993573 
 0587  24                    C  	DB	044 
 0588  4C                    C  	DB	114 
 0589  7E                    C  	DB	176 
 058A  79                    C  	DB	171		;-.3333324 
 058B  A9                    C  	DB	251 
 058C  AA                    C  	DB	252 
 058D  7F                    C  	DB	177 
 058E  00                    C  	DB	000		;1.0 
 058F  00                    C  	DB	000 
 0590  00                    C  	DB	000 
 0591  81                    C  	DB	201 
                             C  ;**********************************************
				************** 
                             C  ;THE FOLLOWING CONSTANT LABELED $IN2PI IS USED 
				FOR RANGE 
                             C  ;REDUCTION IN SIN,COS, & TAN. THE LOW ORDER BYT
				ES ARE PURPOSELY 
                             C  ;ZERO TO PROVIDE A MORE ACCURATE REDUCTION OF S
				INGLE PRECISION 
                             C  ;NUMBERS. THIS CONSTANT SHOULD NOT BE USED WITH
				 ORDINARY DOUBLE 
                             C  ;PRECISION NUMBERS. 
                             C  ;**********************************************
				************** 
 0592  0B                    C  $IN2PI: DB	013		;1/(2*PI) 
 0593  44                    C  	DB	104 
 0594  4E                    C  	DB	116 
 0595  6E                    C  	DB	156 
 0596  83                    C  	DB	203 
 0597  F9                    C  	DB	371 
 0598  22                    C  	DB	042 
 0599  7E                    C  	DB	176 
                             C  ;**********************************************
				************* 
                             C  ;CONSTANTS FOR THE RANDOM NUMBER GENERATOR FOLL
				OW 
                             C  ;DO NOT CHANGE THESE WITHOUT CONSULTING KNUTH V
				OL 2 
                             C  ;CHAPTER 3 FIRST 
                             C  ;**********************************************
				************** 
 059A  FD                    C  $RNDA:	DB	375		;214013 
 059B  43                    C  	DB	103 
 059C  03                    C  	DB	003 
 059D  C3                    C  $RNDC:	DB	303		;2531011 
 059E  9E                    C  	DB	236 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-31
CON86	 8086 BASIC CONSTANTS                                 

 059F  26                    C  	DB	046 
 05A0  01                    C  $RND0:	DB	001 
 05A1  00                    C  	DB	000		;1 
 05A2  00                    C  	DB	000 
 05A3  30                    C  $NUMB:	DB	"0"	      ;TABLE FOR OCTAL/HEX OUTPUT
				 
 05A4  31                    C  	DB	"1" 
 05A5  32                    C  	DB	"2" 
 05A6  33                    C  	DB	"3" 
 05A7  34                    C  	DB	"4" 
 05A8  35                    C  	DB	"5" 
 05A9  36                    C  	DB	"6" 
 05AA  37                    C  	DB	"7" 
 05AB  38                    C  	DB	"8" 
 05AC  39                    C  	DB	"9" 
 05AD  41                    C  	DB	"A" 
 05AE  42                    C  	DB	"B" 
 05AF  43                    C  	DB	"C" 
 05B0  44                    C  	DB	"D" 
 05B1  45                    C  	DB	"E" 
 05B2  46                    C  	DB	"F" 
                             C   
                             C  	SUBTTL	 $SIN	 SINGLE PRECISION SINE/COSINE/TAN
				GENT/ARCTANGENT 
                             C  ;**********************************************
				****************** 
                             C  ; 
                             C  ;       $SIN,$COS,$TAN  CALCULATE THE SINE/COSI
				NE/TAN OF NO. 
                             C  ;                       IN THE $FAC.USES HART P
				OLYNOMIAL EVALUATION 
                             C  ;                       WITH COEFFICIENTS FROM 
				#3341 
                             C  ;       CALLING SEQUENCE:       CALL    $SIN 
                             C  ;                       OR      CALL    $COS 
                             C  ;                       OR      CALL    $TAN 
                             C  ;                       WITH ARGUMENT IN THE $F
				AC 
                             C  ; 
                             C  ;       $ATAN           CALCULATE THE ARCTANGEN
				T OF THE VALUE IN THE 
                             C  ;                       FAC. USES COEFFICIENTS 
				FROM HART 4940 
                             C  ;       CALLING SEQUENCE:       CALL    $ATAN 
                             C  ;                       WITH THE ARGUMENT IN TH
				E FAC 
                             C  ; 
                             C  ;       Changed COS to double precision range r
				eduction 24-JUN-82/NGT 
                             C  ; 
                             C  ;**********************************************
				******************** 
                             C   
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-32
$SIN	 SINGLE PRECISION SINE/COSINE/TANGENT/ARCTANGENT       

 05B3                        C  COS: 
 05B3                        C  $COS: 
 05B3  80 26 0000 E 7F       C  	AND	BYTE PTR $FACM1,LOW 177O	;clear sign bit (
				 cos(-x) = cos(x) ) 
 05B8  E8 063E R             C  	CALL	RR		; Do range reduction, FAC=REM(FAC/2pi
				) 
 05BB  E8 0660 R             C  	CALL	ONEARG		; Zero the accumulator 
 05BE  C6 06 0000 E 7F       C  	MOV	BYTE PTR $ARG,LOW 177O	; ARG = DP 1/4 
 05C3  E8 12E3 R             C  	CALL	$FADDD		; FAC = reduced angle + PI/2 
 05C6  E8 064A R             C  	CALL	RR1		; Make sure we are still in 0 - 2*PI
				 
 05C9  EB 19                 C  	JMP	SHORT SIN30 
                             C   
 05CB                        C  SIN: 
 05CB                        C  $SIN:				;Will now take advantage of identity S
				IN(-X)=-SIN(X) 
 05CB  A1 FFFF E             C  	MOV	AX,WORD PTR $FAC-1	;FETCH SIGN BYTE 
 05CE  80 FC 77              C  	CMP	AH,LOW 167O	;IF EXP SMALLER THEN RETURN X 
 05D1  73 01                 C  	JNB	SIN10 
 05D3  C3                    C  	RET 
 05D4                        C  SIN10: 
 05D4  0A C0                 C  	OR	AL,AL 
 05D6  79 09                 C  	JNS	SIN20 
                             C  ;(FAC) is negative will make positive and push 
				neg on stack 
 05D8  24 7F                 C  	AND	AL,LOW 177O	;CLEAR SIGN BYTE 
 05DA  A2 FFFF E             C  	MOV	BYTE PTR $FAC-1,AL 
 05DD  B8 0B24 R             C  	MOV	AX,OFFSET $NEG	;FETCH ADDRESS OF NEG 
 05E0  50                    C  	PUSH	AX		;AND PUSH ON STACK 
 05E1                        C  SIN20: 
 05E1  E8 063E R             C  	CALL	RR		; Do DP range reduction 
                             C  ; 
                             C  ; At this point the FAC has the remainder of th
				e angle / 2*PI 
                             C  ; 
 05E4                        C  SIN30: 
 05E4  B0 00 E               C  	MOV	AL,LOW OFFSET $FAC 
 05E6  0A C0                 C  	OR	AL,AL 
 05E8  74 05                 C  	JZ	SIN31 
 05EA  80 06 0000 E 02       C  	ADD	BYTE PTR $FAC,LOW 2	; FAC = FAC*4 = Reduce
				 angle / PI/2 
 05EF                        C  SIN31: 
 05EF  E8 0653 R             C  	CALL	RR3		;ARG= INT(FAC) 
                             C  ; 
                             C  ; Now we have the reduced angle mod PI/2, so th
				at we can find what quadrant 
                             C  ; it's in.  The FAC should have a value in the 
				range 0-3 corresponding to 
                             C  ; the quadrant.  If the value is 2 or 3, corres
				ponding to the interval 
                             C  ; PI - 2*PI, we must return a negative value fo
				r the Sine.  If the value is 
                             C  ; in quadrants 1 or 3, we must subtract the red
				uced angle from 1 (PI/2). 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-33
$SIN	 SINGLE PRECISION SINE/COSINE/TANGENT/ARCTANGENT       

                             C  ; Algorithm: 
                             C  ;       FAC = (angle / (2*PI))*4      ; Yields 
				number in 0.LE.FAC.LT.4 
                             C  ;       Save FAC 
                             C  ;       ARG = INT( FAC )            ; ARG = qua
				drant 0-3 
                             C  ;       Restore FAC 
                             C  ;       FAC = (FAC - ARG)/4         ; FAC = ang
				le in range 0 - PI/2 
                             C  ;       IF quadrant = 1 or 3 THEN 
                             C  ;           FAC = 1 - FAC           ; FAC = PI/
				2 - angle 
                             C  ;       Calculate polynomial 
                             C  ;       IF quadrant = 2 or 3 THEN 
                             C  ;           Negate result           ; Negative 
				for PI - 2*PI 
                             C  ; 
                             C  ;         LOW              HIGH (octal bytes) 
                             C  ; D.P. 0 = 0,0,0,0,0,0,000,000 
                             C  ; D.P. 1 = 0,0,0,0,0,0,000,201 
                             C  ; D.P. 2 = 0,0,0,0,0,0,000,202      ; Which imp
				lies that FAC = 202 for 2 and 3 
                             C  ; D.P. 3 = 0,0,0,0,0,0,100,202 
                             C  ; 
 05F2  A1 FFFF E             C  	MOV	AX,WORD PTR $ARG-1 
 05F5  80 FC 82              C  	CMP	AH,LOW 202O	; ARG now has quadrant informa
				tion 
 05F8  9C                    C  	PUSHF			; Z set if we need to negate when done
				 
 05F9  F6 C4 01              C  	TEST	AH,LOW 1	; Now set NZ if in quadrant 1 
 05FC  75 02                 C  	JNZ	SIN40 
 05FE  A8 40                 C  	TEST	AL,LOW 100O	; Set NZ if in quadrant 3 
 0600                        C  SIN40: 
 0600  9C                    C  	PUSHF			; NZ if we must subtract from 1 
 0601  E8 064D R             C  	CALL	RR2		; FAC = X-INT(X) = angle MOD PI/2 
 0604  9D                    C  	POPF 
 0605  74 09                 C  	JZ	SIN50		; Nothing more to do, calculate the 
				SIN 
 0607  BB 0361 R             C  	MOV	BX,OFFSET $DP00 ; Point to a D.P. 1 (10^0)
				 
 060A  E8 09CF R             C  	CALL	$MOVAC		; ARG = 1 
 060D  E8 12D7 R             C  	CALL	$FSUBD		; FAC = 1 - FAC = PI/2 - angle MO
				D PI/2 
 0610                        C  SIN50: 
 0610  80 2E 0000 E 02       C  	SUB	BYTE PTR $FAC,LOW 2	; FAC = FAC/4 = ( angl
				e / 2*PI ) 
 0615  73 03                 C  	JNB	SIN51 
 0617  E8 08A7 R             C  	CALL	$DZERO		;Return 0 if Underflow 
 061A                        C  SIN51: 
 061A  E8 17AA R             C  	CALL	$CSD		; Convert DP reduced angle back to 
				SP 
 061D  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC	;WILL SEE IF SMALL ENOUGH
				 
                             C  				;SUCH THAT X=SIN(X) 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-34
$SIN	 SINGLE PRECISION SINE/COSINE/TANGENT/ARCTANGENT       

 0620  3C 74                 C  	CMP	AL,LOW 164O	;IF FAC SMALLER THAN THIS JUST
				 
 0622  73 0B                 C  	JNB	SIN60 
 0624  BA 0FDB               C  	MOV	DX,7733O	;2*PI 
 0627  BB 8349               C  	MOV	BX,101511O 
 062A  E8 191D R             C  	CALL	$FMULS 
 062D  EB 06                 C  	JMP	SHORT SIN65	; Go set sign properly 
 062F                        C  SIN60: 
 062F  BB 0563 R             C  	MOV	BX,OFFSET $SINCN	;POINT TO HART 3341 COEFF
				S. 
 0632  E8 1D17 R             C  	CALL	$POLYX		;EVALUATE THE POLYNOMIAL 
 0635                        C  SIN65: 
 0635  9D                    C  	POPF			;RECALL SIGN 
 0636  75 05                 C  	JNZ	SIN70 
 0638  80 36 FFFF E 80       C  	XOR	BYTE PTR $FAC-1,LOW 200O	;FLIP SIGN 
 063D                        C  SIN70: 
 063D  C3                    C  	RET 
                             C  ; 
                             C  ; Converts FAC to double precision and reduces 
				the result to a 
                             C  ; value in the range 0 - 2*PI. 
                             C  ; The RR1 entry point can be used to extract th
				e fractional part of the FAC. 
                             C  ;DOUBLE PRECISION REDUCTION OF RANGE BY 2*PI 
                             C  ; 
 063E                        C  RR: 
 063E  BB 0592 R             C  	MOV	BX,OFFSET $IN2PI	;POINT TO 1/(2*PI) 
 0641  E8 09CF R             C  	CALL	$MOVAC		;MOVE TO ARG 
 0644  E8 17D7 R             C  	CALL	$CDS		;CONVERT TO DOUBLE 
 0647  E8 1873 R             C  	CALL	$FMULD		;X 
 064A                        C  RR1: 
 064A  E8 0653 R             C  	CALL	RR3 
 064D                        C  RR2: 
 064D  E8 12D7 R             C  	CALL	$FSUBD		;INT(X)-X 
 0650  E9 0B24 R             C  	JMP	$NEG		;X-INT(X) 
 0653                        C  RR3: 
 0653  E8 0BB5 R             C  	CALL	$VPSHF		;SAVE X 
 0656  E8 1B65 R             C  	CALL	$DINT		;($FAC)=INT(X) 
 0659  E8 09E7 R             C  	CALL	$MOVAF		;SAVE IN ARG 
 065C  E8 0BD4 R             C  	CALL	$VPOPF		;FETCH X 
 065F  C3                    C  	RET 
 0660                        C  ONEARG: 
 0660  BB 0361 R             C  	MOV	BX,OFFSET $DP00 
 0663  E9 09CF R             C  	JMP	$MOVAC 
                             C   
                             C   
                             C   
                             C  ; 
                             C  ; Tangent Code 
                             C  ; 
 0666                        C  TAN: 
 0666  FF 36 0000 E          C  $TAN:	PUSH	WORD PTR $FACM1 ;SAVE ARG 
 066A  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 066E  E8 05CB R             C  	CALL	$SIN		;CALCULATE SINE 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-35
$SIN	 SINGLE PRECISION SINE/COSINE/TANGENT/ARCTANGENT       

 0671  5A                    C  	POP	DX		;RECALL ARGUMENT 
 0672  5B                    C  	POP	BX 
 0673  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO ;SAVE SIN(X) 
 0677  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 
 067B  E8 0A05 R             C  	CALL	$MOVFR		;MOVE ORIGINAL ARG TO FAC 
 067E  E8 05B3 R             C  	CALL	$COS		;CALCULATE COSINE 
 0681  5B                    C  	POP	BX		;RECALL SIN(X) 
 0682  5A                    C  	POP	DX 
 0683  E9 15D6 R             C  	JMP	$FDIVS		;GO DIVIDE TO EFFECT TANGENT 
 0686                        C  ATN: 
 0686                        C  $ATAN:				;(FAC)=ARCTANGENT(FAC) 
 0686  A1 FFFF E             C  	MOV	AX,WORD PTR $FAC-1	;WANT ONLY POSITIVE X 
 0689  0A C0                 C  	OR	AL,AL 
 068B  79 09                 C  	JNS	ATN10 
 068D  BF 0B24 R             C  	MOV	DI,OFFSET $NEG	;TAKE ADVANTAGE OF IDENTITY
				 
 0690  57                    C  	PUSH	DI		;ATAN(X)=-ATAN(-X) 
 0691  24 7F                 C  	AND	AL,LOW 177	;CLEAR SIGN 
 0693  A2 FFFF E             C  	MOV	BYTE PTR $FAC-1,AL 
 0696  80 FC 81              C  ATN10:	CMP	AH,LOW 201	;SEE IF X .GT. TAN(PI/4) 
 0699  72 0C                 C  	JB	ATN20		;IF NOT PROCEED 
 069B  BF 06F2 R             C  	MOV	DI,OFFSET ATN100	;WILL WANT TO FORM 
 069E  57                    C  	PUSH	DI		;PI/2-(FAC) AT THE END 
 069F  33 D2                 C  	XOR	DX,DX		;WILL SET (BXDX)=1.0 
 06A1  BB 8100               C  	MOV	BX,100400 
 06A4  E8 15D6 R             C  	CALL	$FDIVS		;THIS PUTS 1/X IN FAC 
 06A7  BA 30A2               C  ATN20:	MOV	DX,30242	;FETCH TAN(PI/12) 
 06AA  BB 7F09               C  	MOV	BX,77411 
 06AD  E8 0A40 R             C  	CALL	$FCOMP		;SEE IF LARGER 
 06B0  78 3A                 C  	JS	ATN30		;IF NOT PROCEED 
 06B2  BF 06FB R             C  	MOV	DI,OFFSET ATN200	;WILL WANT (FAC)=(FAC)+PI
				/6 
 06B5  57                    C  	PUSH	DI		;AT THE END 
 06B6  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO ;SAVE X 
 06BA  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 
 06BE  BA B3D7               C  	MOV	DX,131727	;FETCH SQR(3) 
 06C1  BB 815D               C  	MOV	BX,100535 
 06C4  E8 139F R             C  	CALL	$FADDS		;(FAC)=X+SQR(3) 
 06C7  5B                    C  	POP	BX 
 06C8  5A                    C  	POP	DX		;FETCH X BACK 
 06C9  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO ;SAVE X+SQR(3) 
 06CD  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 
 06D1  E8 0A05 R             C  	CALL	$MOVFR		;X TO FAC 
 06D4  BB 0578 R             C  	MOV	BX,OFFSET $ATNC1 
 06D7  E8 1D30 R             C  	CALL	$POLY		;FORM X*SQR(3)-1 
 06DA  5B                    C  	POP	BX 
 06DB  5A                    C  	POP	DX		;RECALL X+SQR(3) 
 06DC  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO ;PUSH X*SQR(3)-1 ON STACK
				 
 06E0  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 
 06E4  E8 0A05 R             C  	CALL	$MOVFR		;X+SQR(3) TO FAC 
 06E7  5B                    C  	POP	BX 
 06E8  5A                    C  	POP	DX		;RECALL X*SQR(3)-1 
 06E9  E8 15D6 R             C  	CALL	$FDIVS		;FORM (X+SQR(3)-1)/(X+SQR(3)) 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-36
$SIN	 SINGLE PRECISION SINE/COSINE/TANGENT/ARCTANGENT       

 06EC  BB 0581 R             C  ATN30:	MOV	BX,OFFSET $ATNC2	;PREPARE FOR HART 4
				940 
 06EF  E9 1D17 R             C  	JMP	$POLYX 
 06F2  BA 0FDB               C  ATN100: MOV	DX,7733	;FETCH PI/2 
 06F5  BB 8149               C  	MOV	BX,100511 
 06F8  E9 1393 R             C  	JMP	$FSUBS		;(FAC)=PI/2-(FAC) 
                             C   
 06FB  BA 0A92               C  ATN200: MOV	DX,5222	;FETCH PI/6 
 06FE  BB 8006               C  	MOV	BX,100006 
 0701  E9 139F R             C  	JMP	$FADDS		;ADD PI/6 TO FAC 
                             C   
                             C  	SUBTTL	 $FINE	 ROUTINE TO ADJUST INPUT NUMBER 
				FOR EXPONENT 
                             C  ;**********************************************
				****************** 
                             C  ; 
                             C  ;       $FINE   THIS ROUTINE MODIFIES THE CURRE
				NT FAC WHICH HAS 
                             C  ;               THE INPUT SIGNIFICANT DIGITS SO
				 THAT THE EXPONENT 
                             C  ;               IS REFLECTED IN THE NUMBER. FOR
				 EXAMPLE, IF THE 
                             C  ;               NUMBER INPUT IS 1.9876E-17 THEN
				 THE FAC CURRENTLY 
                             C  ;               HAS THE NUMBER 19876. IT MUST B
				E MULTIPLIED BY 
                             C  ;               10^-21 TO CORRECTLY REFLECT THE
				 INPUT NUMBER. 
                             C  ;               IT IS THE JOB OF THIS ROUTINE T
				O DETERMINE THE 
                             C  ;               CORRECT MULTIPLIER AND PERFORM 
				THE MULTIPLICATION 
                             C  ;       CALLING SEQUENCE        CALL    $FINE 
                             C  ;               WITH (SI) CONTAINING 0 IF POSIT
				IVE EXPONENT 
                             C  ;               ALL BITS SET IF NEGATIVE EXPONE
				NT. (DX) CONTAINS 
                             C  ;               THE INPUT EXPONENT(FOR THE EXAM
				PLE ABOVE =17) 
                             C  ;               AND (DI) CONTAINS THE NUMBER PL
				ACES TO THE RIGHT 
                             C  ;               OF THE DECIMAL POINT. 
                             C  ; 
                             C  ;**********************************************
				******************* 
                             C   
 0704  0B F6                 C  $FINE:	OR	SI,SI		;SEE IF DX SHOULD BE NEGATED 
 0706  79 02                 C  	JNS	FIN05		;IF NOT PROCEED 
 0708  F7 DA                 C  	NEG	DX		;NEGATE 
 070A  2B D7                 C  FIN05:	SUB	DX,DI		;SUBTRACT OUT DIGITS TO RIGHT
				 OF DP. 
 070C  70 44                 C  	JO	FIN80		;UNDERFLOW IF OVERFLOW FLAG SET 
 070E  74 41                 C  	JZ	FIN55		;NUMBER COMPLETE AS IS 
                             C  ;**********************************************
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-37
$FINE	 ROUTINE TO ADJUST INPUT NUMBER FOR EXPONENT          

				***************** 
                             C  ;HERE WE HAVE THE EXPONENT IN DX. WE HAVE MULTI
				PLIERS RANGING 
                             C  ;FROM (10^-38,10^38) TO USE IN DETERMINING THE 
				CORRECT FAC. WE 
                             C  ;MAY NEED TO DO SEVERAL MULTIPLIES TO CORRECTLY
				 FORM THE NUMBER. 
                             C  ;FOR EXAMPLE IF THE NUMBER INPUT WAS 1234567.E-
				40 DX WOULD 
                             C  ;HAVE -40. IF THIS WERE THE CASE WE NEED TO DO 
				A MULTIPLY BY 10^-38 
                             C  ;THEN A MULTIPLY BY 10^-2 TO GET THE RIGHT NUMB
				ER. 
                             C  ;  All calculations are done in double precisio
				n and then converted 
                             C  ;back to the original type.  Integers are conve
				rted to single precision. 
                             C  ;**********************************************
				****************** 
 0710                        C  MDPTEN: 
 0710  53                    C  	PUSH	BX		; Preserve text pointer 
 0711  E8 08EE R             C  	CALL	$GETYP		; Get the current type, 
 0714  9C                    C  	PUSHF			; And save, so that we can convert bac
				k 
 0715  73 03                 C  	JNB	FIN20		; If already D.P., no conversion ne
				cessary 
 0717  E8 17C8 R             C  	CALL	FRCDBL		; Force result to be double preci
				sion 
 071A  0B D2                 C  FIN20:	OR	DX,DX		; Test sign of exponent 
 071C  78 16                 C  	JS	FIN30		;IF NEGATIVE EXPONENT JUMP 
                             C  ;**********************************************
				********************** 
                             C  ;POSITIVE EXPONENT . IF GREATER THAN D^38 THEN 
				WE HAVE OVERFLOW 
                             C  ; Unless the number is zero, in which case just
				 return zero. 
                             C  ;**********************************************
				********************** 
 071E  F6 06 0000 E FF       C  	TEST	BYTE PTR $FAC,LOW 377O	;Is the number zer
				o? 
 0723  74 2D                 C  	JZ	FIN80		;Yes, just return zero then. 
 0725  83 FA 27              C  	CMP	DX,39D 
 0728  72 1D                 C  	JB	FIN40		;OK PROCEED 
 072A  9D                    C  	POPF			; Get back type flags 
 072B  73 03                 C  	JNB	FIN25		; Already D.P., nothing to convert 
 072D  E8 17AA R             C  	CALL	$CSD		; Convert double to single 
 0730  5B                    C  FIN25:	POP	BX		; Restore text pointer 
 0731  EB 42 90              C  	JMP	$OVFLS		;OVERFLOW 
                             C  ; 
                             C  ; Negative exponent. 
                             C  ; Might require two divisions since highest tab
				le entry is 10^38. 
                             C  ; 
 0734  83 FA DA              C  FIN30:	CMP	DX,-38D	;Will one pass be enough? 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-38
$FINE	 ROUTINE TO ADJUST INPUT NUMBER FOR EXPONENT          

 0737  7D 0E                 C  	JGE	FIN40		;Yes. 
 0739  83 C2 26              C  	ADD	DX,38D		;No, will two divisions get it? 
 073C  83 FA DA              C  	CMP	DX,-38D 
 073F  7C 11                 C  	JL	FIN80		;No, underflow - return zero. 
 0741  E8 0757 R             C  	CALL	MDP10		;Yes, do the first one 
 0744  BA FFDA               C  	MOV	DX,-38D	;Then divide by 10^38. 
 0747  E8 0757 R             C  FIN40:	CALL	MDP10		; Do the division 
 074A  9D                    C  FIN45:	POPF			; Get back type flags 
 074B  73 03                 C  	JNB	FIN50		; Already D.P., nothing to convert 
 074D  E8 17AA R             C  	CALL	$CSD		; Convert double to single 
                             C   
                             C  ; At this point the number is restored to its o
				riginal type, with the 
                             C  ; exception of integers being converted to sing
				le precision. 
                             C   
 0750  5B                    C  FIN50:	POP	BX		; Restore text pointer 
 0751  C3                    C  FIN55:	RET 
                             C   
 0752  E8 08B4 R             C  FIN80:	CALL	$ZERO		;UNDERFLOW! 
 0755  EB F3                 C  	JMP	SHORT FIN45	; Restore proper type 
                             C   
                             C  ; 
                             C  ; Multiply or divide by double precision power 
				of ten. 
                             C  ; On entry DX contains the exponent. 
                             C  ; If the exponent is postive, multiply. 
                             C  ; If exponent is negaive, divide. 
                             C  ; 
                             C   
 0757                        C  MDP10: 
 0757  0B D2                 C  	OR	DX,DX		;Is the exponent negative? 
 0759  9C                    C  	PUSHF			;Remember whether to multiply or 
                             C  				;divide. 
 075A  79 02                 C  	JNS	POSEXP		;Positive exponent. 
 075C  F7 DA                 C  	NEG	DX		;Negative exponent, make it positive. 
 075E  B9 0003               C  POSEXP: MOV	CX,3		;DX:=DX*8 to get offset into 
				powers 
 0761  D3 E2                 C  	SHL	DX,CL		;of ten table. 
 0763  81 C2 0361 R          C  	ADD	DX,OFFSET $DP00 ;DX:=pointer to power of t
				en. 
 0767  87 DA                 C  	XCHG	BX,DX		;Move it to BX. 
 0769  E8 09CF R             C  	CALL	$MOVAC		;MOVE D.P. NO. TO ARG 
 076C  9D                    C  	POPF			;Divide? 
 076D  78 03                 C  	JS	DBLDIV		;Yes. 
 076F  E9 1873 R             C  	JMP	$FMULD		;No, multiply and return to caller
				 
 0772  E9 1475 R             C  DBLDIV: JMP	DDIVFA		;Double precision divide; F
				AC=FAC/ARG, 
                             C  				; Return to caller. 
                             C   
                             C   
                             C  	SUBTTL	 $OVFLS  OVERFLOW CODE 
                             C  ;**********************************************
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-39
$OVFLS  OVERFLOW CODE                                       

				************* 
                             C  ; 
                             C  ;       $OVFLS  PLACES CORRECT INFINITY IN THE 
				FAC AND PRINTS 
                             C  ;               OVERFLOW MESSAGE 
                             C  ; 
                             C  ;       $DIV0S  PLACES CORRECT INFINITY IN THE 
				FAC AND PRINTS 
                             C  ;               DIVIDE-BY-ZERO MESSAGE 
                             C  ; 
                             C  ;**********************************************
				************* 
                             C   
 0775  53                    C  $OVFLS: PUSH	BX 
 0776  E8 077B R             C  	CALL	OVFLS		;DO THE OVERFLOW CODE 
 0779  5B                    C  	POP	BX		;RESTORE TEXT POINTER 
 077A  C3                    C  	RET 
 077B  E8 07B4 R             C  OVFLS:	CALL	DOINF		;PUT IN APPROPRIATE INFINITY
				 
 077E  B8 0000 E             C  	MOV	AX,OFFSET OVERR ;Error trapping routine ad
				r 
 0781  BB 0000 E             C  	MOV	BX,OFFSET $OVMSG	;ADDRESS APPROPRIATE ERRO
				R MESSAGE 
 0784  EB 0F                 C  	JMP	SHORT DV010	;GO PRINT MESSAGE 
 0786  53                    C  $DIV0S: PUSH	BX		;SAVE TEXT POINTER 
 0787  E8 078C R             C  	CALL	DIV0S		;DO THE DIVIDE OVERFLOW CODE 
 078A  5B                    C  	POP	BX 
 078B  C3                    C  	RET			;RETURN WITH TEXT POINTER SAVED 
 078C  E8 07B4 R             C  DIV0S:	CALL	DOINF		;PUT IN APPROPRIATE INFINITY
				 
 078F  B8 0000 E             C  	MOV	AX,OFFSET DV0ERR	;Error trapping routine a
				dr 
 0792  BB 0000 E             C  	MOV	BX,OFFSET $DIV0M	;AND ERROR MESSAGE 
 0795  E8 07E1 R             C  DV010:	CALL	TRAPER		;Trap error if error trappi
				ng enabled 
 0798  80 3E 0000 E 01       C  	CMP	BYTE PTR $FLGOV,LOW 1	;IF 0,1 PRINT, IF 1 
				MAKE 2 
 079D  78 07                 C  	JS	DV015		;PRINT IF 0 
 079F  75 12                 C  	JNZ	DV020		;DON'T PRINT IF 2 
 07A1  C6 06 0000 E 02       C  	MOV	BYTE PTR $FLGOV,LOW 2	;MAKE 2 IF 1 
 07A6  E8 0000 E             C  DV015:	CALL	$STPRN 
 07A9  B0 0D                 C  	MOV	AL,LOW 15	;CARRIAGE RETURN 
 07AB  E8 0000 E             C  	CALL	$CATTY		;SEND IT 
 07AE  B0 0A                 C  	MOV	AL,LOW 12	;LINE FEED 
 07B0  E8 0000 E             C  	CALL	$CATTY		;SEND IT 
 07B3  C3                    C  DV020:	RET 
                             C   
 07B4                        C  DOINF:				;PUT CORRECT INFINITY IN THE FAC 
 07B4  FC                    C  	CLD			;CLEAR THE DIRECTION FLAG "DF" 
 07B5  0A FF                 C  	OR	BH,BH		;SEE IF ZERO TO A NEG POWER 
 07B7  BE 0532 R             C  	MOV	SI,OFFSET $INFPD	;ASSUME POSITIVE 
 07BA  74 0A                 C  	JZ	INF10		;POSITIVE INFINITY FOR ZERO^-X 
 07BC  F6 06 0001 E 80       C  	TEST	BYTE PTR $FAC+1,LOW 200 ;NEGATIVE? 
 07C1  79 03                 C  	JNS	INF10		;IF NOT PROCEED 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-40
$OVFLS  OVERFLOW CODE                                       

 07C3  BE 053A R             C  	MOV	SI,OFFSET $INFMD	;NEGATIVE INFINITY 
 07C6  E8 08EE R             C  INF10:	CALL	$GETYP		;SET CODES ACCORDING TO TYP
				E 
 07C9  72 08                 C  	JB	INF20 
                             C  ;**********************************************
				************* 
                             C  ;IT'S DOUBLE PRECISION 
                             C  ;**********************************************
				************* 
 07CB  BF 0000 E             C  	MOV	DI,OFFSET $DFACL	;RECEIPIENT 
 07CE  B9 0004               C  	MOV	CX,4		;4 WORDS FOR DOUBLE PRECISION 
 07D1  EB 09                 C  	JMP	SHORT INF30 
 07D3                        C  INF20:				;SINGLE PRECISION 
 07D3  83 C6 04              C  	ADD	SI,4		;SO WE POINT TO SINGLE PRECISION NO.
				 
 07D6  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
 07D9  B9 0002               C  	MOV	CX,2		;2 WORDS FOR SINGLE 
 07DC                        C  INF30:				;MUST FETCH FROM CODE SEGMENT 
 07DC  2E: A5                C  	MOVS	WORD PTR ES:[DI],WORD PTR CS:[SI]	;TO FAC
				 
 07DE  E2 FC                 C  	LOOP	INF30 
 07E0  C3                    C  	RET 
                             C   
 07E1  50                    C  TRAPER: PUSH	AX		;save Error trapping routine a
				dr 
 07E2  A1 0000 E             C  	MOV	AX,WORD PTR ONELIN 
 07E5  0B C0                 C  	OR	AX,AX		;see if we are trapping errors 
 07E7  75 01                 C  	JNZ	TRAPIT		;branch if errors are being trappe
				d 
 07E9  58                    C  	POP	AX		;discard Error trapping routine adr 
 07EA  C3                    C  TRAPIT: RET			;return to caller or Error trap r
				outine 
                             C   
                             C  	SUBTTL	 $FOFMT  FLOATING FORMAT OF NUMBER IN T
				HE FAC 
                             C  ;**********************************************
				**************** 
                             C  ; 
                             C  ;       $FOFMT  FORMAT THE NUMBER IN THE FAC. I
				F THE NUMBER CAN BE 
                             C  ;               AS ACCURATELY REPRESENTED IN FI
				XED FORMAT AS 
                             C  ;               SCIENTIFIC THEN USE FIXED OUTPU
				T. 
                             C  ;       CALLING SEQUENCE:       CALL    $FOFMT 
                             C  ;               WITH (BX) POINTING TO CURRENT O
				UTPUT POSITION 
                             C  ;               IN THE OUTPUT BUFFER $FBUFF AND
				 CONDITION CODES 
                             C  ;               SET AS IF $GETYP WAS JUST CALLE
				D 
                             C  ; 
                             C  ;**********************************************
				******************* 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-41
$FOFMT  FLOATING FORMAT OF NUMBER IN THE FAC                

                             C   
 07EB  53                    C  $FOFMT: PUSH	BX		;SAVE BUFFER POINTER 
                             C   
                             C   
 07EC  B0 08                 C  	MOV	AL,LOW 8D	;assume single precision - print
				 7 digits 
                             C   
 07EE  72 02                 C  	JB	FFM10		;JUMP IF SINGLE PRECISION 
 07F0  B0 11                 C  	MOV	AL,LOW 17D	;DOUBLE PRECISION POSSIBLE DIGI
				TS 
 07F2  8A E8                 C  FFM10:	MOV	CH,AL		;WILL SAVE A SECOND COPY FOR 
				LATER 
 07F4  8A C8                 C  	MOV	CL,AL 
 07F6  51                    C  	PUSH	CX		;SAVE FOR LATER 
 07F7  9C                    C  	PUSHF			;SAVE TYPE 
 07F8  E8 1AC0 R             C  	CALL	$FOTNV		;BRACKET THE NUMBER SO THAT SIGNI
				FICANT 
                             C  				;DIGITS ARE IN THE INTEGER PART AND 
                             C  				;THE NECESSARY EXPONENT IS IN (AL) 
 07FB  0A C0                 C  	OR	AL,AL		;IF POSITIVE DON'T CALL SIGD 
 07FD  74 02                 C  	JZ	FFM11 
 07FF  79 0C                 C  	JNS	FFM15 
 0801  9D                    C  FFM11:	POPF			;RECALL TYPE FOR TEST TO SEE IF S
				IGD 
                             C  				;CALLED. IF S.P. AND (AL) SMALLER THAN 
                             C  				;-7 MUST CALL SIG, IF D.P. AND (AL) 
                             C  				;SMALLER THAN -16 THEN MUST CALL SIGD. 
                             C  				;IF (AL) POSITIVE SIGD WILL NOT BE 
                             C  				;CALLED. PURPOSE OF SIGD IS TO 
                             C  				;DETERMINE WHETHER WE CAN PRINT NO. IN 
                             C  				;FIXED FORMAT W/O LOSING SIGNIFICANT 
                             C  				;DIGITS. 
 0802  59                    C  	POP	CX		;RECALL POSIBLE SIGNIFICANT SIGITS 
 0803  50                    C  	PUSH	AX		;SAVE EXP. 
 0804  7B 0B                 C  	JPO	FFM16		;SINGLE PREC. 
 0806  04 10                 C  	ADD	AL,LOW 16D	;THIS MUST MAKE POSITIVE TO NOT
				 CALL 
 0808  58                    C  	POP	AX 
 0809  79 1A                 C  	JNS	FFM18		;POP AX AND DO FIXED OUTPUT 
 080B  EB 09                 C  	JMP	SHORT FFM17	;MUST CALL SIGD 
 080D                        C  FFM15: 
 080D  9D                    C  	POPF			;RECALL TYPE FLAG 
 080E  59                    C  	POP	CX		;RECALL CX 
 080F  EB 26                 C  	JMP	SHORT FFM20 
 0811                        C  FFM16: 
 0811  04 07                 C  	ADD	AL,LOW 7 
 0813  58                    C  	POP	AX 
 0814  79 0F                 C  	JNS	FFM18 
 0816                        C  FFM17: 
 0816  50                    C  	PUSH	AX		;SAVE NECESSARY EXPONENT IN (AL) 
 0817  E8 1FFD R             C  	CALL	$SIGD		;INCREMENT (CL) FOR EACH ZERO DIGI
				T 
                             C  				;BEGINNING FROM THE RIGHT 
 081A  58                    C  	POP	AX		;RECALL NECESSARY EXPONENT 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-42
$FOFMT  FLOATING FORMAT OF NUMBER IN THE FAC                

 081B  8A E0                 C  	MOV	AH,AL		;WILL PERFORM FIRST TEST ON AH 
 081D  02 E1                 C  	ADD	AH,CL		;IF SF=1 AFTER THIS THEN USE "E" FO
				RMAT 
 081F  7E 16                 C  	JLE	FFM20		;JUMP IF TOO SMALL 
 0821  02 E8                 C  	ADD	CH,AL 
 0823  EB 0C                 C  	JMP	SHORT FFM19 
 0825  02 C5                 C  FFM18:	ADD	AL,CH 
 0827  FE C5                 C  	INC	CH 
 0829  3A E8                 C  	CMP	CH,AL 
 082B  B5 03                 C  	MOV	CH,LOW 3	;TO FLAG "E" FORMAT IF NECESSARY 
 082D  72 0C                 C  	JB	FFM30 
 082F  8A E8                 C  	MOV	CH,AL 
 0831  FE C5                 C  FFM19:	INC	CH		;(CH)= NUMBER DIGITS+2 
 0833  B0 02                 C  	MOV	AL,LOW 2	;THIS WILL CAUSE ZF=1 IN LATER CA
				LC 
                             C  				;AND WILL SIGNAL FIXED OUTPUT 
 0835  EB 04                 C  	JMP	SHORT FFM30 
 0837  02 C5                 C  FFM20:	ADD	AL,CH 
 0839  B5 03                 C  	MOV	CH,LOW 3	;SIGNALS "E" TYPE FORMAT 
 083B  FE C8                 C  FFM30:	DEC	AL		;(AL) 2 TOO LARGE 
 083D  FE C8                 C  	DEC	AL 
 083F  5B                    C  	POP	BX		;RECALL BUFFER POINTER 
 0840  50                    C  	PUSH	AX		;SAVE EXPONENT 
 0841  9C                    C  	PUSHF			;SAVE CONDITION CODES 
 0842  32 C9                 C  	XOR	CL,CL		;(CL)=0  (NO COMMAS AFTER EACH 3 DI
				GITS 
 0844  E8 198D R             C  	CALL	$FOTAN		;PUT IN DECIMAL POINT AND LEADING
				 
                             C  				;ZEROS AS NECESSARY 
 0847  C6 07 30              C  	MOV	BYTE PTR 0[BX],LOW "0"  ;ZF=1 IF THIS "0" 
				NECESSARY 
 084A  75 01                 C  	JNZ	FFM40 
 084C  43                    C  	INC	BX 
 084D  E8 19C4 R             C  FFM40:	CALL	$FOTCV		;CONVERT THE FAC TO DECIMAL
				 DIGITS 
                             C  				;AND PUT IN DECIMAL POINT AS NECESSARY 
 0850  4B                    C  FFM50:	DEC	BX		;WILL NOW SEE IF THERE ARE TRAIL
				ING 
 0851  80 3F 30              C  	CMP	BYTE PTR 0[BX],LOW "0"  ;ZEROS TO SUPPRESS
				. WE KNOW ZEROS WE 
 0854  74 FA                 C  	JZ	FFM50		;FIND HERE ARE TRAILING BECAUSE $FOT
				CV 
 0856  80 3F 2E              C  	CMP	BYTE PTR 0[BX],LOW "."  ;PUTS IN DECIMAL P
				OINT 
 0859  74 01                 C  	JZ	FFM60		;CAN WE DELETE THE DECIMAL POINT ALS
				O? 
 085B  43                    C  	INC	BX		; 
 085C  9D                    C  FFM60:	POPF			;LET'S HAVE A LOOK AT THE POSSIBL
				E 
                             C  				;EXPONENT 
 085D  58                    C  	POP	AX 
 085E  74 2B                 C  	JZ	FFM100		;IF NO EXPONENT JUST CLEAN-UP AND R
				ET 
 0860  9C                    C  $PUEXP: PUSHF			;SAVE SF( IF =1 NEGATIVE EXPONE
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-43
$FOFMT  FLOATING FORMAT OF NUMBER IN THE FAC                

				NT) 
 0861  50                    C  	PUSH	AX		;SAVE EXPONENT 
 0862  E8 08EE R             C  	CALL	$GETYP		;SET COND. CODES FOR TYPE NUMBER 
 0865  B4 45                 C  	MOV	AH,LOW "E"      ;ASSUME SINGLE PRECISION 
 0867  7B 02                 C  	JPO	FFM70		;IF S.P. PROCEED 
 0869  B4 44                 C  	MOV	AH,LOW "D"      ;IT'S DOUBLE PRECISION 
 086B  88 27                 C  FFM70:	MOV	BYTE PTR 0[BX],AH	;PUT IN EXPONENT D
				ESIGNATOR 
 086D  43                    C  	INC	BX		;POINT TO NEXT BUFFER POSITION 
 086E  58                    C  	POP	AX		;RECALL EXPONENT 
 086F  9D                    C  	POPF			;NOW TO SEE IF POSITIVE OR NEGATIVE 
 0870  C6 07 2B              C  	MOV	BYTE PTR 0[BX],LOW "+"  ;ASSUME POSITIVE E
				XPONENT 
 0873  79 05                 C  	JNS	FFM80		;AND JUMP IF SO 
 0875  C6 07 2D              C  	MOV	BYTE PTR 0[BX],LOW "-" 
 0878  F6 D8                 C  	NEG	AL		;MUST MAKE EXPONENT POSITIVE 
 087A  B4 2F                 C  FFM80:	MOV	AH,LOW OFFSET "0"-1     ;WILL BUILD 
				DIGIT IN (AL) 
 087C  FE C4                 C  FFM90:	INC	AH		;INCREMENT TO NEXT DIGIT 
 087E  2C 0A                 C  	SUB	AL,LOW 10D	; 
 0880  73 FA                 C  	JNB	FFM90 
 0882  04 3A                 C  	ADD	AL,LOW OFFSET "0"+10D   ;ADD TO DETERMINE 
				SECOND DIGIT 
 0884  43                    C  	INC	BX		;POINT TO NEXT BUFFER POSITION 
 0885  86 C4                 C  	XCHG	AL,AH		;PREPARE FOR WORD STORE 
 0887  89 07                 C  	MOV	WORD PTR 0[BX],AX	;STORE 2 DIGITS OF EXPON
				ENT 
 0889  43                    C  	INC	BX		;INCREMENT TO NEXT BUFFER POSITION 
 088A  43                    C  	INC	BX 
 088B  C6 07 00              C  FFM100: MOV	BYTE PTR 0[BX],LOW 0	;SIGNAL END OF
				 BUFFER DATA 
 088E  87 D9                 C  	XCHG	BX,CX		;END-OF-BUFFER PTR. IN (CX) 
 0890  BB 0001 E             C  	MOV	BX,OFFSET $FBUFF+1	;START IN (BX) 
 0893  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 UTILS	   UTILITY ROUTINES 
                             C   
                             C   
                             C   
                             C  ;string printer must fetch from code segment 
 0894  E8 0000 E             C  STOULP: CALL	OUTDO		;send char 
 0897  3C 0D                 C  	CMP	AL,LOW 13D	;carriage return? 
 0899  75 03                 C  	JNZ	STROUT		;no 
 089B  E8 0000 E             C  	CALL	CRFIN		;force carriage back to left 
 089E                        C  STROUT:			;fetch from code segment 
 089E  2E: 8A 07             C  	MOV	AL,BYTE PTR CS:0[BX]	;get char 
 08A1  43                    C  	INC	BX		;point at next one 
 08A2  0A C0                 C  	OR	AL,AL		;end of string? 
 08A4  75 EE                 C  	JNZ	STOULP		;no print char until done 
 08A6  C3                    C  	RET 
 08A7                        C  $DZERO:			;DOUBLE PRECISION ZERO 
 08A7  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 08AA  B9 0004               C  	MOV	CX,4 
 08AD  B8 0000               C  	MOV	AX,0 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-44
UTILS	   UTILITY ROUTINES                                   

 08B0  FC                    C  	CLD 
 08B1  F3/ AB                C   REP	STOSW 
 08B3  C3                    C  	RET 
                             C   
 08B4                        C  ZERO: 
 08B4                        C  $ZERO:				;ZERO THE FAC 
 08B4  B8 0000               C  	MOV	AX,0 
 08B7  A3 0000 E             C  	MOV	WORD PTR $FACLO,AX	;ZERO LOWER 2 BYTES 
 08BA  A3 FFFF E             C  	MOV	WORD PTR $FAC-1,AX	;ZERO UPPER TWO BYTES 
 08BD  C3                    C  	RET 
                             C   
 08BE                        C  SIGN: 
 08BE                        C  $SIGNS:			;DETERMINE SIGN OF FAC 
                             C  				;ZF=1 IF ($FAC)=0, SF=1 IF ($FAC) .LT.0, NE
				ITHER OF 
                             C  				;THESE FLAGS SET IF ($FAC).GT.0 
 08BE  E8 08EE R             C  	CALL	$GETYP		;IF NOT INTEGER CAN LOOK AT FAC:F
				AC-1 
 08C1  75 03                 C  	JNE	SIS01 
 08C3  E9 0000 E             C  	JMP	TMERR		;Strings illegal 9-Mar-82/ngt 
 08C6                        C  SIS01: 
 08C6  79 0E                 C  	JNS	SIS05		;NOT INTEGER PROCEED 
 08C8  A1 0000 E             C  	MOV	AX,WORD PTR $FACLO	;FETCH INTEGER 
 08CB  0B C0                 C  	OR	AX,AX		;DETERMINE SIGN 
 08CD  74 1E                 C  	JZ	SIS10 
 08CF  B0 01                 C  	MOV	AL,LOW 1 
 08D1  79 1A                 C  	JNS	SIS10 
 08D3  F6 D8                 C  	NEG	AL 
 08D5  C3                    C  	RET 
 08D6                        C  SIS05: 
 08D6  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC	;FIRST CHECK FOR ZERO 
 08D9  0A C0                 C  	OR	AL,AL 
 08DB  74 10                 C  	JZ	SIS10		;IF ZERO JUST RETURN 
 08DD  A0 FFFF E             C  	MOV	AL,BYTE PTR $FAC-1	;FETCH SIGN BYTE 
 08E0  0A C0                 C  SIGNAL: OR	AL,AL		;SIGNSET NOW 
 08E2  74 07                 C  	JZ	SIS07		;MUST MAKE AL=1 AND ZF=0 
 08E4  B0 01                 C  	MOV	AL,LOW 1 
 08E6  79 05                 C  	JNS	SIS10 
 08E8  F6 D8                 C  	NEG	AL 
 08EA  C3                    C  	RET 
 08EB  0C 01                 C  SIS07:	OR	AL,LOW 1	;KNOW POSITIVE NON-ZERO 
 08ED  C3                    C  SIS10:	RET 
                             C   
                             C  ; 
                             C  ; Set cond. codes according to type value. 
                             C  ;   S, C = Integer 
                             C  ;   Z, C = String 
                             C  ;      C = Single Precision 
                             C  ;   None = Double Precision 
                             C  ; 
 08EE                        C  $GETYP: 
 08EE  A0 0000 E             C  	MOV	AL,BYTE PTR $VALTP	;FETCH TYPE VARIABLE 
 08F1  3C 08                 C  	CMP	AL,LOW 10	;CF=1 EXCEPT FOR DOUBLE PREC. 
 08F3  FE C8                 C  	DEC	AL		;WILL SUBTRACT 3 WITH DECBREMENTS 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-45
UTILS	   UTILITY ROUTINES                                   

 08F5  FE C8                 C  	DEC	AL 
 08F7  FE C8                 C  	DEC	AL 
 08F9  C3                    C  	RET			;ZF=1 IF STRING,SF=1 IF INTEGER 
                             C  				;PO=1 IF SINGLE PREC 
                             C   
 08FA                        C  $VADDH:			;ADD .5 ACCORDING TO TYPE 
 08FA  E8 08EE R             C  	CALL	$GETYP		;SET CODES ACCORDING TO TYPE 
 08FD  72 0C                 C  	JB	$FADDH 
 08FF                        C  $DADDH:			;DOUBLE PRECISION ADD .5 
 08FF  53                    C  	PUSH	BX 
 0900  BB 0499 R             C  	MOV	BX,OFFSET $DHALF 
 0903  E8 09CF R             C  	CALL	$MOVAC		;MOVE TO ARG 
 0906  E8 12E3 R             C  	CALL	$FADDD		;ADD TO FAC 
 0909  5B                    C  	POP	BX 
 090A  C3                    C  	RET 
 090B                        C  $FADDH:			;SINGLE PRECISION ADD .5 
 090B  33 D2                 C  	XOR	DX,DX		;WILL SET (BXDX)=.5 
 090D  BB 8000               C  	MOV	BX,100000 
 0910  E8 139F R             C  	CALL	$FADDS		;ADD .5 TO FAC 
 0913  C3                    C  	RET 
 0914                        C  $DIV10:			;DIVIDE FAC BY 10 
 0914  E8 08EE R             C  	CALL	$GETYP 
 0917  BB 0359 R             C  	MOV	BX,OFFSET $DPM01	;ADDRESS .1 
 091A  72 11                 C  	JB	ML10 
 091C  EB 08                 C  	JMP	SHORT ML05	;MULTIPLY 
                             C   
 091E                        C  $MUL10:			;MULTIPLY THE FAC BY 10 
 091E  E8 08EE R             C  	CALL	$GETYP		;SEE IF SINGLE OR DOUBLE PREC 
 0921  BB 0369 R             C  	MOV	BX,OFFSET $DP01 ;ADDRESS OF DOUBLE PREC 10
				. 
 0924  72 07                 C  	JB	ML10		;JUMP IF SINGLE 
 0926  E8 09CF R             C  ML05:	CALL	$MOVAC		;MOVE 10. TO ARG 
 0929  E8 1873 R             C  	CALL	$FMULD		;MULTIPLY 
 092C  C3                    C  	RET 
 092D                        C  ML10:				;MULTIPLY SINGLE PREC. FAC BY NO. POIN
				TED TO BY BX 
 092D                        C  $MLSP: 
 092D  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 ;PUSH FAC ON THE STACK 
 0931  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 0935  C6 06 0000 E 08       C  	MOV	BYTE PTR $VALTP,LOW 10	;SET UP D.P. 
 093A  E8 09D4 R             C  	CALL	$MOVFC		;MOVE DOUBLE PREC. 10 TO FAC 
 093D  E8 17AA R             C  	CALL	$CSD		;CONVERT TO SINGLE PRECISION 
 0940  5A                    C  	POP	DX		;GET LOW MANTISSA BITS 
 0941  5B                    C  	POP	BX		;EXP SIGN AND HIGH MATISSA BITS 
 0942  E8 191D R             C  	CALL	$FMULS		;MULTIPLY 
 0945  C3                    C  	RET 
                             C   
                             C   
 0946  B9 0004               C  $RDL:	MOV	CX,4		;WILL SHIFT 4 WORDS LEFT 
 0949  D1 17                 C  RDL120: RCL	WORD PTR 0[BX],1	;SHIFT  LEFT 1 BIT
				 SHIFTING IN CF 
 094B  43                    C  	INC	BX 
 094C  43                    C  	INC	BX 
 094D  E2 FA                 C  	LOOP	RDL120 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-46
UTILS	   UTILITY ROUTINES                                   

 094F  C3                    C  	RET 
 0950  B9 0004               C  $SHDR:	MOV	CX,4		;DO DOUBLE PRECISION RIGHT SHI
				FT 
 0953                        C  $SHRM:				;SHIFT NO. POINTED TO BY (BX) , (CX) 
				WDS RT. 
 0953  D1 1F                 C  	RCR	WORD PTR 0[BX],1	;SHIFT 1 WD. RT. THRU CF 
 0955  4B                    C  	DEC	BX 
 0956  4B                    C  	DEC	BX		;TO NEXT WD. 
 0957  E2 FA                 C  	LOOP	$SHRM		;DO THIS (CX) TIMES 
 0959  C3                    C  	RET 
 095A  80 4F 02 20           C  SHST:	OR	BYTE PTR 2[BX],LOW 40	;"OR" IN ST BIT 
 095E  E2 01                 C  	LOOP	$SHRA 
 0960  C3                    C  	RET 
 0961                        C  $SHRA:				;SHIFT $ARG RIGHT (CX) BITS 
 0961  BB FFFE E             C  	MOV	BX,OFFSET $ARG-2 
 0964  80 F9 08              C  	CMP	CL,LOW 10	;CAN I DO A BYTE MOVE 
 0967  72 24                 C  	JB	SHRA30		;IF NOT PROCEED AS NORMAL 
                             C  ;**********************************************
				*************** 
                             C  ;FOR SPEED PURPOSES WE WILL DO A BYTE MOVE TO T
				HE RIGHT 
                             C  ;**********************************************
				*************** 
 0969  51                    C  	PUSH	CX		;SAVE BITS TO SHIFT 
 096A  B9 0007               C  	MOV	CX,7		;7 BYTE MOVE 
 096D  BB FFFF E             C  	MOV	BX,OFFSET $ARGLO-1 
 0970  8A 27                 C  	MOV	AH,BYTE PTR 0[BX]	;FETCH OVERFLOW BYTE 
 0972  8A 47 01              C  SHRA11: MOV	AL,BYTE PTR 1[BX] 
 0975  88 07                 C  	MOV	BYTE PTR 0[BX],AL 
 0977  43                    C  	INC	BX 
 0978  E2 F8                 C  	LOOP	SHRA11 
 097A  32 C0                 C  	XOR	AL,AL 
 097C  88 07                 C  	MOV	BYTE PTR 0[BX],AL 
 097E  59                    C  	POP	CX		;RECALL BIT COUNT 
 097F  80 E9 08              C  	SUB	CL,LOW 10 
 0982  80 E4 20              C  	AND	AH,LOW 40	;WILL NEED TO RE-ESTABLISH ST 
 0985  74 DA                 C  	JZ	$SHRA		;NO-ST JUST PROCEED 
 0987  08 26 FFFF E          C  	OR	BYTE PTR $ARGLO-1,AH 
 098B  EB D4                 C  	JMP	$SHRA 
 098D                        C  SHRA30: 
 098D  0A C9                 C  	OR	CL,CL 
 098F  74 0E                 C  	JZ	SHRA40		;JUMP IF DONE 
 0991  51                    C  	PUSH	CX		;SAVE NO. BITS TO SHIFT 
 0992  F8                    C  	CLC			;DON'T WANT THE CARRY SHIFTED IN 
 0993  E8 0950 R             C  	CALL	$SHDR 
 0996  59                    C  	POP	CX 
 0997  F6 47 02 10           C  	TEST	BYTE PTR 2[BX],LOW 20	;SEE IF SHIFTED THR
				U "ST" 
 099B  75 BD                 C  	JNZ	SHST		;MUST "OR" ST BIT IN IF NON-ZERO 
 099D  E2 C2                 C  	LOOP	$SHRA 
 099F  C3                    C  SHRA40: RET 
                             C   
                             C   
 09A0  BE 0000 E             C  $XCGAF: MOV	SI,OFFSET $DFACL	;WILL EXCHANGE FAC
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-47
UTILS	   UTILITY ROUTINES                                   

				 AND ARG (D.P.) 
 09A3  BF 0000 E             C  	MOV	DI,OFFSET $ARGLO 
 09A6  FC                    C  	CLD			;SO MOVW WILL INCREMENT INDICES 
 09A7  B9 0004               C  	MOV	CX,4		;WILL MOVE 4 WORDS (8 BYTES) 
 09AA  8B 05                 C  XCG10:	MOV	AX,WORD PTR 0[DI]	;FETCH DESTINATION
				 WORD 
 09AC  A5                    C  	MOVSW			;MOVE FAC TO ARG & INCREMENT INDICES 
 09AD  89 44 FE              C  	MOV	WORD PTR -2[SI],AX	;ARG TO FAC 
 09B0  E2 F8                 C  	LOOP	XCG10		;CONTINUE 
 09B2  C3                    C  	RET 
                             C   
                             C  ;**********************************************
				*********************** 
                             C  ;       SPECIAL MOVE ROUTINES FOR HANDLING CONS
				TANTS FROM THE CODE 
                             C  ;       SEGMENT 
                             C  ;**********************************************
				*********************** 
 09B3                        C  $MOVBS:			;THIS ROUTINE IS USED TO MOVE A SINGL
				E PRECISION NO. FROM THE 
                             C  				;CODE SEGMENT TO $DBUFF. THE NO. IS POINTED
				 TO BY (BX) 
 09B3  BF 0004 E             C  	MOV	DI,OFFSET $DBUFF+4 
 09B6  B9 0002               C  	MOV	CX,2 
 09B9  EB 06                 C  	JMP	SHORT MBF10 
 09BB                        C  $MOVBF:			;THIS ROUTINE IS USED TO MOVE A DOUBL
				E PRECISION NO. FROM THE 
                             C  				;CODE SEGMENT TO $DBUFF. THE NO. IS POINTED
				 TO BY (BX) 
 09BB  BF 0000 E             C  	MOV	DI,OFFSET $DBUFF 
 09BE  B9 0004               C  MBF05:	MOV	CX,4 
 09C1  FC                    C  MBF10:	CLD 
 09C2  8B F3                 C  	MOV	SI,BX		;SO WE CAN USE A LODW 
 09C4                        C  MBF20: 
 09C4  2E: AD                C  	LODS	WORD PTR ?CSLAB ;FETCH FROM CS 
 09C6  AB                    C  	STOSW			;STORE IN DBUFF 
 09C7  E2 FB                 C  	LOOP	MBF20		;CONTINUE WITH MOVE 
 09C9  8B DF                 C  	MOV	BX,DI		;UPDATE (BX) 
 09CB  83 EB 02              C  	SUB	BX,2		;GET POINTER CORRECT 
 09CE  C3                    C  	RET 
                             C   
 09CF                        C  $MOVAC:			;ROUTINE TO MOVE A DOUBLE PRECISION N
				O. POINTED TO BY (BX) 
                             C  				;FROM THE CODE SEGMENT TO ARG 
 09CF  BF 0000 E             C  	MOV	DI,OFFSET $ARGLO 
 09D2  EB EA                 C  	JMP	SHORT MBF05 
                             C   
 09D4                        C  $MOVFC:			;ROUTINE USED TO MOVE A DOUBLE PRECIS
				ION NO. FROM THE CODE 
                             C  				;SEGMENT TO THE FAC. NO. IS POINTED TO BY (
				BX) 
 09D4  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 09D7  EB E5                 C  	JMP	SHORT MBF05 
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-48
UTILS	   UTILITY ROUTINES                                   

 09D9                        C  MOVAM:				;MOVE NO. POINTED TO BY BX TO ARG 
 09D9  BF 0000 E             C  	MOV	DI,OFFSET $ARGLO	;LOW ADDRESS OF ARG 
 09DC  B9 0004               C  	MOV	CX,4		;MOVE DOUBLE PREC NO. POINTED TO 
                             C  				;BY (BX) TO DOUBLE PREC NO. POINTED TO 
                             C  				;BY (DI) 
 09DF                        C  MOVEM:				;MOVE NO. POINTED TO BY (BX) TO NO. P
				OINTED TO BY (DI) 
                             C  				;FOR (CX) WORDS 
 09DF  87 DE                 C  	XCHG	BX,SI		;SO MOVW CAN BE USED 
 09E1  FC                    C  	CLD			;SO MOVW WILL INC 
                             C  		     ;DO MOVE (CX) TIMES 
 09E2  F3/ A5                C   REP	MOVSW			;MOVE "FROM" TO "TO" 
 09E4  87 DE                 C  	XCHG	BX,SI		;GET REGISTERS STRAIGHT 
 09E6  C3                    C  	RET 
                             C   
 09E7                        C  $MOVAF:			;MOVE THE $FAC TO $ARG 
 09E7  51                    C  	PUSH	CX		;SAVE CX,BX,DI 
 09E8  53                    C  	PUSH	BX 
 09E9  57                    C  	PUSH	DI 
 09EA  BB 0000 E             C  	MOV	BX,OFFSET $DFACL	;"FROM" ADDRESS 
 09ED  BF 0000 E             C  	MOV	DI,OFFSET $ARGLO	;"TO" ADDRESS 
 09F0  B9 0004               C  MAF05:	MOV	CX,4		;4 16-BIT QUANTITIES TO MOVE 
 09F3  E8 09DF R             C  	CALL	MOVEM		;DO THE MOVE 
 09F6  5F                    C  	POP	DI 
 09F7  5B                    C  	POP	BX 
 09F8  59                    C  	POP	CX		;REGISTERS RESTORED 
 09F9  C3                    C  	RET 
                             C   
                             C   
                             C   
 09FA                        C  $MOVFA:			;MOVE THE $ARG TO THE FAC 
 09FA  51                    C  	PUSH	CX 
 09FB  53                    C  	PUSH	BX 
 09FC  57                    C  	PUSH	DI		;SAVE REGISTERS 
 09FD  BB 0000 E             C  	MOV	BX,OFFSET $ARGLO	;"FROM" ADDRESS 
 0A00  BF 0000 E             C  	MOV	DI,OFFSET $DFACL	;"TO" ADDRESS 
 0A03  EB EB                 C  	JMP	SHORT MAF05	;GO MOVE 
                             C  ;**********************************************
				**************** 
                             C  ;SINGLE PRECISION MOVE ROUTINES 
                             C  ;**********************************************
				***************** 
 0A05                        C  $MOVFR:			;MOVE (BXDX) TO FAC 
 0A05  89 16 0000 E          C  	MOV	WORD PTR $FACLO,DX 
 0A09  89 1E FFFF E          C  	MOV	WORD PTR $FAC-1,BX 
 0A0D  C3                    C  	RET 
                             C   
 0A0E                        C  $MOVRF:			;MOVE THE FAC INTO REGISTERS (BXDX) 
 0A0E  8B 16 0000 E          C  	MOV	DX,WORD PTR $FACLO 
 0A12  8B 1E FFFF E          C  	MOV	BX,WORD PTR $FAC-1 
 0A16  C3                    C  	RET 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-49
UTILS	   UTILITY ROUTINES                                   

                             C  	PAGE 
                             C  ; 
                             C  ; ZCMPCK is called by the comparison routines t
				o handle the 
                             C  ; cases where the exponent of either or both of
				 the numbers 
                             C  ; is zero.  These must be treated as special ca
				ses because 
                             C  ; a number whose exponent is zero is zero regar
				dless of the 
                             C  ; garbage that might be in the mantissa. 
                             C  ; 
                             C  ; On entry -    BH=exponent of comperand 
                             C  ;               Bit 7 of BL=sign of comperand 
                             C  ; 
                             C  ; On exit -     Carry clear - caller must conti
				nue comparison. 
                             C  ; 
                             C  ;               Carry set - comparison is finis
				hed. 
                             C  ;               A=1, Z=0, S=0 for FAC .GT. comp
				erand 
                             C  ;               A=0, Z=1 for FAC .EQ. comperand
				 
                             C  ;               A=377 octal, Z=0, S=1 for FAC .
				LT. comperand 
                             C  ; 
                             C   
 0A17  0A FF                 C  ZCMPCK: OR	BH,BH		;Is the comperand zero? 
 0A19  75 05                 C  	JNZ	NZCOMP		;No. 
 0A1B  E8 08D6 R             C  	CALL	SIS05		;Yes, result is the sign of the FA
				C. 
 0A1E  F9                    C  	STC			;Set carry to say comparison is done 
 0A1F  C3                    C  	RET			;and return. 
                             C   
 0A20  A0 0000 E             C  NZCOMP: MOV	AL,BYTE PTR $FAC	;Is the FAC zero? 
 0A23  0A C0                 C  	OR	AL,AL		;(Also clear carry.) 
 0A25  75 08                 C  	JNZ	ZCMPRT		;No, return with carry clear to te
				ll 
                             C  				;the caller he must continue. 
 0A27  8A C3                 C  	MOV	AL,BL		;Yes, the result is the opposite 
 0A29  F6 D0                 C  	NOT	AL		;of the sign of the comperand. 
 0A2B  E8 08E0 R             C  	CALL	SIGNAL 
 0A2E  F9                    C  	STC			;Set carry to say comparison is 
 0A2F  C3                    C  ZCMPRT: RET			;finished and return. 
                             C   
                             C  ; 
                             C  ; ZCMPBX performs the special zero check for th
				e case where 
                             C  ; BX points to the comperand. 
                             C  ; 
                             C   
 0A30  53                    C  ZCMPBX: PUSH	BX		;Preserve the comperand pointe
				r. 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-50
UTILS	   UTILITY ROUTINES                                   

 0A31  8B 1F                 C  	MOV	BX,WORD PTR 0[BX]	;BH:=exponent, BL bit 7:
				=sign for 
                             C  				;ZCMPCK. 
 0A33  E8 0A17 R             C  	CALL	ZCMPCK		;Check for the zero cases. 
 0A36  5B                    C  	POP	BX		;Retrieve the comperand pointer 
 0A37  C3                    C  	RET			;and return. 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-51
UTILS	   UTILITY ROUTINES                                   

                             C  	PAGE 
                             C   
 0A38                        C  $VCOMP:			;DETERMINE IF SINGLE OR DOUBLE PRECIS
				ION AND COMPARE ACCORDINGLY 
 0A38  E8 08EE R             C  	CALL	$GETYP		;SET CODES ACCORDING TO TYPE 
 0A3B  72 43                 C  	JB	$COMPM		;DO S.P. COMPARE 
 0A3D  E9 0AD2 R             C  	JMP	$DCMPM		;GO DO D.P. COMPARE 
                             C   
 0A40                        C  $FCOMP:			;SINGLE PRECISION COMPARE OF ($FAC) A
				ND (BXDX) 
                             C  				;(AL)=1 AND ZF=0,SF=0,CF=0 IF ($FAC).GT.(BX
				DX) 
                             C  				;(AL)=0 AND ZF=1 IF ($FAC)=(BXDX) 
                             C  				;(AL)=377 AND ZF=0,SF=1,CF=1 IF ($FAC).LT.(
				BXDX) 
                             C   
 0A40  E8 0A17 R             C  	CALL	ZCMPCK		;Check for zero exponent cases. 
 0A43  72 36                 C  	JB	ZEREXP		;All done if carry set. 
 0A45  53                    C  	PUSH	BX 
 0A46  57                    C  	PUSH	DI		; 
 0A47  8A C3                 C  	MOV	AL,BL		;SIGN OF (BXDX) TO (AL) 
 0A49  32 06 FFFF E          C  	XOR	AL,BYTE PTR $FAC-1	;SET CODES FOR SIGNS 
 0A4D  78 43                 C  	JS	CPM05 
 0A4F  0A DB                 C  	OR	BL,BL 
 0A51  78 10                 C  	JS	UFC10		;NEGATIVE NOS. 
 0A53  A1 FFFF E             C  	MOV	AX,WORD PTR $FAC-1	;SIGNS SAME MUST COMPAR
				E 
 0A56  2B C3                 C  	SUB	AX,BX		;SUBTRACT HIGH WORD 
 0A58  72 46                 C  	JB	CPM10		;($FAC) SMALLER 
 0A5A  75 3E                 C  	JNZ	CPM06		;($FAC) LARGER 
 0A5C  A1 0000 E             C  	MOV	AX,WORD PTR $FACLO	;MUST COMPARE LOW WORD 
 0A5F  2B C2                 C  	SUB	AX,DX		; 
 0A61  EB 10                 C  	JMP	SHORT TSTFLG	;return comparison result bas
				ed on flags 
 0A63  8B C3                 C  UFC10:	MOV	AX,BX		;SINCE NEGATIVE LARGER MAGNIT
				UDE IS 
 0A65  2B 06 FFFF E          C  	SUB	AX,WORD PTR $FAC-1	;SMALLER NO. 
 0A69  72 35                 C  	JB	CPM10 
 0A6B  75 2D                 C  	JNZ	CPM06		;(BXDX) SMALLER 
 0A6D  8B C2                 C  	MOV	AX,DX		;MUST COMPARE LOW WORD 
 0A6F  2B 06 0000 E          C  	SUB	AX,WORD PTR $FACLO 
 0A73  72 2B                 C  TSTFLG: JB	CPM10		;branch if FAC is smaller tha
				n comperand 
 0A75  75 23                 C  	JNZ	CPM06		;branch if FAC is larger than compe
				rand 
 0A77  32 C0                 C  	XOR	AL,AL		;FAC is equal to comperand 
 0A79  EB 51                 C  	JMP	SHORT CPM80 
                             C   
                             C  ;One of the exponents was zero (meaning the num
				ber=0). 
                             C  ; Set Carry flag if [AL]=377 (if FAC is less th
				an comperand) 
                             C  ; 
 0A7B  FE C0                 C  ZEREXP: INC	AL		;Map AL from (377, 0, 1) to (0,
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-52
UTILS	   UTILITY ROUTINES                                   

				 1, 2) 
 0A7D  2C 01                 C  	SUB	AL,LOW 1	;Map it back, setting Flags appro
				priately 
 0A7F  C3                    C  	RET 
                             C   
 0A80                        C  $COMPM:			;COMPARE FAC TO NUMBER POINTED TO BY 
				(BX) 
                             C  ;       (BX) MUST BE POINTING TO SIGN BYTE OF N
				O. 
                             C  				;SET (AL)=1,ZF=0,SF=0,CF=0 IF (FAC).GT.[BX]
				 
                             C  				;    (AL)=0,ZF=1 IF (FAC)=[BX] 
                             C  				;    (AL)=377,ZF=0,SF=1,CF=1 IF (FAC).LT.[B
				X] 
                             C   
 0A80  E8 0A30 R             C  	CALL	ZCMPBX		;Check for zero exponent cases. 
 0A83  72 F6                 C  	JB	ZEREXP		;All done if carry set. 
 0A85  53                    C  	PUSH	BX		;SAVE INITIAL ADDRESS 
 0A86  57                    C  	PUSH	DI		;SAVE DI 
 0A87  BF FFFF E             C  	MOV	DI,OFFSET $FAC-1 
 0A8A  8B 07                 C  	MOV	AX,WORD PTR 0[BX]	;FETCH SIGN BYTE INTO AL
				 
 0A8C  32 06 FFFF E          C  	XOR	AL,BYTE PTR $FAC-1	;SF=1 IF SIGNS DIFFEREN
				T 
 0A90  79 13                 C  	JNS	CPM20 
                             C  ;**********************************************
				******************* 
                             C  ;SIGNS ARE DIFFERENT , THE ONE WITH POS. SIGN I
				S BIGGER 
                             C  ;**********************************************
				******************** 
 0A92  8A 26 FFFF E          C  CPM05:	MOV	AH,BYTE PTR $FAC-1	;FETCH FAC SIGN 
 0A96  0A E4                 C  	OR	AH,AH 
 0A98  78 06                 C  	JS	CPM10		;FAC IS SMALLER MUST SET (AL)=377 
 0A9A  B0 01                 C  CPM06:	MOV	AL,LOW 1 
 0A9C  0A C0                 C  	OR	AL,AL		;MIGHT HAVE GOTTEN A ZF=1 ON LAST "O
				R" 
 0A9E  EB 2C                 C  	JMP	SHORT CPM80 
 0AA0  B0 FF                 C  CPM10:	MOV	AL,LOW 377	;KNOW SF=1 
 0AA2  F9                    C  	STC			;WANT CF=1 IF FAC SMALLER 
 0AA3  EB 27                 C  	JMP	SHORT CPM80 
 0AA5                        C  CPM20: 
                             C  ;**********************************************
				******************** 
                             C  ;SIGNS ARE THE SAME MUST DO ACTUAL COMPARE 
                             C  ;**********************************************
				******************** 
 0AA5  51                    C  	PUSH	CX		;WILL USE (CX) FOR LOOP CONTROL 
 0AA6  B9 0002               C  	MOV	CX,2 
 0AA9  87 DE                 C  CPM22:	XCHG	BX,SI		;SO CMPW CAN BE USED 
 0AAB  A0 FFFF E             C  	MOV	AL,BYTE PTR $FAC-1	;IF NEGATIVE NO. NEED T
				O REVERSE CMP 
 0AAE  0A C0                 C  	OR	AL,AL 
 0AB0  79 02                 C  	JNS	CPM25 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-53
UTILS	   UTILITY ROUTINES                                   

 0AB2  87 F7                 C  	XCHG	SI,DI		;WILL CAUSE CORRECT COMPARE FOR NE
				G. 
 0AB4                        C  CPM25: 
 0AB4  FD                    C  	STD			;SO CMPW WILL DECREMENT 
 0AB5  A7                    C  CPM30:	CMPSW			;FORM CODES FOR (.SI)-(.DI) 
 0AB6  75 06                 C  	JNZ	CPM50 
 0AB8  E2 FB                 C  	LOOP	CPM30		;CONTINUE THRU VALUES 
 0ABA  B0 00                 C  	MOV	AL,LOW 0	;ZF=1 ALREADY SET 
 0ABC  EB 0D                 C  	JMP	SHORT CPM70 
 0ABE  73 06                 C  CPM50:	JNB	CPM60		;MEMORY VALUE LARGER 
 0AC0  B0 01                 C  	MOV	AL,LOW 1	;FAC LARGER SF=0,ZF=0 
 0AC2  0A C0                 C  	OR	AL,AL 
 0AC4  EB 05                 C  	JMP	SHORT CPM70 
 0AC6                        C  CPM60:				;MEMORY IS LARGER MUST SET SF=1 AND (
				AL)=377 
 0AC6  B0 FF                 C  	MOV	AL,LOW 377 
 0AC8  0A C0                 C  	OR	AL,AL 
 0ACA  F9                    C  	STC			;WANT CF=1 IF MEMORY VALUE LARGER 
 0ACB  59                    C  CPM70:	POP	CX		;RESTORE CX REGISTER 
 0ACC                        C  CPM80: 
 0ACC  5F                    C  	POP	DI 
 0ACD  5B                    C  	POP	BX 
 0ACE  C3                    C  	RET 
                             C   
 0ACF                        C  $DCMPA:			;DOUBLE PRECISION COMPARE OF ($FAC) A
				ND ($ARG) 
 0ACF  BB FFFF E             C  	MOV	BX,OFFSET $ARG-1 
                             C   
 0AD2                        C  $DCMPM:			;DOUBLE PRECISION COMPARE OF ($FAC) A
				ND ((BX)) 
                             C  				;(AL)=1 AND ZF=0,SF=0,CF=0 IF ($FAC).GT.((B
				X)) 
                             C  				;(AL)=0 AND ZF=1 IF ($FAC)=((BX)) 
                             C  				;(AL)=377 AND ZF=0,SF=1,CF=1 IF ($FAC).LT.(
				(BX)) 
                             C   
 0AD2  E8 0A30 R             C  	CALL	ZCMPBX		;Check for zero exponent cases. 
 0AD5  72 A4                 C  	JB	ZEREXP		;All done if carry set. 
 0AD7  53                    C  	PUSH	BX 
 0AD8  57                    C  	PUSH	DI		;SAVE REGISTERS 
 0AD9  BF FFFF E             C  	MOV	DI,OFFSET $FAC-1	;D.P. HIGH FAC WORD 
 0ADC  8A 05                 C  	MOV	AL,BYTE PTR 0[DI]	;WILL FIRST SEE IF SIGNS
				 DIFFERENT 
 0ADE  32 07                 C  	XOR	AL,BYTE PTR 0[BX] 
 0AE0  79 02                 C  	JNS	DC10		;PROCEED IF NOT DIFFERENT 
 0AE2  EB AE                 C  	JMP	SHORT CPM05	;SIGNS DIFFERENT SET CODES ACC
				ORDINGLY 
 0AE4  51                    C  DC10:	PUSH	CX 
 0AE5  B9 0004               C  	MOV	CX,4		;FOUR WORDS TO COMPARE 
 0AE8  EB BF                 C  	JMP	SHORT CPM22	;GO COMPARE 
                             C   
                             C   
 0AEA                        C  $CONI2:			;CHECK FAC FOR -32768 SINGLE PRECISIO
				N AND IF 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-54
UTILS	   UTILITY ROUTINES                                   

                             C  				;EQUAL CONVERT TO INTEGER 
 0AEA  BB 052E R             C  	MOV	BX,OFFSET $S32KM	;ADDRESS OF S.P. -32768 
 0AED  E8 09B3 R             C  	CALL	$MOVBS		;MOVE IT OUT TO DBUFF FOR COMPARI
				SON 
 0AF0  E8 0A80 R             C  	CALL	$COMPM		;ONLY INTERESTED IN ZF 
 0AF3  75 0B                 C  	JNZ	CON10		;IF NOT EQUAL JUST RETURN 
 0AF5  C6 06 0000 E 02       C  	MOV	BYTE PTR $VALTP,LOW 2	;TO INDICATE INTEGER
				 
 0AFA  C7 06 0000 E 8000     C  	MOV	WORD PTR $FACLO,OFFSET 200*400	;-32768 
 0B00  C3                    C  CON10:	RET 
                             C   
                             C   
 0B01                        C  $RSUBM:			;SUBTRACT NO POINTED TO BY (BP) FROM 
				(BLDX) 
                             C  				;NUMBER POINTED TO BY (BP) IS PRESUMED TO B
				E IN 
                             C  				;THE CODE SEGMENT 
 0B01  2E: 2B 56 00          C  	SUB	DX,WORD PTR CS:0[BP]	;FIRST 16 BITS 
 0B05  2E: 1A 5E 02          C  	SBB	BL,BYTE PTR CS:2[BP] 
 0B09  C3                    C  	RET			;COND. FLAGS ALL SET 
                             C   
                             C  ;**********************************************
				*********** 
                             C  ;THE "V" UTILITIES FOLLOW. THESE UTILITIES HAVE
				 ONE THING IN 
                             C  ;COMMON: THEY MUST FIRST ASCERTAIN WHAT TYPE OF
				 VARIABLE 
                             C  ;THEY ARE TO WORK ON BEFORE PERFORMING THEIR TA
				SK. 
                             C  ;**********************************************
				************** 
 0B0A                        C  ABSFN: 
 0B0A                        C  $VABS:				;ABSOLUTE VALUE ROUTINE 
 0B0A  E8 08EE R             C  	CALL	$GETYP		;SEE WHAT TYPE VARIABLE 
 0B0D  78 08                 C  	JS	$IABS		;IF INTEGER PROCEED 
 0B0F  A0 FFFF E             C  	MOV	AL,BYTE PTR $FAC-1 
 0B12  0A C0                 C  	OR	AL,AL		;SEE IF CURRENTLY NEGATIVE 
 0B14  78 0E                 C  	JS	$NEG		;AND IF SO NEGATE 
 0B16  C3                    C  	RET 
 0B17  A1 0000 E             C  $IABS:	MOV	AX,WORD PTR $FACLO	;FETCH INTEGER 
 0B1A  0B C0                 C  	OR	AX,AX		;AND SEE IF ALREADY POS. 
 0B1C  78 0F                 C  	JS	VN15 
 0B1E  C3                    C  	RET			;RETURN IF POSITIVE 
                             C   
 0B1F                        C  VNEG: 
 0B1F                        C  $VNEG:				;NEGATE THE VALUE IN THE FAC 
 0B1F  E8 08EE R             C  	CALL	$GETYP		;SET COND. CODES ACCORDING TO TYP
				E 
 0B22  78 06                 C  	JS	$INEG		;IT'S INTEGER MUST COMPLEMENT 
                             C  ;**********************************************
				************** 
                             C  ;IT'S SINGLE OR DOUBLE PRECISION MUST FLIP THE 
				SIGN BIT 
                             C  ;**********************************************
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-55
UTILS	   UTILITY ROUTINES                                   

				************** 
 0B24                        C  NEG: 
 0B24                        C  $NEG: 
 0B24  80 36 FFFF E 80       C  	XOR	BYTE PTR $FAC-1,LOW 200 ;FLIP SIGN OF FAC 
 0B29  C3                    C  	RET 
 0B2A                        C  INEG: 
 0B2A  A1 0000 E             C  $INEG:	MOV	AX,WORD PTR $FACLO	;WILL CHECK FOR -
				32768 
 0B2D  3D 8000               C  VN15:	CMP	AX,100000	;SEE IF -32768 
 0B30  75 07                 C  	JNZ	VN20		;IF NOT JUST NEGATE 
 0B32  53                    C  	PUSH	BX		;PRESERVE BX 
 0B33  E8 17E5 R             C  	CALL	$CSI		;CONVERT TO SINGLE PRECISION 
 0B36  5B                    C  	POP	BX		;RECALL BX 
 0B37  EB EB                 C  	JMP	$NEG		;GO NEGATE 
 0B39  F7 1E 0000 E          C  VN20:	NEG	WORD PTR $FACLO ;NEGATE 
 0B3D  C3                    C  	RET 
                             C   
 0B3E                        C  $SETDB:			;MOVE FAC TO DBUFF FOR MULT. AND ZERO
				 FAC 
 0B3E  BB 0001 E             C  	MOV	BX,OFFSET $DBUFF+1	; 
 0B41  E8 0B76 R             C  	CALL	$VMVMF		;MOVE FAC TO DBUFF 
 0B44  BF FFF8 E             C  	MOV	DI,OFFSET $DFACL-10	;WILL NOW ZERO 16 BYTE
				S OF FAC 
 0B47  B9 0008               C  	MOV	CX,10 
 0B4A  B8 0000               C  	MOV	AX,0 
 0B4D  FC                    C  	CLD 
 0B4E  F3/ AB                C   REP	STOSW			;STORES (AX) INTO LOCATIONS 
 0B50  A2 0000 E             C  	MOV	BYTE PTR $DBUFF,AL	;ZERO OVERFLOW BYTE 
 0B53  A2 FFFF E             C  	MOV	BYTE PTR $ARGLO-1,AL	;ZERO OVERFLOW BYTE O
				F ARG 
 0B56  C3                    C  	RET 
                             C   
 0B57                        C  $VMVAM:			;MOVE THE VALUE POINTED TO BY (BX) TO
				 (BXDX) IF SINGLE 
                             C  				;PRECISION, TO $ARG IF DOUBLE PRECISION 
 0B57  E8 08EE R             C  	CALL	$GETYP		;SET CODES ACCORDING TO TYPE 
 0B5A  72 03                 C  	JB	VM10		;JUMP IF SINGLE PRECISION 
 0B5C  E9 09D9 R             C  	JMP	MOVAM		;MOVE THE VALUE TO THE ARG 
 0B5F  8B 17                 C  VM10:	MOV	DX,WORD PTR 0[BX]	;FETCH LOW MANTISSA
				 BITS 
 0B61  8B 5F 02              C  	MOV	BX,WORD PTR 2[BX]	;FETCH HIGH MANTISSA AND
				 EXPONENT 
 0B64  C3                    C  	RET 
                             C   
                             C   
 0B65                        C  $VMOVM:			;MOVE THE VARIABLE POINTED TO BY (BX)
				 TO THE ONE POINTED 
                             C  				;TO BY (DI) 
 0B65  B9 0004               C  	MOV	CX,4		;ASSUME DOUBLE PRECISION 
 0B68  E8 08EE R             C  	CALL	$GETYP 
 0B6B  72 03                 C  	JB	VMM10		;IT'S SINGLE PREC JUMP 
 0B6D  E9 09DF R             C  	JMP	MOVEM		;GO DO MOVE 
 0B70  B9 0002               C  VMM10:	MOV	CX,2 
 0B73  E9 09DF R             C  	JMP	MOVEM		;GO DO MOVE 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-56
UTILS	   UTILITY ROUTINES                                   

                             C   
 0B76                        C  $VMVMF:			;MOVE THE FAC TO THE NO. POINTED TO B
				Y (BX) 
 0B76  B9 0004               C  	MOV	CX,4		;ASSUME DOUBLE PREC. 
 0B79  87 FB                 C  	XCHG	DI,BX		;(DI)=DESTINATION,(BX)=ORIGIN 
 0B7B  BB 0000 E             C  	MOV	BX,OFFSET $DFACL 
 0B7E  E8 08EE R             C  	CALL	$GETYP		;SET COND. CODES ACCORDING TO $VA
				LTP 
 0B81  72 03                 C  	JB	VMVM1		;JUMP IF S.P. 
 0B83  E9 09DF R             C  	JMP	MOVEM		;GO DO MOVE 
 0B86  87 DF                 C  VMVM1:	XCHG	BX,DI 
 0B88  B9 0002               C  $MOVMF: MOV	CX,2 
 0B8B  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
 0B8E  87 FB                 C  	XCHG	DI,BX 
 0B90  E9 09DF R             C  	JMP	MOVEM		;GO DO MOVE 
                             C   
 0B93                        C  $VMVFM:			;MOVE TO FAC THE NO POINTED TO BY (BX
				) 
 0B93  B9 0004               C  	MOV	CX,4		;ASSUME DOUBLE PREC 
 0B96  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 0B99  E8 08EE R             C  	CALL	$GETYP 
 0B9C  72 03                 C  	JB	$MOVFM 
 0B9E  E9 09DF R             C  	JMP	MOVEM 
 0BA1  B9 0002               C  $MOVFM: MOV	CX,2 
 0BA4  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
 0BA7  E9 09DF R             C  	JMP	MOVEM		;GO DO MOVE 
                             C   
 0BAA                        C  $VCMPM:			;COMPARE FAC TO NO. POINTED TO BY (BX
				) 
 0BAA  E8 08EE R             C  	CALL	$GETYP 
 0BAD  72 03                 C  	JB	VCMP10 
 0BAF  E9 0AD2 R             C  	JMP	$DCMPM		;DO DOUBLE PREC COMPARE 
 0BB2  E9 0A80 R             C  VCMP10: JMP	$COMPM		;SINGLE PREC COMPARE 
                             C   
 0BB5                        C  $VPSHF:			;PUSH THE FAC ON THE STACK ACCORDING 
				TO TYPE 
 0BB5  E8 08EE R             C  	CALL	$GETYP		;SET COND CODES ACCORDING TO $VAL
				TP 
 0BB8  B9 0004               C  	MOV	CX,4		;FOR DOUBLE PRECISION 
 0BBB  73 03                 C  	JNB	VPS10		;IF DOUBLE PREC PROCEED 
 0BBD                        C  $PUSHF:			;PUSH SINGLE PRECISION FAC ON THE STA
				CK 
 0BBD  B9 0002               C  	MOV	CX,2 
 0BC0  5D                    C  VPS10:	POP	BP		;GET RETURN ADDRESS OFF STACK 
 0BC1  BF FFFF E             C  	MOV	DI,OFFSET $FAC-1 
 0BC4  FF 35                 C  VPS20:	PUSH	WORD PTR 0[DI] 
 0BC6  4F                    C  	DEC	DI 
 0BC7  4F                    C  	DEC	DI 
 0BC8  E2 FA                 C  	LOOP	VPS20 
 0BCA  55                    C  	PUSH	BP		;GET RETURN ADDRESS RIGHT 
 0BCB  C3                    C  	RET			;AND RETURN 
 0BCC                        C  $POPA:				;POP STACK INTO ARG 
 0BCC  BF 0000 E             C  	MOV	DI,OFFSET $ARGLO 
 0BCF  B9 0004               C  	MOV	CX,4 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-57
UTILS	   UTILITY ROUTINES                                   

 0BD2  EB 11                 C  	JMP	SHORT VPO17 
 0BD4                        C  $VPOPF:			;POP EITHER 4 OR 8 BYTES OFF THE STAC
				K 
 0BD4  E8 08EE R             C  	CALL	$GETYP		;SET CODES ACCORDING TO $VALTP 
 0BD7  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 0BDA  B9 0004               C  	MOV	CX,4 
 0BDD  73 06                 C  	JNB	VPO17		;JUMP IF DOUBLE PRECISION 
 0BDF  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
 0BE2  B9 0002               C  	MOV	CX,2 
 0BE5  58                    C  VPO17:	POP	AX		;GET RETURN ADDRESS OFF STACK 
 0BE6  8F 05                 C  VPO20:	POP	WORD PTR 0[DI] 
 0BE8  47                    C  	INC	DI 
 0BE9  47                    C  	INC	DI 
 0BEA  E2 FA                 C  	LOOP	VPO20 
 0BEC  50                    C  	PUSH	AX		;PUSH RETURN ADDRESS ON STACK 
 0BED  C3                    C  	RET 
 0BEE                        C  VINT: 
 0BEE                        C  $VINT:				;DO INT ACCORDING TO TYPE (SINGLE OR 
				DOUBLE PRECISION) 
 0BEE  E8 08EE R             C  	CALL	$GETYP		;SET CODES ACCORDING TO TYPE 
 0BF1  79 01                 C  	JNS	VIN05 
 0BF3  C3                    C  	RET			;RETURN IF INTEGER ALREADY 
 0BF4                        C  VIN05: 
 0BF4  72 03                 C  	JB	VIN10		;JUMP IF SINGLE PRECISION 
 0BF6  E9 1B65 R             C  	JMP	$DINT		;GO DO DOUBLE PRECISION 
 0BF9  E9 1BD4 R             C  VIN10:	JMP	$INT 
                             C   
                             C  	SUBTTL	 $FIN	 NUMERIC INPUT ROUTINE 
                             C  ;**********************************************
				****************** 
                             C  ; 
                             C  ;       $FIN    GIVEN A TEXT POINTER, $FIN WILL
				 BUILD AN INPUT 
                             C  ;               NUMBER IN THE FAC. AS NECESSARY
				 (OR IF FORCED) 
                             C  ;               $FIN WILL GO TO NEXT HIERARCHY 
				OF NUMBERS 
                             C  ;               I.E. TRANSITIONS FROM INTEGER-S
				INGLE PRECISION- 
                             C  ;               DOUBLE PRECISION CAN EITHER BE 
				FORCED OR DICTATED 
                             C  ;               BY THE INPUT NUMBERS. 
                             C  ;       CALLING         SEQUENCE:       CALL   
				 $FIN 
                             C  ;               WITH (BX) POINTING TO TEXT CONT
				AINING THE NUMBER 
                             C  ;               TO BE CONVERTED FROM ASCII. 
                             C  ; 
                             C  ;**********************************************
				******************** 
                             C   
                             C   
                             C   
 0BFC                        C  FIN: 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-58
$FIN	 NUMERIC INPUT ROUTINE                                 

 0BFC  32 C0                 C  $FIN:	XOR	AL,AL		;LET INPUT NUMBER DETERMINE TY
				PE 
 0BFE  EB 07                 C  	JMP	SHORT FN20 
 0C00                        C  FINDBL: 
 0C00                        C  $FINDB:			;FORCE DOUBLE PRECISION ENTRY POINT 
 0C00  B0 01                 C  	MOV	AL,LOW 1	;FLAG TO INDICATE D.P. 
 0C02  C6 06 0000 E 08       C  	MOV	BYTE PTR $VALTP,LOW 10	;SET TO DOUBLE PREC
				ISION 
 0C07                        C  FN20: 
 0C07  C6 06 0000 E 01       C  	MOV	BYTE PTR $FLGOV,LOW 1	;SET ONCE-ONLY OVERF
				LOW MODE 
 0C0C  BE 0000 E             C  	MOV	SI,OFFSET $FLGOC	;ADDRESS OF INPUT OVERFLO
				W CODE 
 0C0F  56                    C  	PUSH	SI		;PUSH ON STACK SO RETURN IS HERE 
 0C10  33 FF                 C  	XOR	DI,DI		;DIGITS PAST DECIMAL POINT 
 0C12  8B CF                 C  	MOV	CX,DI		;DECIMAL POINT FLAG 
 0C14  8B F7                 C  	MOV	SI,DI		;(SI) WILL FLAG POS/NEG EXPONENT 
 0C16  F7 D1                 C  	NOT	CX		;SET ALL BITS 
 0C18  50                    C  	PUSH	AX 
 0C19  E8 08B4 R             C  	CALL	$ZERO		;(FAC)=0 
 0C1C  58                    C  	POP	AX 
 0C1D  0A C0                 C  	OR	AL,AL		;MUST SEE IF $VALTP SHOULD START AT 
 0C1F  75 05                 C  	JNZ	FN30		;INTEGER OR NOT. 
 0C21  C6 06 0000 E 02       C  	MOV	BYTE PTR $VALTP,LOW 2	;SET TO INTEGER 
 0C26  8A 07                 C  FN30:	MOV	AL,BYTE PTR 0[BX]	;FETCH 1ST CHARACTE
				R FROM TEXT 
 0C28  3C 26                 C  	CMP	AL,LOW "&"      ;SIGNIFIES SPECIAL INPUT N
				O. 
 0C2A  75 03                 C  	JNZ	FN40		;IF NOT, PROCEED 
 0C2C  E9 0000 E             C  	JMP	$OHCNS		;OTHERWISE GO PROCESS OCT. OR HEX 
 0C2F  3C 2D                 C  FN40:	CMP	AL,LOW "-"      ;NEGATIVE NUMBER? 
 0C31  9C                    C  	PUSHF			;WILL SAVE ZF FOR POSSIBLE NEGATION 
 0C32  74 05                 C  	JZ	FN50		;ONCE NUMBER IS FORMED POSITIVE 
 0C34  3C 2B                 C  	CMP	AL,LOW "+"      ;NEED TO ADVANCE TEXT POIN
				TER FOR 
 0C36  74 01                 C  	JZ	FN50		;LEADING SIGN 
 0C38  4B                    C  	DEC	BX		; 
 0C39  E8 0E5B R             C  FN50:	CALL	$CHRGT		;GET NEXT CHARACTER OF NUMBE
				R 
 0C3C  73 05                 C  	JNB	FN60		;IF NOT DIGIT GO EXAMINE FURTHER 
 0C3E  E8 16B2 R             C  FN55:	CALL	$FIDIG		;MUL FAC BY TEN AND ADD IN T
				HE DIGIT 
 0C41  EB F6                 C  	JMP	SHORT FN50 
 0C43                        C  FN60: 
 0C43  BD 04D2 R             C  	MOV	BP,OFFSET $FINCH+7 
 0C46  33 D2                 C  	XOR	DX,DX		;MUST SET EXPONENT TO ZERO 
 0C48  8B F2                 C  	MOV	SI,DX		;FOR SUBSEQUENT CALL TO FINE 
 0C4A                        C  FN70: 
 0C4A  2E: 3A 46 00          C  	CMP	AL,BYTE PTR CS:0[BP]	;CODE SEGMENT 
 0C4E  74 09                 C  	JZ	FN80		;FOUND SPEC CH (.,D,D+40,!,#,%,E,E+40
				) 
 0C50  81 FD 04CB R          C  	CMP	BP,OFFSET $FINCH	;IF EQUAL NONE OF THE SPE
				CIAL CHARS. 
 0C54  74 23                 C  	JZ	FN96		;GO FNISH UP NUMBER NON-RECOG. CHAR. 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-59
$FIN	 NUMERIC INPUT ROUTINE                                 

 0C56  4D                    C  	DEC	BP		;PROCEED TO NEXT CHARACTER 
 0C57  EB F1                 C  	JMP	SHORT FN70	;IF NOT FNISHED LOOK AT NEXT CH
				AR. 
 0C59  81 ED 04CB R          C  FN80:	SUB	BP,OFFSET $FINCH	; 
 0C5D  D1 E5                 C  	SHL	BP,1		; BRANCH TABLE ENTRIES 2 BYTES EA 
 0C5F                        C  FN90: 
                             C  				;CODE SEGMENT OVERRIDE PREFIX 
 0C5F  2E: FF A6 0C64 R      C  	JMP	 WORD PTR CS:FN95[BP] 
 0C64                        C  FN95  LABEL WORD 
 0C64  0C7E R                C  	DW	OFFSET FN100 
 0C66  0C91 R                C  	DW	OFFSET FN200 
 0C68  0C91 R                C  	DW	OFFSET FN200 
 0C6A  0C98 R                C  	DW	OFFSET FN400 
 0C6C  0C9B R                C  	DW	OFFSET FN500 
 0C6E  0CA0 R                C  	DW	OFFSET FN600 
 0C70  0C74 R                C  	DW	OFFSET FN92 
 0C72  0C74 R                C  	DW	OFFSET FN92 
 0C74                        C  FN92:				;IT WAS A "D" 
 0C74  32 C0                 C  	XOR	AL,AL		;SET CONDITION CODES CORRECTLY 
 0C76  E8 172B R             C  FN94:	CALL	$FINEX		;CALCULATE EXPONENT 
 0C79  E8 0704 R             C  FN96:	CALL	$FINE		;MODIFY NUMBER TO REFLECT EXP
				ONENT 
 0C7C  EB 27                 C  	JMP	SHORT FINF	;CLEAN UP, NEGATE AS NECESSARY 
 0C7E                        C  FN100:				;IT WAS A "." 
 0C7E  41                    C  	INC	CX		;TO DENOTE DECIMAL POINT DETECTED 
 0C7F  75 F8                 C  	JNZ	FN96		;GO FINISH UP NO.-2ED DECIMAL PT. SE
				EN! 
 0C81  E8 08EE R             C  	CALL	$GETYP		;IF SNG OR DOUBLE JUST RETURN 
 0C84  79 B3                 C  	JNS	FN50 
 0C86  51                    C  	PUSH	CX 
 0C87  53                    C  	PUSH	BX 
 0C88  57                    C  	PUSH	DI 
 0C89  E8 17E5 R             C  	CALL	$CSI		;CONVERT TO SINGLE PRECISION 
 0C8C  5F                    C  	POP	DI 
 0C8D  5B                    C  	POP	BX 
 0C8E  59                    C  	POP	CX 
 0C8F  EB A8                 C  	JMP	FN50		;GO PROCESS NEXT CHAR. 
 0C91                        C  FN200:				;IT WAS AN "E" OR  "E"+40 (LOWER CASE
				 E) 
 0C91  E8 1254 R             C  	CALL	$CHKEL		;MAKE SURE WE DON'T HAVE AN "ELSE
				" 
 0C94  74 E3                 C  	JZ	FN96		;IT WAS AN "ELSE" OR "EQV" 
 0C96  EB DE                 C  	JMP	SHORT FN94	;GO DETERMINE EXPONENT 
 0C98                        C  FN400:				;IT WAS A "%" (INTEGER) 
 0C98  43                    C  	INC	BX		;Eat the percent sign. 
 0C99  EB DE                 C  	JMP	SHORT FN96	;Call $FINE since could be work
				ing 
                             C  				;on a floating point. 
                             C   
 0C9B                        C  FN500:				;IT WAS A "#" (DOUBLE PRECISION) 
 0C9B  E8 1776 R             C  	CALL	$FIND 
 0C9E  EB 05                 C  	JMP	SHORT FINF	;GO FINISH UP 
 0CA0                        C  FN600:				;IT WAS A "!"    (SINGLE PRECISION) 
 0CA0  32 C0                 C  	XOR	AL,AL		;FLAG AS SINGLE 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-60
$FIN	 NUMERIC INPUT ROUTINE                                 

 0CA2  E8 1778 R             C  	CALL	$FINS		;FORCE TO SINGLE PRECISION 
 0CA5  9D                    C  FINF:	POPF			;RECALL SIGN FLAG 
 0CA6  75 0D                 C  	JNZ	FN990		;RETURN IF NOT NEGATIVE NO. 
 0CA8  E8 0B1F R             C  	CALL	$VNEG		;NEGATE NUMBER 
 0CAB  E8 08EE R             C  	CALL	$GETYP		;SET CONDITION CODES ACCORDING TO
				 TYPE 
 0CAE  7A 05                 C  	JPE	FN990		;IF NOT SINGLE PRECISION RETURN 
 0CB0  53                    C  	PUSH	BX		;SAVE TEXT POINTER 
 0CB1  E8 0AEA R             C  	CALL	$CONI2		;CHECK FOR -32768 AND CONVERT TO 
				INT. 
 0CB4  5B                    C  	POP	BX		;RECALL TEXT POINTER 
                             C  				;IF FOUND 
 0CB5  C3                    C  FN990:	RET 
                             C   
                             C  	SUBTTL	 $FPWR/$SQR	 INVOLUTION/SQUARE RT. OF S
				INGLE PRECISION NOS. 
                             C  ;**********************************************
				************* 
                             C  ; 
                             C  ;       $FPWR   CALCULATES X^Y BY X^Y=EXP(Y*LOG
				(X)) 
                             C  ; 
                             C  ;       CALLING SEQUENCE:       CALL    $FPWR 
                             C  ;               WITH Y IN THE $FAC, X IN (BXDX)
				 
                             C  ;       $SQR    ENTRY POINT TO PROVIDE SQUARE R
				OOT FUNCTION 
                             C  ;       CALLING SEQUENCE:       CALL    $SQR 
                             C  ;               WITH ARGUMENT IN $FAC 
                             C  ; 
                             C  ;**********************************************
				************** 
                             C   
                             C  ;SQUARE ROOT FUNCTION (FAC)=SQR(FAC) 
 0CB6                        C  SQR: 
 0CB6                        C  $SQR: 
 0CB6  8B 16 FFFE E          C  	MOV	DX,WORD PTR $FAC-2 
 0CBA  0A F6                 C  	OR	DH,DH		;Test sign bit 
 0CBC  78 68                 C  	JS	NEGNUM 
 0CBE  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC	;Get exponent 
 0CC1  0A C0                 C  	OR	AL,AL 
 0CC3  74 60                 C  	JZ	DONE		;SQR(0)=0 
 0CC5  8A 3E FFFD E          C  	MOV	BH,BYTE PTR $FAC-3 
 0CC9  B3 00                 C  	MOV	BL,LOW 0 
 0CCB  80 CE 80              C  	OR	DH,LOW 128D	;Set implied bit 
 0CCE  D0 E8                 C  	SHR	AL,1		;Divide exponent by two 
 0CD0  73 05                 C  	JNB	EVENEX		; 
 0CD2  D1 EA                 C  	SHR	DX,1		;HALF MANTISSA IF EXP ODD 
 0CD4  D1 DB                 C  	RCR	BX,1 
 0CD6  F9                    C  	STC			;RESTORE CARRY FOR ROUND UP 
 0CD7                        C  EVENEX: 
 0CD7  14 40                 C  	ADC	AL,LOW 100O	;ADD BACK 1/2 OF BIAS 
 0CD9  A2 0000 E             C  	MOV	BYTE PTR $FAC,AL	;SAVE FINAL EXPONENT 
 0CDC  B9 0019               C  	MOV	CX,25D		;24 BITS PLUS 1 FOR ROUNDING 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-61
$FPWR/$SQR	 INVOLUTION/SQUARE RT. OF SINGLE PRECISION NOS.  

 0CDF  33 ED                 C  	XOR	BP,BP		;CLEAR SOME REGISTERS 
 0CE1  8B F5                 C  	MOV	SI,BP 
 0CE3  8B FD                 C  	MOV	DI,BP 
 0CE5  8B C5                 C  	MOV	AX,BP 
 0CE7                        C  RTLP: 
 0CE7  D1 E3                 C  	SHL	BX,1		;64 BIT LEFT SHIFT OF INPUT 
 0CE9  D1 D2                 C  	RCL	DX,1 
 0CEB  D1 D7                 C  	RCL	DI,1 
 0CED  D1 D5                 C  	RCL	BP,1 
 0CEF  D1 E3                 C  	SHL	BX,1		;SHIFT IT TWICE 
 0CF1  D1 D2                 C  	RCL	DX,1 
 0CF3  D1 D7                 C  	RCL	DI,1 
 0CF5  D1 D5                 C  	RCL	BP,1 
 0CF7  F9                    C  	STC			;ROTATE IN TEST BIT 
 0CF8  D1 D6                 C  	RCL	SI,1		;32-BIT SHIFT OF PARTIAL RESULT 
 0CFA  D1 D0                 C  	RCL	AX,1 
 0CFC  2B FE                 C  	SUB	DI,SI		;TRY TEST BIT 
 0CFE  1B E8                 C  	SBB	BP,AX 
 0D00  73 09                 C  	JNB	ROOTBT		;JUMP OUT IF IT FIT 
 0D02  03 FE                 C  	ADD	DI,SI		;RESTORE IF IT DIDN'T 
 0D04  13 E8                 C  	ADC	BP,AX 
 0D06  4E                    C  	DEC	SI 
 0D07  E2 DE                 C  	LOOP	RTLP 
 0D09  EB 03                 C  	JMP	SHORT FPWRND 
 0D0B                        C  ROOTBT: 
 0D0B  46                    C  	INC	SI		;HERE IF TEST BIT FIT 
 0D0C  E2 D9                 C  	LOOP	RTLP		;SET REAL RESULT BIT AND CONTINUE 
 0D0E                        C  FPWRND: 
 0D0E  D1 E8                 C  	SHR	AX,1		;HALF TO A 25-BIT RESULT 
 0D10  D1 DE                 C  	RCR	SI,1 
 0D12  D1 E8                 C  	SHR	AX,1		;TO A 24-BIT RESULT 
 0D14  D1 DE                 C  	RCR	SI,1 
 0D16  83 D6 00              C  	ADC	SI,0		;ROUND IF A 1 SHIFTED OUT 
 0D19  15 0000               C  	ADC	AX,0		;AND PROPAGATE CARRY 
 0D1C  89 36 FFFD E          C  	MOV	WORD PTR $FAC-3,SI	;STORE RESULT 
 0D20  24 7F                 C  	AND	AL,LOW 177O	;CLEAR SIGN BIT 
 0D22  A2 FFFF E             C  	MOV	BYTE PTR $FAC-1,AL	;AND STORE 
 0D25  C3                    C  DONE:	RET 
                             C   
 0D26  E9 0000 E             C  NEGNUM: JMP	$FCERR 
                             C   
 0D29                        C  $FPWR:				;INVOLUTION ($FAC):=(BXDX)^($FAC) 
                             C  				;OR         (FAC)=X^Y 
 0D29  BF 0000 E             C  	MOV	DI,OFFSET $CLROV 
 0D2C  57                    C  	PUSH	DI 
 0D2D  BF 0000 E             C  	MOV	DI,OFFSET $FLGOV 
 0D30  C6 05 01              C  	MOV	BYTE PTR 0[DI],LOW 1	;ONCE-ONLY OVERFLOW M
				ODE 
 0D33  E8 08BE R             C  	CALL	$SIGNS		;SEE IF Y IS ZERO 
 0D36  75 03                 C  	JNZ	FP10 
 0D38  E9 1268 R             C  	JMP	$EXP		;ANS IS 1 IF Y=0 
 0D3B  79 07                 C  FP10:	JNS	FP20		;IF NEGATIVE POTENTIAL OVERFLOW
				 
 0D3D  0A FF                 C  	OR	BH,BH		;IF X IS ZERO 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-62
$FPWR/$SQR	 INVOLUTION/SQUARE RT. OF SINGLE PRECISION NOS.  

 0D3F  75 0A                 C  	JNZ	FP25 
 0D41  E9 0786 R             C  	JMP	$DIV0S		;DIVIDE-BY-ZERO CODE 
 0D44  0A FF                 C  FP20:	OR	BH,BH		;SEE IF ZERO TO POWER 
 0D46  75 03                 C  	JNZ	FP25 
 0D48  E9 08B4 R             C  	JMP	$ZERO		;ANS IS ZERO 
 0D4B                        C  FP25:				;WE KNOW AT THIS POINT THAT X IS NON-Z
				ERO. IF X IS NEGATIVE 
                             C  				;THEN Y MUST BE AN INTEGRAL POWER OR WE HAV
				E A FUNCTION 
                             C  				;CALL ERROR 
 0D4B  0A DB                 C  	OR	BL,BL		;IS X NEGATIVE? 
 0D4D  79 26                 C  	JNS	FP30		;IF NOT PROCEED 
 0D4F  80 3E 0000 E 99       C  	CMP	BYTE PTR $FAC,LOW 231	;SEE IF Y TOO LARGE 
				TO DETERMINE SIGN 
                             C  				;OF INVOLUTION RESULT 
 0D54  72 03                 C  	JB	FP27		;JUMP IF OK TO COMPUTE 
 0D56  E9 0000 E             C  	JMP	$FCERR 
 0D59                        C  FP27: 
 0D59  52                    C  	PUSH	DX		;SAVE X ON THE STACK 
 0D5A  53                    C  	PUSH	BX 
 0D5B  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO ;PUSH Y ON THE STACK 
 0D5F  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 
 0D63  E8 1BD4 R             C  	CALL	$INT		;MAKE Y AN INTEGER 
 0D66  5B                    C  	POP	BX		;Y TO THE REGISTERS 
 0D67  5A                    C  	POP	DX 
 0D68  E8 0A40 R             C  	CALL	$FCOMP		;SEE IF Y IS AN INTEGER 
 0D6B  E8 0A05 R             C  	CALL	$MOVFR		;MOVE ORIGINAL Y BACK TO FAC 
 0D6E  5B                    C  	POP	BX		;RECALL X 
 0D6F  5A                    C  	POP	DX 
 0D70  74 03                 C  	JZ	FP30		;PROCEED IF Y IS AN INTEGER 
 0D72  E9 0000 E             C  	JMP	$FCERR		;OTHERWISE WE HAVE FCN CALL ERROR 
 0D75  A0 FFFF E             C  FP30:	MOV	AL,BYTE PTR $FAC-1	;NEED TO KNOW IF Y
				 IS NEGATIVE 
 0D78  0A C0                 C  	OR	AL,AL 
 0D7A  79 3D                 C  	JNS	FP30A		;Y POSITIVE 
 0D7C  24 7F                 C  	AND	AL,LOW 177	;Y is negative - will invert wh
				en 
 0D7E  A2 FFFF E             C  	MOV	BYTE PTR $FAC-1,AL	;finished.  Clear the s
				ign bit of Y. 
 0D81  53                    C  	PUSH	BX		;Save the sign of X. 
 0D82  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 ;Save Y. 
 0D86  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 0D8A  E8 0DB9 R             C  	CALL	FP30A		;FAC:=X^positive Y. 
 0D8D  F6 06 0000 E FF       C  	TEST	BYTE PTR $FAC,LOW 377O	;Did it underflow?
				 
 0D92  75 19                 C  	JNZ	INVERT		;No, go invert it. 
 0D94  8F 06 0000 E          C  	POP	WORD PTR $FACLO ;Yes, pop Y into the FAC. 
 0D98  8F 06 0000 E          C  	POP	WORD PTR $FACM1 
 0D9C  E8 1C37 R             C  	CALL	$QINT		;Get least significant byte of Y 
                             C  				;into DL. 
 0D9F  5B                    C  	POP	BX		;Get sign of X into BL bit 7. 
 0DA0  D0 CA                 C  	ROR	DL,1		;Set sign bit of FAC if X is negativ
				e 
 0DA2  22 DA                 C  	AND	BL,DL		;and Y is odd. 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-63
$FPWR/$SQR	 INVOLUTION/SQUARE RT. OF SINGLE PRECISION NOS.  

 0DA4  88 1E 0001 E          C  	MOV	BYTE PTR $FAC+1,BL 
 0DA8  B7 FF                 C  	MOV	BH,LOW 377O	;Make BH nonzero for DOINF rou
				tine 
                             C  				;(which is called by $OVFLS) so it uses 
                             C  				;$FAC+1 to determine the sign of the 
                             C  				;inifinity to use. 
 0DAA  E9 0775 R             C  	JMP	$OVFLS		;Give Overflow error with and retu
				rn 
                             C  				;appropriate (negative or positive) 
                             C  				;inifinity based on the sign just 
                             C  				;put into the FAC. 
                             C   
 0DAD  83 C4 06              C  INVERT: ADD	SP,6		;Pop off the garbage. 
 0DB0  BA 0000               C  	MOV	DX,0		;BXDX:=1.0. 
 0DB3  BB 8100               C  	MOV	BX,100400 
 0DB6  E9 15D6 R             C  	JMP	$FDIVS		;Invert the result and return. 
                             C   
 0DB9                        C  FP30A: 
 0DB9  53                    C  	PUSH	BX		;SAVE X ON THE STACK 
 0DBA  52                    C  	PUSH	DX 
 0DBB  80 CB 7F              C  	OR	BL,LOW 177	;SET CODES TO REFLECT SIGNS OF X
				 
 0DBE  9C                    C  	PUSHF			;SAVE X POS/NEG INFORMATION 
 0DBF  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 ;PUSH Y ON THE STACK 
 0DC3  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 0DC7  E8 1BD4 R             C  	CALL	$INT		;MUST DETERMINE IF Y IS AN INTEGER 
 0DCA  5A                    C  	POP	DX		;RECALL ORIGINAL Y 
 0DCB  5B                    C  	POP	BX 
 0DCC  E8 0A40 R             C  	CALL	$FCOMP		;ZF=1 IF Y IS AN INTEGER 
 0DCF  75 15                 C  	JNZ	FP34		;IF NOT INTEGER PROCEED AS NORMAL 
 0DD1  52                    C  	PUSH	DX		;SAVE Y 
 0DD2  53                    C  	PUSH	BX 
 0DD3  BA 0000               C  	MOV	DX,0		;WILL MAKE (BXDX) 32768. 
 0DD6  BB 9000               C  	MOV	BX,110000 
 0DD9  E8 0A40 R             C  	CALL	$FCOMP		;SEE IF TOO LARGE 
 0DDC  5B                    C  	POP	BX		;RECALL Y 
 0DDD  5A                    C  	POP	DX 
 0DDE  79 06                 C  	JNS	FP34		;AND IF SO COMPUTE WITH LOG & EXP 
 0DE0  9D                    C  	POPF			;GET X POS/NEG INFO OFF STACK 
 0DE1  5A                    C  	POP	DX		;GET X TO REGISTERS 
 0DE2  5B                    C  	POP	BX 
 0DE3  EB 34 90              C  	JMP	XTON		;AND COMPUTE X^N 
                             C   
 0DE6  9D                    C  FP34:	POPF			;GET X POS/NEG INFORMATION 
 0DE7  79 0E                 C  	JNS	FP40		;NO PROBS IF X IS POSITIVE 
 0DE9  53                    C  	PUSH	BX		;SAVE Y ON THE STACK 
 0DEA  52                    C  	PUSH	DX 
 0DEB  E8 1C37 R             C  	CALL	$QINT		;NEED EVEN-ODD INFORMATION 
 0DEE  8A C2                 C  	MOV	AL,DL		;GET LOW BYTE OF INTEGER 
 0DF0  E8 1CE4 R             C  	CALL	$NORMS		;($FAC)=INT(Y) 
 0DF3  5A                    C  	POP	DX		;RECALL Y 
 0DF4  5B                    C  	POP	BX 
 0DF5  D0 D8                 C  	RCR	AL,1		;CF=1 IF ODD 
 0DF7  8F 06 0000 E          C  FP40:	POP	WORD PTR $FACLO ;GET X TO FAC 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-64
$FPWR/$SQR	 INVOLUTION/SQUARE RT. OF SINGLE PRECISION NOS.  

 0DFB  8F 06 0002 E          C  	POP	WORD PTR $FACLO+2 
 0DFF  9F                    C  	LAHF			;SAVE EVEN/ODD INFO 
 0E00  80 26 0000 E 7F       C  	AND	BYTE PTR $FACM1,LOW 177 ;CLEAR ANY SIGN BI
				T 
 0E05  9E                    C  	SAHF			;GET EVEN/ODD INFO 
 0E06  73 04                 C  	JNB	FP60 
 0E08  BF 0B24 R             C  	MOV	DI,OFFSET $NEG 
 0E0B  57                    C  	PUSH	DI		;WILL NEGATE AT THE END IF CF=1 
 0E0C  53                    C  FP60:	PUSH	BX		;SAVE Y AGAIN 
 0E0D  52                    C  	PUSH	DX 
 0E0E  E8 1C40 R             C  	CALL	$LOG		;LOG(X) 
 0E11  5A                    C  	POP	DX		;RECALL Y 
 0E12  5B                    C  	POP	BX 
 0E13  E8 191D R             C  	CALL	$FMULS		;($FAC)=Y*LOG(X) 
 0E16  E9 1268 R             C  	JMP	$EXP		;COMPLETE CALCULATION 
                             C  ;**********************************************
				**************** 
                             C  ;       ($FAC)=($FAC)^(BXDX) 
                             C  ;WHERE (BXDX) IS AN INTEGER SUCH THAT 0.LT.(BXD
				X).LE.32767 
                             C  ; 
                             C  ;OR AS IN KNUTH X**N IS AS FOLLOWS 
                             C  ;THE ALGORITHM IS TAKEN FROM KNUTH VOL2 P400 
                             C  ;A1.Y=1, Z=X 
                             C  ;A2.HALVE N AND DETERMINE IF N WAS EVEN OR ODD.
				 IF N WAS EVEN 
                             C  ;   THEN JUMP TO A4. 
                             C  ;A3.Y=Y*Z 
                             C  ;A4.IF N = 0 FINISHED WITH Y THE ANSWER 
                             C  ;A5.Z=Z*Z AND RETURN TO A2 
                             C  ;**********************************************
				***************** 
 0E19                        C  XTON:				;($FAC):=(BXDX)^($FAC) 
 0E19  53                    C  	PUSH	BX		;SAVE X ON STACK 
 0E1A  52                    C  	PUSH	DX 
 0E1B  E8 1C37 R             C  	CALL	$QINT		;CONVERT TO INTEGER 
 0E1E  89 16 0000 E          C  	MOV	WORD PTR $ARG,DX	;N TO $ARG 
 0E22  C7 06 0000 E 0000     C  	MOV	WORD PTR $FACLO,0	;WILL MOVE 1.0 TO FAC 
 0E28  C7 06 0000 E 8100     C  	MOV	WORD PTR $FACM1,100400	; 
 0E2E  D1 2E 0000 E          C  XTON10: SHR	WORD PTR $ARG,1 ;SHIFT RIGHT 1 BIT 
 0E32  73 07                 C  	JNB	XTON20		;IF NO MULTIPLY THEN Z=Z**2 
 0E34  5A                    C  	POP	DX		;FETCH Z 
 0E35  5B                    C  	POP	BX 
 0E36  53                    C  	PUSH	BX		;AND PUT IT BACK ON STACK 
 0E37  52                    C  	PUSH	DX 
 0E38  E8 191D R             C  	CALL	$FMULS		;Y=Y*Z 
 0E3B  F7 06 0000 E FFFF     C  XTON20: TEST	WORD PTR $ARG,177777	;SEE IF N HAS
				 GONE TO ZERO 
 0E41  74 15                 C  	JZ	XTON30		;GET OUT IF FINISHED 
 0E43  5A                    C  	POP	DX		;FETCH Z TO REGISTERS 
 0E44  5B                    C  	POP	BX 
 0E45  E8 0BBD R             C  	CALL	$PUSHF		;Y TO STACK 
 0E48  E8 0A05 R             C  	CALL	$MOVFR		;Z TO FAC 
 0E4B  E8 191D R             C  	CALL	$FMULS		;Z=Z*Z 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-65
$FPWR/$SQR	 INVOLUTION/SQUARE RT. OF SINGLE PRECISION NOS.  

 0E4E  5A                    C  	POP	DX		;FETCH Y 
 0E4F  5B                    C  	POP	BX 
 0E50  E8 0BBD R             C  	CALL	$PUSHF		;NEW Z TO STACK 
 0E53  E8 0A05 R             C  	CALL	$MOVFR		;Y TO FAC 
 0E56  EB D6                 C  	JMP	SHORT XTON10	;TRY AGAIN 
 0E58  5A                    C  XTON30: POP	DX		;GET STACK CLEAR OF Z 
 0E59  5B                    C  	POP	BX 
 0E5A  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 F4  MAP BETWEEN 8080-8086 CONVERTED F3
				 TO 8086 MATHPK 
                             C   
                             C   
                             C   
 0E5B  E9 0000 E             C  $CHRGT: JMP	CHRGTR 
 0E5E                        C  DSUB: 
 0E5E  80 36 FFFF E 80       C  	XOR	BYTE PTR $FAC-1,LOW 200 ;WILL FLIP SIGNS O
				F EACH ARGUMENT 
 0E63  80 36 FFFF E 80       C  	XOR	BYTE PTR $ARG-1,LOW 200 
 0E68  E9 12D7 R             C  	JMP	$FSUBD 
 0E6B                        C  FADD: 
 0E6B  87 D9                 C  	XCHG	BX,CX 
 0E6D  E9 139F R             C  	JMP	$FADDS 
 0E70                        C  FSUB: 
 0E70  87 D9                 C  	XCHG	BX,CX 
 0E72  E9 1393 R             C  	JMP	$FSUBS 
 0E75  87 D9                 C  FDIV:	XCHG	BX,CX 
 0E77  E9 15D6 R             C  	JMP	$FDIVS 
 0E7A                        C  CONSIH: 
 0E7A  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX 
 0E7E  E9 17E5 R             C  	JMP	$CSI 
 0E81                        C  FLOAT: 
 0E81  52                    C  	PUSH	DX 
 0E82  98                    C  	CBW 
 0E83  8B D0                 C  	MOV	DX,AX 
 0E85  E8 184E R             C  	CALL	$FLT 
 0E88  5A                    C  	POP	DX 
 0E89  C3                    C  	RET 
 0E8A                        C  FMULT: 
 0E8A  87 D9                 C  	XCHG	BX,CX 
 0E8C  E9 191D R             C  	JMP	$FMULS 
 0E8F                        C  FPWR: 
 0E8F  87 D9                 C  	XCHG	BX,CX 
 0E91  E9 0D29 R             C  	JMP	$FPWR 
                             C   
                             C  ;**********************************************
				*************** 
                             C  ;INTEGER ARITHMETIC FOLLOWS 
                             C  ;**********************************************
				*************** 
 0E94                        C  ISUB:				;(BX)=(DX)-(BX) 
 0E94  81 FB 8000            C  	CMP	BX,100000	;CHECK FOR -32768 
 0E98  75 11                 C  	JNZ	IS10		;PROCEED IF NOT 
 0E9A  E8 184E R             C  	CALL	$FLT		;FLOAT DX 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-66
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 0E9D  33 D2                 C  	XOR	DX,DX		;WILL SET (BXDX)=-32768.0 
 0E9F  BB 9080               C  	MOV	BX,110200 
 0EA2  E8 1393 R             C  	CALL	$FSUBS		;DO SUBTRACT 
 0EA5  E8 0B24 R             C  	CALL	$NEG		;NEGATE 
 0EA8  E9 17F1 R             C  	JMP	$FI 
 0EAB                        C  IS10: 
 0EAB  F7 DB                 C  	NEG	BX		;NEGATE AND FALL INTO ADD 
                             C   
 0EAD                        C  IADD:				;(BX)=(DX)+(BX) 
 0EAD  53                    C  	PUSH	BX		;SAVE 1ST ARG 
 0EAE  03 DA                 C  	ADD	BX,DX 
 0EB0  70 04                 C  	JO	IAD10		;IF OVERFLOW JUMP 
 0EB2  58                    C  	POP	AX		;CLEAR STACK 
 0EB3  E9 105E R             C  	JMP	MAKINT 
 0EB6                        C  IAD10: 
 0EB6  E8 184E R             C  	CALL	$FLT		;FLOAT 2ED ARG 
 0EB9  5A                    C  	POP	DX		;RECALL FIRST ARG 
 0EBA  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 0EBE  FF 36 FFFF E          C  	PUSH	WORD PTR $FAC-1 ;FAC PUSHED ON THE STACK 
 0EC2  E8 184E R             C  	CALL	$FLT		;FLOAT 2ED ARG 
 0EC5  5B                    C  	POP	BX 
 0EC6  5A                    C  	POP	DX		;GET 2ED ARG TO (BXDX) 
 0EC7  E9 139F R             C  	JMP	$FADDS		;GO ADD FLOATING 
                             C   
 0ECA                        C  IMULT:				;(BX)=(BX)*(DX) 
 0ECA  8B C3                 C  	MOV	AX,BX 
 0ECC  52                    C  	PUSH	DX		;SAVE 2ED ARG 
 0ECD  F7 EA                 C  	IMUL	DX		;PERFORM MULTIPLICATION 
 0ECF  5A                    C  	POP	DX		;RECALL 2ED ARG 
 0ED0  72 05                 C  	JB	IM10		;MUST FLOAT ARGS IF CF=1 
 0ED2  8B D8                 C  	MOV	BX,AX 
 0ED4  E9 105E R             C  	JMP	MAKINT 
 0ED7                        C  IM10: 
 0ED7  53                    C  	PUSH	BX		;SAVE FIRST ARG 
 0ED8  E8 184E R             C  	CALL	$FLT		;FLOAT 2ED ARG 
 0EDB  5A                    C  	POP	DX		;RECALL 1ST ARG 
 0EDC  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 0EE0  FF 36 FFFF E          C  	PUSH	WORD PTR $FAC-1 
 0EE4  E8 184E R             C  	CALL	$FLT		;FLOAT 1ST ARG 
 0EE7  5B                    C  	POP	BX 
 0EE8  5A                    C  	POP	DX		;GET 2ED ARG TO (BXDX) 
 0EE9  E9 191D R             C  	JMP	$FMULS		;GO MULTIPLY FLOATING 
                             C   
 0EEC                        C  IDIV:				;(BX)=(DX)/(BX) 
 0EEC  0B DB                 C  	OR	BX,BX		;MAKE SURE ITS NON-ZERO 
 0EEE  75 0E                 C  	JNZ	IDIV10 
 0EF0  88 36 0001 E          C  	MOV	BYTE PTR $FAC+1,DH	;FOR CORRECT SIGN 
 0EF4  FE C7                 C  	INC	BH		; Hack for DOINF to work 
 0EF6  C6 06 0000 E 04       C  	MOV	BYTE PTR $VALTP,LOW 4 
 0EFB  E9 0786 R             C  	JMP	$DIV0S 
 0EFE                        C  IDIV10: 
 0EFE  81 FA 8000            C  	CMP	DX,100000	;CHECK FOR -32768 
 0F02  75 16                 C  	JNZ	IDIV15		;PROCEED IF NOT 
 0F04  83 FB FF              C  	CMP	BX,177777	;Check for special case of -3276
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-67
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

				8\-1 
 0F07  75 07                 C  	JNE	IDIV11 
 0F09  E8 184E R             C  	CALL	$FLT		;FLOAT DX 
 0F0C  E8 0B24 R             C  	CALL	$NEG 
 0F0F  C3                    C  	RET 
 0F10                        C  IDIV11: 
 0F10  83 FB 01              C  	CMP	BX,1		;Other special case 
 0F13  75 05                 C  	JNE	IDIV15 
 0F15  8B DA                 C  	MOV	BX,DX		;Put -32768\1 = -32768 in BX so we 
				can ... 
 0F17  E9 105E R             C  	JMP	MAKINT		;Return it as an Int. (IDIV doesn'
				t work) 
 0F1A                        C  IDIV15: 
 0F1A  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX	;WILL PERFORM (DX:AX)/(
				FAC) 
 0F1E  B8 0000               C  	MOV	AX,0 
 0F21  A3 0000 E             C  	MOV	WORD PTR $FACM1,AX 
 0F24  92                    C  	XCHG	AX,DX		;GET NO RT. ADJUSTED IN AX 
 0F25  0B C0                 C  	OR	AX,AX 
 0F27  79 03                 C  	JNS	IDV20 
 0F29  BA FFFF               C  	MOV	DX,177777	;SIGN EXTEND INTO DX 
 0F2C  0B DB                 C  IDV20:	OR	BX,BX		;SEE IF DENOMINATOR NEEDS SIGN
				 EXT 
 0F2E  79 06                 C  	JNS	IDV30 
 0F30  C7 06 0000 E FFFF     C  	MOV	WORD PTR $FACM1,177777 
 0F36  F7 3E 0000 E          C  IDV30:	IDIV	WORD PTR $FACLO ;16 BIT DIVIDE 
 0F3A  8B D8                 C  	MOV	BX,AX 
 0F3C  E9 105E R             C  	JMP	MAKINT 
                             C   
 0F3F  87 D9                 C  MOVFR:	XCHG	BX,CX 
 0F41  E8 0A05 R             C  	CALL	$MOVFR		;MOVE TO FAC 
 0F44  87 D9                 C  	XCHG	BX,CX		;GET REGISTERS RIGHT 
 0F46  C3                    C  	RET 
 0F47  53                    C  MOVFM:	PUSH	BX 
 0F48  E8 0BA1 R             C  	CALL	$MOVFM 
 0F4B  5B                    C  	POP	BX 
 0F4C  83 C3 04              C  	ADD	BX,4 
 0F4F  C3                    C  	RET 
 0F50  8B 16 0000 E          C  MOVRF:	MOV	DX,WORD PTR $FACLO 
 0F54  8B 0E FFFF E          C  	MOV	CX,WORD PTR $FAC-1 
 0F58  C3                    C  	RET 
 0F59  9C                    C  MOVMF:	PUSHF 
 0F5A  53                    C  	PUSH	BX 
 0F5B  E8 0B88 R             C  	CALL	$MOVMF 
 0F5E  5B                    C  	POP	BX 
 0F5F  83 C3 04              C  	ADD	BX,4 
 0F62  9D                    C  	POPF 
 0F63  C3                    C  	RET 
 0F64  E8 0000 E             C  FOUTO:	CALL	FRQINT 
 0F67  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX 
 0F6B  E9 002E R             C  	JMP	$FOUTO 
 0F6E  E8 0000 E             C  FOUTH:	CALL	FRQINT 
 0F71  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX 
 0F75  E9 0036 R             C  	JMP	$FOUTH 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-68
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 0F78                        C  FADDS:				;ADD NO. POINTED TO BY (BX) TO (FAC) 
 0F78  8B 17                 C  	MOV	DX,WORD PTR 0[BX] 
 0F7A  8B 5F 02              C  	MOV	BX,WORD PTR 2[BX] 
 0F7D  E9 139F R             C  	JMP	$FADDS 
 0F80  5E                    C  PUSHF:	POP	SI		;GET OUR RETURN ADDRESS OFF STAC
				K 
 0F81  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 0F85  FF 36 FFFF E          C  	PUSH	WORD PTR $FAC-1 
 0F89  FF E6                 C  	JMP	SI 
 0F8B                        C  FCOMP: 
 0F8B  87 D9                 C  	XCHG	BX,CX 
 0F8D  E8 0A40 R             C  	CALL	$FCOMP 
 0F90  87 D9                 C  	XCHG	BX,CX 
 0F92  C3                    C  	RET 
 0F93                        C  FRCSTR: 
 0F93  E8 08EE R             C  CHKSTR: CALL	$GETYP		;WANT TO ASSURE STRING 
 0F96  74 03                 C  	JZ	CH10 
 0F98  E9 0000 E             C  	JMP	TMERR 
 0F9B  C3                    C  CH10:	RET 
 0F9C  87 DA                 C  INEG2:	XCHG	BX,DX 
 0F9E  E8 1068 R             C  	CALL	VALSNG 
 0FA1  32 C0                 C  	XOR	AL,AL 
 0FA3  B5 98                 C  INEGAD: MOV	CH,LOW 230 
 0FA5                        C  FLOATR: 
 0FA5  BB 0000 E             C  	MOV	BX,OFFSET $FAC 
 0FA8  8A C8                 C  	MOV	CL,AL 
 0FAA  88 2F                 C  	MOV	BYTE PTR 0[BX],CH 
 0FAC  B5 00                 C  	MOV	CH,LOW 0	;ZERO OVERFLOW BYTE 
 0FAE  43                    C  	INC	BX 
 0FAF  88 2F                 C  	MOV	BYTE PTR 0[BX],CH 
 0FB1  D0 D0                 C  	RCL	AL,1 
 0FB3                        C  FADFLT: 
 0FB3  73 03                 C  	JNB	FL10 
 0FB5  E8 10CC R             C  	CALL	NEGR 
 0FB8  8A E5                 C  FL10:	MOV	AH,CH		;OVERFLOW BYTE TO AH 
 0FBA  8A D9                 C  	MOV	BL,CL		;BL IS HIGH MANTISSA BIT 
 0FBC  E9 1CE4 R             C  	JMP	$NORMS 
 0FBF  E8 0E5B R             C  RNDMON: CALL	$CHRGT 
 0FC2  53                    C  RNDMN2: PUSH	BX 
 0FC3  33 DB                 C  	XOR	BX,BX		;WILL SET FAC TO 1.0 
 0FC5  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX 
 0FC9  B7 81                 C  	MOV	BH,LOW 201 
 0FCB  89 1E 0000 E          C  	MOV	WORD PTR $FACM1,BX 
 0FCF  C6 06 0000 E 04       C  	MOV	BYTE PTR $VALTP,LOW 4	;SET CORRECT TYPE 
 0FD4  E8 1F03 R             C  	CALL	$RND 
 0FD7  5B                    C  	POP	BX 
 0FD8  C6 06 0000 E 04       C  	MOV	BYTE PTR $VALTP,LOW 4 
 0FDD  C3                    C  	RET 
 0FDE  8B C1                 C  UMULT:	MOV	AX,CX		;WILL FORM (DX)=(CX)*(DX) 
 0FE0  F7 E2                 C  	MUL	DX 
 0FE2  92                    C  	XCHG	AX,DX 
 0FE3  73 03                 C  	JNB	UM10 
 0FE5  E9 0000 E             C  	JMP	BSERR 
 0FE8  C3                    C  UM10:	RET 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-69
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 0FE9  BB 0000 E             C  VMOVFA: MOV	BX,OFFSET $ARGLO 
 0FEC  BA 100B R             C  VMOVFM: MOV	DX,OFFSET MOVVFM 
 0FEF  EB 07 90              C  	JMP	VMVVFM 
 0FF2  BB 0000 E             C  VMOVAF: MOV	BX,OFFSET $ARGLO 
 0FF5  BA 100D R             C  VMOVMF: MOV	DX,OFFSET VMOVE 
 0FF8  52                    C  VMVVFM: PUSH	DX 
 0FF9  BA 0000 E             C  VDFACS: MOV	DX,OFFSET $FACLO 
 0FFC  E8 08EE R             C  	CALL	$GETYP 
 0FFF  72 03                 C  	JB	VD15 
 1001  BA 0000 E             C  VD10:	MOV	DX,OFFSET $DFACL 
 1004  C3                    C  VD15:	RET 
 1005  8A CD                 C  MOVE1:	MOV	CL,CH 
 1007  32 ED                 C  	XOR	CH,CH 
 1009  EB 08                 C  	JMP	SHORT F4VM10	;MOVE FOR BASIC INTERPRETER 
 100B  87 DA                 C  MOVVFM: XCHG	BX,DX 
 100D  A0 0000 E             C  VMOVE:	MOV	AL,BYTE PTR $VALTP 
 1010  98                    C  	CBW 
 1011  8B C8                 C  	MOV	CX,AX 
 1013  FC                    C  F4VM10: CLD			;SO WE WILL INCREMENT 
 1014  8B F2                 C  	MOV	SI,DX 
 1016  8B FB                 C  	MOV	DI,BX 
 1018  F3/ A4                C   REP	MOVSB 
 101A  8B D6                 C  	MOV	DX,SI 
 101C  8B DF                 C  	MOV	BX,DI 
 101E  C3                    C  	RET 
                             C   
                             C  ; 
                             C  ; THIS IS THE BLOCK TRANSFER ROUTINE 
                             C  ; IT MAKES SPACE BY SHOVING EVERYTHING FORWARD 
                             C  ; 
                             C  ; BX = DESTINATION OF HIGH ADDRESS 
                             C  ; DX = LOW ADDRESS TO BE TRANSFERRED 
                             C  ; CX = HIGH ADDRESS TO BE TRANSFERRED 
                             C  ; 
                             C  ; A CHECK IS MADE TO MAKE SURE A REASONABLE AMO
				UNT 
                             C  ; OF SPACE REMAINS BETWEEN THE TOP OF THE STACK
				 AND 
                             C  ; THE HIGHEST LOCATION TRANSFERRED INTO 
                             C  ; 
                             C  ; ON EXIT BX=DX=LOW CX=LOCATION LOW WAS MOVED I
				NTO 
                             C  ; 
 101F  E8 0000 E             C  BLTU:	CALL	REASON		;CHECK DESTINATION TO MAKE S
				URE 
                             C  				;STRING SPACE WONT BE OVERWRITTEN 
 1022  8B F1                 C  BLTUC:	MOV	SI,CX		;SET UP HIGH ADDRESS 
 1024  8B FB                 C  	MOV	DI,BX		;SET UP DESTINATION OF HIGH ADDRESS
				 
 1026  FD                    C  	STD			;MOVE DOWN 
 1027  2B CA                 C  	SUB	CX,DX		;GET COUNT OF BYTES TO TRANSFER 
 1029  41                    C  	INC	CX		;ALWAYS MOVE ONE BYTE 
 102A  F3/ A4                C   REP	MOVSB			;MOVE BYTES 
 102C  8B DA                 C  	MOV	BX,DX		;BX=LOW 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-70
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 102E  8B CF                 C  	MOV	CX,DI		;CX=DESTINATION OF LOW 
 1030  41                    C  	INC	CX		;CORRECT AS DECREMENTED ONE TOO MANY 
 1031  FC                    C  	CLD			;SET DIRECTION BIT TO UP 
 1032  C3                    C  	RET 
                             C   
 1033  9C                    C  DCXBRT: PUSHF 
 1034  49                    C  	DEC	CX 
 1035  9D                    C  	POPF 
 1036  C3                    C  	RET 
 1037  E8 08EE R             C  VSIGN:	CALL	$GETYP		;DETERMINE TYPE 
 103A  75 03                 C  	JNZ	VS10		;IF NOT STRING PROCEED 
 103C  E9 0000 E             C  	JMP	TMERR 
 103F                        C  VS10: 
 103F  78 03                 C  	JS	ISI10 
 1041  E9 08BE R             C  	JMP	$SIGNS		;SINGLE OR DOUBLE PRECISION 
 1044  A1 0000 E             C  ISI10:	MOV	AX,WORD PTR $FACLO	;GET THE INTEGER 
 1047  0B C0                 C  	OR	AX,AX		;SET SIGNS CORRECTLY 
 1049  74 06                 C  	JZ	ISIGN1 
 104B  B0 01                 C  ISI15:	MOV	AL,LOW 1 
 104D  79 02                 C  	JNS	ISIGN1 
 104F  B0 FF                 C  	MOV	AL,LOW 377 
 1051  C3                    C  ISIGN1: RET 
 1052  33 C0                 C  ISIGN:	XOR	AX,AX		;IN CASE (BX) IS ZERO 
 1054  0B DB                 C  	OR	BX,BX		;NEED SIGN OF (BX) 
 1056  75 F3                 C  	JNZ	ISI15 
 1058  C3                    C  	RET 
 1059  5B                    C  POPHRT: POP	BX 
 105A  C3                    C  	RET 
 105B                        C  CONIA:				;CONVERT NO. IN A TO AN INTEGER 
 105B  98                    C  	CBW 
 105C  8B D8                 C  	MOV	BX,AX 
 105E  C6 06 0000 E 02       C  MAKINT: MOV	BYTE PTR $VALTP,LOW 2	;MAKE INTEGER
				 
 1063  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX	;STORE INTEGER IN $FAC 
 1067  C3                    C  	RET 
 1068  C6 06 0000 E 04       C  VALSNG: MOV	BYTE PTR $VALTP,LOW 4 
 106D  C3                    C  	RET 
 106E  E8 1037 R             C  SGN:	CALL	VSIGN 
 1071  EB E8                 C  	JMP	CONIA 
 1073                        C  FDIVT: 
 1073  5B                    C  	POP	BX 
 1074  5A                    C  	POP	DX 
 1075  E9 15D6 R             C  	JMP	$FDIVS 
 1078  E8 1799 R             C  FPWRQ:	CALL	$FS		;FORCE FAC TO SP 
 107B  5B                    C  FPWRT:	POP	BX 
 107C  5A                    C  	POP	DX 
 107D  E9 0D29 R             C  	JMP	$FPWR 
 1080  B9 0004               C  MOVE:	MOV	CX,4 
 1083  EB 8E                 C  	JMP	F4VM10 
 1085  9C                    C  MOVRM:	PUSHF 
 1086  8A 17                 C  	MOV	DL,BYTE PTR 0[BX] 
 1088  43                    C  	INC	BX 
 1089  9D                    C  	POPF 
 108A  9C                    C  GETBCD: PUSHF 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-71
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 108B  8A 37                 C  	MOV	DH,BYTE PTR 0[BX] 
 108D  43                    C  	INC	BX 
 108E  8B 0F                 C  	MOV	CX,WORD PTR 0[BX] 
 1090  43                    C  	INC	BX 
 1091  9D                    C  	POPF 
 1092  9C                    C  INXHRT: PUSHF 
 1093  43                    C  	INC	BX 
 1094  9D                    C  	POPF 
 1095  C3                    C  	RET 
 1096  53                    C  INPRT:	PUSH	BX 
 1097  BB 0000 E             C  	MOV	BX,OFFSET INTXT 
 109A  E8 089E R             C  	CALL	STROUT 
 109D  5B                    C  	POP	BX 
 109E  B9 0000 E             C  LINPRT: MOV	CX,OFFSET STROUI 
 10A1  51                    C  	PUSH	CX 
 10A2  E8 105E R             C  LINOUT: CALL	MAKINT 
 10A5  32 C0                 C  	XOR	AL,AL 
 10A7                        C  FOUINI: 
 10A7  A2 0000 E             C  	MOV	BYTE PTR TEMP3,AL 
 10AA  BB 0001 E             C  	MOV	BX,OFFSET $FBUFF+1 
 10AD  C6 07 20              C  	MOV	BYTE PTR 0[BX],LOW " " 
 10B0  0A 07                 C  	OR	AL,BYTE PTR 0[BX] 
 10B2  43                    C  	INC	BX 
 10B3  C6 07 30              C  	MOV	BYTE PTR 0[BX],LOW "0" 
 10B6  E9 1B4B R             C  	JMP	$FOUT2 
 10B9                        C  SIGNC: 
 10B9  A0 FFFF E             C  	MOV	AL,BYTE PTR $FAC-1 
 10BC  EB 07                 C  	JMP	SHORT ICOMPS 
 10BE                        C  DCOMP: 
 10BE  E8 0ACF R             C  	CALL	$DCMPA 
 10C1  74 08                 C  	JZ	SG15 
 10C3  F6 D0                 C  	NOT	AL 
 10C5  D0 E0                 C  ICOMPS: SAL	AL,1 
 10C7  1A C0                 C  SIGNS:	SBB	AL,AL 
 10C9  74 39                 C  	JZ	INRART 
 10CB  C3                    C  SG15:	RET 
 10CC                        C  NEGR: 
 10CC  80 36 0001 E 80       C  	XOR	BYTE PTR $FAC+1,LOW 200 ;FLIP SIGN 
 10D1  33 DB                 C  	XOR	BX,BX		;WILL NEED THIS ZERO REGISTER 
 10D3  F6 DD                 C  	NEG	CH 
 10D5  8B C3                 C  	MOV	AX,BX 
 10D7  1B C2                 C  	SBB	AX,DX		;DO MIDDLE BYTES 
 10D9  8B D0                 C  	MOV	DX,AX		;AND REPLACE 
 10DB  8A C3                 C  	MOV	AL,BL 
 10DD  1A C1                 C  	SBB	AL,CL 
 10DF  8A C8                 C  	MOV	CL,AL 
 10E1  C3                    C  NG10:	RET 
 10E2                        C  FIXER: 
 10E2  E8 08EE R             C  	CALL	$GETYP 
 10E5  78 FA                 C  	JS	NG10 
 10E7  E8 08BE R             C  	CALL	$SIGNS 
 10EA  78 03                 C  	JS	F4FX20 
 10EC  E9 0BEE R             C  	JMP	$VINT 
 10EF  E8 0B24 R             C  F4FX20: CALL	$NEG 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-72
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 10F2  E8 0BEE R             C  	CALL	$VINT 
 10F5  E9 0B24 R             C  	JMP	$NEG 
 10F8                        C  ICOMP:				;COMPARE (DX) AND (BX) 
                             C  				;(AL)=1 IF (DX) .LT. (BX) 
                             C  				;(AL)=0 IF (DX) = (BX) 
                             C  				;(AL)=-1 IF (DX) .GT. (BX) 
 10F8  8B C3                 C  	MOV	AX,BX		;SO WE CAN HAVE SEPARATE ENTRY FOR 
				AX 
 10FA  2B C2                 C  ICMPA:	SUB	AX,DX		;COMPARISONS 
 10FC  74 0E                 C  	JZ	IC40		;ALL OK , JUST EXIT 
 10FE  70 07                 C  	JO	IC20		;IF SF=1 ADDITIONALLY THEN AX LARGER 
 1100  78 07                 C  	JS	IC30		;DX DEFINITELY LARGER 
 1102  32 C0                 C  IC10:	XOR	AL,AL		;(AX) LARGER 
 1104  FE C0                 C  INRART: INC	AL		;(AL)=1 
 1106  C3                    C  IC15:	RET 
 1107  78 F9                 C  IC20:	JS	IC10 
 1109  F9                    C  IC30:	STC 
 110A  1A C0                 C  	SBB	AL,AL		;(AL)=377 
 110C  C3                    C  IC40:	RET 
 110D  3B DA                 C  IMOD:	CMP	BX,DX		;IF EQUAL RETURN ZERO 
 110F  75 05                 C  	JNZ	IMD10 
 1111  33 DB                 C  IMD05:	XOR	BX,BX 
 1113  EB 47 90              C  	JMP	IMD40 
 1116                        C  IMD10:				;(BX)= (DX) MOD (BX) 
 1116  81 FA 8000            C  	CMP	DX,100000	;CHECK FOR -32768 
 111A  75 0A                 C  	JNZ	IMD15		;PROCEED IF NOT 
 111C  83 FB FF              C  	CMP	BX,177777	;Check for special case of -3276
				8 MOD -1 
 111F  74 F0                 C  	JE	IMD05 
 1121  83 FB 01              C  	CMP	BX,1		;Also for -32768 MOD 1 
 1124  74 EB                 C  	JE	IMD05 
 1126                        C  IMD15: 
 1126  8B C2                 C  	MOV	AX,DX 
 1128  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX 
 112C  0B DB                 C  	OR	BX,BX 
 112E  75 0E                 C  	JNZ	IMD17		; Trying to divide by zero? 
 1130  88 36 0001 E          C  	MOV	BYTE PTR $FAC+1,DH	; Yep, set up correct s
				ign 
 1134  FE C7                 C  	INC	BH		; Hack for DOINF to work 
 1136  C6 06 0000 E 04       C  	MOV	BYTE PTR $VALTP,LOW 4 
 113B  E9 0786 R             C  	JMP	$DIV0S 
 113E                        C  IMD17: 
 113E  C7 06 FFFF E 0000     C  	MOV	WORD PTR $FAC-1,0 
 1144  79 06                 C  	JNS	IMD20 
 1146  C7 06 FFFF E FFFF     C  	MOV	WORD PTR $FAC-1,177777 
 114C  0B C0                 C  IMD20:	OR	AX,AX 
 114E  BA 0000               C  	MOV	DX,0 
 1151  79 03                 C  	JNS	IMD30 
 1153  BA FFFF               C  	MOV	DX,177777 
 1156  F7 3E 0000 E          C  IMD30:	IDIV	WORD PTR $FACLO 
 115A  8B DA                 C  	MOV	BX,DX		;MOVE MOD TO BX 
 115C  89 1E 0000 E          C  IMD40:	MOV	WORD PTR $FACLO,BX 
 1160  C3                    C  	RET 
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-73
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

                             C   
                             C  ; THIS IS THE INNER LOOP OF SYMBOL TABLE SEARCH
				ING FOR NON-SUBSCRIPTED 
                             C  ; VARIABLES. 
                             C  ; 
                             C  ; Note 9-Aug-82/MLC - Entry is made at LOPFND, 
				which does a CLD. 
                             C  ; Want this code to be fast so don't only do th
				is one CLD for the 
                             C  ; entire piece of code. 
                             C  ; 
                             C   
 1161  AD                    C  LOPTOP: LODSW			;GET VALTYP IN [AL], 1ST CHAR I
				N [AH] 
 1162  3A E1                 C  	CMP	AH,CL		;SAME 2ND CHAR? 
 1164  74 11                 C  	JZ	ISIT		;YES MAY BE VAR WERE LOOKING FOR 
 1166  46                    C  NOTIT1: INC	SI		;POINT AT LENGTH OF REST OF VAR
				 CHARS 
 1167  02 04                 C  	ADD	AL,BYTE PTR 0[SI]	;ADD FURTHUR OFFSET 
 1169  FE C0                 C  	INC	AL		;PLUS ONE 
 116B  98                    C  NOTIT0: CBW			;SIGN EXTEND IT 
 116C  03 F0                 C  	ADD	SI,AX		;MOVE TO NEXT VARIABLE 
 116E  3B F5                 C  NOTIT2: CMP	SI,BP		;DONE WITH SYMBOL TABLE SEAR
				CH? 
 1170  75 EF                 C  	JNZ	LOPTOP		;NO, KEEP LOOKING 
 1172  8B D6                 C  	MOV	DX,SI		;POINT AFTER VAR 
 1174  E9 0000 E             C  	JMP	NOTFNS		;SEE IF SEARCHED ALL TABLES 
                             C   
 1177  3A 06 0000 E          C  ISIT:	CMP	AL,BYTE PTR VALTYP	;VALTYP'S THE SAME
				? 
 117B  75 E9                 C  	JNZ	NOTIT1		;NO, LOOK AT NEXT VAR 
 117D  3A 2C                 C  	CMP	CH,BYTE PTR 0[SI]	;2ND CHAR OF VAR THE SAM
				E? 
 117F  75 E5                 C  	JNZ	NOTIT1		;NO, KEEP LOOKING 
 1181  46                    C  	INC	SI		;POINT TO VALTYP 
 1182  8A D0                 C  	MOV	DL,AL		;GET IN IN [DL] 
 1184  AC                    C  	LODSB			;GET VALTYP IN [AL] 
 1185  3A 06 0000 E          C  	CMP	AL,BYTE PTR NAMCNT	;SAME AS VAR WERE LOOKI
				NG FOR? 
 1189  74 04                 C  	JZ	LENMAT		;LENGTHS MATCH! 
 118B  02 C2                 C  	ADD	AL,DL		;ADD SAVED VALTYP AND LENGTH OF VAR
				 
 118D  EB DC                 C  	JMP	SHORT NOTIT0	;GO TO NEXT VAR 
                             C   
 118F  0A C0                 C  LENMAT: OR	AL,AL		;LENGTH ZERO? 
 1191  74 10                 C  	JZ	FNDITV		;YES, FOUND IT! 
 1193  98                    C  	CBW			;MAKE LENGTH A WORD 
 1194  91                    C  	XCHG	CX,AX		;SAVE 2 CHARS OF VAR, PUT LENGTH I
				N CX 
 1195  BF 0000 E             C  	MOV	DI,OFFSET NAMBUF	;POINT TO NAME BUFFER 
                             C  		     ;COMPARE TWO VAR NAMES 
 1198  F3/ A6                C   REP	CMPSB			;WITH SPECIAL INSTR 
 119A  91                    C  	XCHG	AX,CX		;FLIP BACK 
 119B  74 06                 C  	JZ	FNDITV		;FOUND IT 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-74
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 119D  03 F0                 C  	ADD	SI,AX		;ADD CHARS LEFT, CC'S SHOULD BE NON
				-ZERO 
 119F  8A C2                 C  	MOV	AL,DL		;GET BACK SAVED VALTYP 
 11A1  EB C8                 C  	JMP	SHORT NOTIT0	;PROCEED WITH FAILED SEARCH 
 11A3  8B D6                 C  FNDITV: MOV	DX,SI		;GET POINTER TO VAR IN [DX] 
 11A5  5B                    C  	POP	BX		;RESTORE TEXT POINTER 
 11A6  C3                    C  	RET			;ALL DONE!!! 
                             C   
 11A7  8B F3                 C  LOPFND: MOV	SI,BX		;START SEARCHING HERE 
 11A9  8B 2E 0000 E          C  	MOV	BP,WORD PTR ARYTA2	;LIMIT OF VARIABLE SEAR
				CH 
 11AD  FC                    C  	CLD			;INCREMENT 
 11AE  EB BE                 C  	JMP	SHORT NOTIT2	;START LOOKING 
                             C   
                             C   
                             C  ; THIS IS THE CORRESPONDING CODE FOR ARRAY SEAR
				CHES 
                             C  ; Note 9-Aug-82/MLC - This code is supposed to 
				be fast so only a 
                             C  ; single CLD is done here for the entire piece 
				of code. 
                             C  ; 
                             C   
 11B0  8B F3                 C  LOPFD1: MOV	SI,BX		;INITIALIZE POINTER TO SYMBO
				L TABLE 
 11B2  8B 2E 0000 E          C  	MOV	BP,WORD PTR STREND	;GET LIMIT OF SEARCH 
 11B6  FC                    C  	CLD			;SET DIRECTION RIGHT 
 11B7  EB 0E 90              C  	JMP	LOPFDI		;START SEARCHING 
 11BA  AD                    C  LOPFD0: LODSW			;GET VALTYP AND 1ST CHAR OF VAR
				 
 11BB  3A E1                 C  	CMP	AH,CL		;ARE FIRST CHARS THE SAME? 
 11BD  74 11                 C  	JZ	ISARY		;YES, COULD BE RIGHT ONE 
 11BF  46                    C  NMARY1: INC	SI		;POINT TO LENGTH OF VAR 
 11C0  AC                    C  NMARY2: LODSB			;GET LENGTH OF IT 
 11C1  98                    C  NMARY3: CBW			;EXTEND SIGN 
 11C2  03 F0                 C  	ADD	SI,AX		;ADD OFFSET 
 11C4  AD                    C  NMARY4: LODSW			;GET OFFSET TO ARRAY 
 11C5  03 F0                 C  	ADD	SI,AX		;POINT TO NEXT ARRAY 
 11C7  3B EE                 C  LOPFDI: CMP	BP,SI		;AT END OF ARRAYS? 
 11C9  75 EF                 C  	JNZ	LOPFD0		;NO, KEEP GOING 
 11CB  8B DE                 C  	MOV	BX,SI		;AT END 
 11CD  E9 0000 E             C  	JMP	NOTFDD		;RETURN TO MAIN-LINE CODE IN BIPTR
				G.MAC 
                             C   
 11D0  3A 06 0000 E          C  ISARY:	CMP	AL,BYTE PTR VALTYP	;TYPE OF VARS THE
				 SAME? 
 11D4  75 E9                 C  	JNZ	NMARY1		;NO, LOOK AT NEXT ONE 
 11D6  3A 2C                 C  	CMP	CH,BYTE PTR 0[SI]	;2ND CHARS THE SAME? 
 11D8  75 E5                 C  	JNZ	NMARY1		;NO 
 11DA  46                    C  	INC	SI		;POINT AT EXTRA CHARS 
 11DB  AC                    C  	LODSB			;FETCH NUMBER OF THEM 
 11DC  3A 06 0000 E          C  	CMP	AL,BYTE PTR NAMCNT	;SAME AS WHAT WE WANT? 
 11E0  75 DF                 C  	JNZ	NMARY3		;NO, LOOK AT NEXT VAR 
 11E2  0A C0                 C  	OR	AL,AL		;NO CHARS LEFT? 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-75
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 11E4  74 0E                 C  	JZ	CNOMAT		;YES, MATCH, ALL DONE 
 11E6  98                    C  	CBW			;MAKE WORD 
 11E7  91                    C  	XCHG	AX,CX		;PUT CHAR COUNT IN CX, SAVE FIRST 
				TWO VAR CHARS 
 11E8  BF 0000 E             C  	MOV	DI,OFFSET NAMBUF	;POINT AT VAR BUFFER 
                             C  		     ;COMPARE TWO VAR NAMES 
 11EB  F3/ A6                C   REP	CMPSB 
 11ED  91                    C  	XCHG	AX,CX		;GET BACK 2 CHARS TO MATCH IN [CX]
				 
                             C  				;REMAINING CHARS IN NAME IN [AX] 
 11EE  74 04                 C  	JZ	CNOMAT		;VARS MATCHED 
 11F0  03 F0                 C  	ADD	SI,AX		;ADD REST OF CHARS TO WHERE WE ARE 
 11F2  EB D0                 C  	JMP	SHORT NMARY4	;LOOK AT NEXT VAR 
                             C   
 11F4  AD                    C  CNOMAT: LODSW			;GET OFFSET TO END OF ARRAY 
 11F5  8B D0                 C  	MOV	DX,AX		;PROBOBALLY NOT USED 
 11F7  8B DE                 C  	MOV	BX,SI		;POINT TO NUMBER OF DIMENSIONS 
 11F9  E9 0000 E             C  	JMP	ARYEXT		;GO BACK 
                             C   
                             C   
                             C  	SUBTTL	 $AEXPS  SINGLE AND DOUBLE PRECISION AD
				D/SUBTRACT OF EXPONENTS 
                             C  ;**********************************************
				*************** 
                             C  ; 
                             C  ;       $AEXPS,$SEXPS   WILL PERFORM THE ADDITI
				ON/SUBTRACTION 
                             C  ;               OF SINGLE OR DOUBLE PRECISION E
				XPONENTS. 
                             C  ;       CALLING SEQUENCE:       CALL    $AEXPS 
                             C  ;               OR              CALL    $SEXPS 
                             C  ;               WITH THE SINGLE PRECISION NUMER
				ATOR(MULTIPLIER) 
                             C  ;               IN (BXDX) OR THE DOUBLE PRECISI
				ON NUMERATOR 
                             C  ;               (MULTIPLIER) IN ($ARG) AND THE 
				DENOMINATOR 
                             C  ;               (MULTIPLICAND) IN THE ($FAC) 
                             C  ;               FOR DOUBLE PRECISION OPERATIONS
				 THE $ARG  EXPONENT 
                             C  ;               AND HIGH MANTISSA BYTE MUST BE 
				IN BH:BL PRIOR 
                             C  ;               TO A $SEXPS,$AEXPS CALL 
                             C  ; 
                             C  ;**********************************************
				**************** 
                             C   
                             C   
 11FC  F9                    C  $AEXPS: STC			;CF=1 
 11FD  EB 01                 C  	JMP	SHORT SES00 
 11FF  F8                    C  $SEXPS: CLC			;CF=0 
 1200  8B F3                 C  SES00:	MOV	SI,BX		;WILL NEED FOR LATER 
 1202  9C                    C  	PUSHF			;SAVE MULTIPLY/DIVIDE FLAG 
 1203  8B 0E FFFF E          C  	MOV	CX,WORD PTR $FAC-1	;(CH)=$FAC:(CL)=$FAC-1 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-76
$AEXPS  SINGLE AND DOUBLE PRECISION ADD/SUBTRACT OF EXPONENT

 1207  8A C3                 C  	MOV	AL,BL		;FETCH (BXDX) SIGN BYTE 
 1209  32 C1                 C  	XOR	AL,CL		;CORRECT SIGN IN AL 
 120B  A2 0001 E             C  	MOV	BYTE PTR $FAC+1,AL	;MOVE TO $FAC+1 
 120E  8A C7                 C  	MOV	AL,BH		;GET (BXDX) EXPONENT 
 1210  32 E4                 C  	XOR	AH,AH		;WILL USE 16-BIT ARITHEMETIC 
 1212  8A DD                 C  	MOV	BL,CH		;TO CALCULATE EXPONENTS 
 1214  32 FF                 C  	XOR	BH,BH 
 1216  9D                    C  	POPF			;SEE IF ADD OR SUBTRACT OF EXPONENTS 
 1217  73 07                 C  	JNB	SES05		;JUMP IF SUBTRACT 
 1219  03 C3                 C  	ADD	AX,BX		;HAVE IN TWO BIASES 
 121B  2D 0101               C  	SUB	AX,401		;NOW HAVE RAW SUM LESS 1 
 121E  EB 02                 C  	JMP	SHORT SES07	;GO CHECK FOR OVERFLOW/UNDERFL
				OW 
 1220  2B C3                 C  SES05:	SUB	AX,BX		;BIASES CANCEL OUT 
 1222  0A E4                 C  SES07:	OR	AH,AH		; 
 1224  78 0D                 C  	JS	SES10		;MUST GO CHECK FOR UNDERFLOW 
 1226  3D 0080               C  	CMP	AX,200		;CF=0 IF OVERFLOW 
 1229  72 15                 C  	JB	SES20		;PROCEED IF OK 
 122B  8B DE                 C  	MOV	BX,SI		;GET (BX) OFF STACK 
 122D  83 C4 02              C  	ADD	SP,2		;GET $SEXPS RETURN ADDRESS OFF STACK
				 
 1230  E9 0775 R             C  	JMP	$OVFLS		;GO DO OVERFLOW CODE 
 1233                        C  SES10:				;POTENTIAL UNDERFLOW 
 1233  05 0080               C  	ADD	AX,200		;BIAS MUST BRING IT IN POSITIVE 
 1236  79 0B                 C  	JNS	SES30		;IF IT IS POSITIVE PROCEED 
 1238  8B DE                 C  	MOV	BX,SI		;BET (BX) OFF STACK 
 123A  83 C4 02              C  	ADD	SP,2		;GET $SEXPS RETURN ADDRESS OFF STACK
				 
 123D  E9 08B4 R             C  	JMP	$ZERO		;GO ZERO THE FAC AND RETURN 
 1240  05 0080               C  SES20:	ADD	AX,200		;ADD IN THE BIAS 
 1243  A2 0000 E             C  SES30:	MOV	BYTE PTR $FAC,AL	;PUT CORRECT EXPONE
				NT IN $FAC 
 1246  BB FFFF E             C  	MOV	BX,OFFSET $FAC-1	;ADDRESS OF HIGH MANTISSA
				 BITS 
 1249  80 0F 80              C  	OR	BYTE PTR 0[BX],LOW 200	;OR IN THE HIDDEN "1
				" 
 124C  8B DE                 C  	MOV	BX,SI		;GET (BXDX) HIGH MANTISSA BITS 
 124E  32 FF                 C  	XOR	BH,BH		;CLEAR SUPERFLUOUS BITS 
 1250  80 CB 80              C  	OR	BL,LOW 200	;RESTORE HIDDEN "1" 
 1253  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $CHKEL  SUBROUTINE TO $FIN FOR CHECKIN
				G "ELSE" AND "EQV" 
                             C  ;**********************************************
				******************* 
                             C  ; 
                             C  ;       $CHKEL  CHECKS AN INPUT STREAM FOR POSS
				IBLE "ELSE" OR "EQV" 
                             C  ;               CONSTRUCTS ONCE AN "E" HAS BEEN
				 DETECTED. IF ONE OF 
                             C  ;               THESE CONSTRUCTS IS DETECTED ZF
				=1 WILL BE RETURNED 
                             C  ;               OTHERWISE ZF=0 WILL BE RETURNED
				. 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-77
$CHKEL  SUBROUTINE TO $FIN FOR CHECKING "ELSE" AND "EQV"    

                             C  ;       CALLING SEQUENCE:       CALL    $CHKEL 
                             C  ;               WITH (BX) POINTING TO THE CURRE
				NT POSITION IN THE 
                             C  ;               INPUT CHARACTER STREAM. 
                             C  ; 
                             C  ;**********************************************
				******************** 
 1254  53                    C  $CHKEL: PUSH	BX		;SAVE TEXT POINTER 
 1255  E8 0E5B R             C  	CALL	$CHRGT		;GET NEXT CHARACTER INTO (AL) 
 1258  3C 6C                 C  	CMP	AL,LOW OFFSET "L"+40    ;LOWER CASE "L"? 
 125A  74 0A                 C  	JZ	CK10		;RETURN WITH ZF=1 
 125C  3C 4C                 C  	CMP	AL,LOW "L"      ;UPPER CASE "L"? 
 125E  74 06                 C  	JZ	CK10		;RETURN WITH ZF=1 
 1260  3C 71                 C  	CMP	AL,LOW OFFSET "Q"+40    ;LOWER CASE "Q"? 
 1262  74 02                 C  	JZ	CK10		;RETURN WITH ZF=1 
 1264  3C 51                 C  	CMP	AL,LOW "Q"      ;UPPER CASE "Q"? 
                             C  ;**********************************************
				****************** 
                             C  ;THAT LAST CMPBI WILL SET ZF APPROPRIATELY SO W
				E'LL EXIT NOW 
                             C  ;**********************************************
				****************** 
 1266  5B                    C  CK10:	POP	BX		;GET TEXT POINTER BACK 
 1267  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $EXP	 SINGLE PRECISION EXPONENTIAL FUN
				CTION 
                             C  ;**********************************************
				*************** 
                             C  ; 
                             C  ;THE FUNCTION EXP(X) CALCULATES e^X WHERE e=2.7
				18282 
                             C  ;       THE TECHNIQUE USED IS TO EMPLOY A COUPL
				E 
                             C  ;       OF FUNDAMENTAL IDENTITIES THAT ALLOWS U
				S TO 
                             C  ;       USE THE BASE 2 THROUGH THE DIFFICULT PO
				RTIONS OF 
                             C  ;       THE CALCULATION: 
                             C  ; 
                             C  ;               (1)e^X=2^y  WHERE y=X*LOG2(e) [
				LOG2(e) IS 
                             C  ;                                              
				 LOG BASE 2 
                             C  ;                                              
				 OF e ] 
                             C  ; 
                             C  ;               (2) 2^y=2^[ INT(y)+(y-INT(y)] 
                             C  ;               (3) IF Ny=INT(y) THEN 
                             C  ;                   2^(Ny+y-Ny)=[2^Ny]*[2^(y-Ny
				)] 
                             C  ; 
                             C  ;       NOW, SINCE 2^Ny IS EASY TO COMPUTE (AN 
				EXPONENT 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-78
$EXP	 SINGLE PRECISION EXPONENTIAL FUNCTION                 

                             C  ;       CALCULATION WITH MANTISSA BITS OF ZERO)
				 THE DIFFICULT 
                             C  ;       PORTION IS TO COMPUTE 2^(Y-Ny) WHERE 0.
				LE.(Y-Ny).LT.1 
                             C  ;       THIS IS ACCOMPLISHED WITH A POLYNOMIAL 
				APPROXIMATION 
                             C  ;       TO 2^Z WHERE 0.LE.Z.LT.1  . ONCE THIS I
				S COMPUTED WE 
                             C  ;       HAVE TO EFFECT THE MULTIPLY BY 2^Ny . 
                             C  ; 
                             C  ;**********************************************
				**************** 
                             C  ;**********************************************
				************* 
                             C  ;THIS IS EXPONENTIAL EVALUATION BY HART POLYNOM
				IAL EVALUATION 
                             C  ;USING COEFFICIENTS FROM #1302 
                             C  ;**********************************************
				************** 
 1268                        C  EXP: 
 1268  BA AA3B               C  $EXP:	MOV	DX,125073	;LOG2(e) 
 126B  BB 8138               C  	MOV	BX,100470 
 126E  E8 191D R             C  	CALL	$FMULS		;y=FAC*LOG2(e) 
 1271  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC	;MUST SEE IF TOO LARGE 
 1274  3C 88                 C  	CMP	AL,LOW 210	;ABS.GT.128? 
 1276  73 3C                 C  	JNB	EXP110		;Yes, too big.  Go decide between 
                             C  				;overflow and underflow. 
 1278  3C 68                 C  	CMP	AL,LOW 150	;SEE IF TOO SMALL(ANS. OF 1.) 
 127A  72 4B                 C  	JB	EXP200 
 127C  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO ;SAVE y 
 1280  FF 36 0002 E          C  	PUSH	WORD PTR $FACLO+2 
 1284  E8 1C37 R             C  	CALL	$QINT		;Determine integer power of 2. 
 1287  8A E2                 C  	MOV	AH,DL 
 1289  80 C4 81              C  	ADD	AH,LOW 201	;THIS WILL CALCULATE THE EXPONE
				NT 
                             C  				;FOR INTEGER POWER OF 2 FLOATING 
                             C  				;POINT . WE USE 201 BECAUSE WE HAVE 
                             C  				;A BIAS OF 200 AND THE UNDERSTOOD 
                             C  				;1 OF FLOATING POINT NUMBERS IS TO 
                             C  				;THE RIGHT OF THE BINARY POINT 
 128C  74 23                 C  	JZ	EXP100		;JUMP IF OVERFLOW 
 128E  50                    C  	PUSH	AX 
 128F  F6 06 0001 E 80       C  	TEST	BYTE PTR $FAC+1,LOW 200O	;Set SF if negat
				ive.  ($QINT saved 
                             C  				;the sign in $FAC+1.) 
 1294  E8 1C2A R             C  	CALL	NGBLDX		;Negate if necessary. 
 1297  32 E4                 C  	XOR	AH,AH		;Clear overflow for $NORMS. 
 1299  E8 1CE4 R             C  	CALL	$NORMS		;This will make the FAC INT(y). 
 129C  58                    C  	POP	AX 
 129D  5B                    C  	POP	BX 
 129E  5A                    C  	POP	DX		;RECALL y 
 129F  50                    C  	PUSH	AX		;SAVE EXPONENT 
 12A0  E8 1393 R             C  	CALL	$FSUBS		;WANT THE FRACTIONAL PART SO WE 
                             C  				;CAN USE HART #1302 TO CALCULATE 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-79
$EXP	 SINGLE PRECISION EXPONENTIAL FUNCTION                 

                             C  				;2^y OF IT .(WE ALREADY 
                             C  				;KNOW 2^Ny OF THE INTEGER PART 
                             C  				;FROM THE ABOVE) 
 12A3  BB 0546 R             C  	MOV	BX,OFFSET $EXPCN	;POINT TO COEFFICIENTS 
 12A6  E8 1D30 R             C  	CALL	$POLY		;DO THE CALCULATION 
 12A9  5B                    C  	POP	BX		;RECALL EXPONENT OF INTEGER 2^y 
 12AA  33 D2                 C  	XOR	DX,DX		; 
 12AC  8A DA                 C  	MOV	BL,DL		;WE NOW HAVE 2^Ny OF INTEGER 
                             C  				;PART IN (BXDX) AND FRACTIONAL PART 
                             C  				;IN THE $FAC. TO CALCULATE THE ANSWER 
                             C  				;NEED ONLY TO MULTIPLY THESE VALUES 
 12AE  E9 191D R             C  	JMP	$FMULS 
 12B1                        C  EXP100:			;OVERFLOW WITH VALUES ON THE STACK 
 12B1  83 C4 04              C  	ADD	SP,4 
 12B4  80 26 FFFF E 80       C  EXP110: AND	BYTE PTR $FAC-1,LOW 200O	;Is it pos
				itively too big? 
 12B9  74 03                 C  	JZ	EXP115		;Yes, overflow. 
 12BB  E9 08B4 R             C  	JMP	$ZERO		;No, underflow for negative. 
                             C   
 12BE  32 E4                 C  EXP115: XOR	AH,AH		;OVERFLOW WITH STACK CLEAR 
 12C0  88 26 0001 E          C  	MOV	BYTE PTR $FAC+1,AH	;MAKE SURE SIGN IS POSI
				TIVE 
                             C  				;to get postive infinity. 
 12C4  E9 0775 R             C  	JMP	$OVFLS		;GO DO OVERFLOW CODE 
                             C   
 12C7                        C  EXP200:			;WE HAVE DETERMINED THAT THE EXPONENT
				 IS SO SMALL 
                             C  				;THAT WE SHOULD RETURN 1. AS AN ANSWER 
 12C7  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
 12CA  33 C0                 C  	XOR	AX,AX		;.0 
 12CC  FC                    C  	CLD			;SO STOW WILL INCREMENT DI 
 12CD  AB                    C  	STOSW			; 
 12CE  C7 05 8100            C  	MOV	WORD PTR 0[DI],100400	;1.0 
 12D2  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $FADDD  DOUBLE PRECISION FLOATING POIN
				T ADDITION 
                             C  ;**********************************************
				************** 
                             C  ; 
                             C  ;       $FADDD  THIS ROUTINE PERFORMS DOUBLE PR
				ECISION FLOATING 
                             C  ;               POINT ADDITION/SUBTRACTION,I.E.
				 
                             C  ;               (FAC)=(FAC)+-(ARG) 
                             C  ;               THE LARGER NO. WILL BE PLACED I
				N THE FAC, THE SMALLER 
                             C  ;               NO. IN THE ARG WILL BE SHIFTED 
				RIGHT UNTIL THEIR 
                             C  ;               BINARY POINTS ALIGN AND THE TWO
				 WILL BE ADDED/ 
                             C  ;               SUBTRACTED. IF IT TURNS OUT THA
				T THE EXPONENTS WERE 
                             C  ;               EQUAL AND THE OPERATION WAS A S
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-80
$FADDD  DOUBLE PRECISION FLOATING POINT ADDITION            

				UBTRACTION THEN 
                             C  ;               A CARRY OUT OF THE HIGH BYTE  C
				AN OCCUR. 
                             C  ;               IF THIS IS THE CASE, OUR CHOICE
				 AS TO WHICH WAS THE 
                             C  ;               LARGER NO. WAS INCORRECT AND WE
				 HAVE TO NEGATE 
                             C  ;               OUR MANTISSA AND COMPLEMENT THE
				 SIGN OF THE RESULT. 
                             C  ; 
                             C  ;       CALLING SEQUENCE        CALL    $FADDD 
                             C  ;               WITH THE NOS. TO BE ADDED/SUBTR
				ACTED IN THE DOUBLE 
                             C  ;               PRECISION FAC AND ARG 
                             C  ;THE FORMAT OF DOUBLE PRECISION NUMBERS IS AS F
				OLLOWS 
                             C  ;; 
                             C  ;BIT: 
                             C  ;66665555 55555544 44444444 33333333 33222222 2
				2221111 11111100 00000000 
                             C  ;32109876 54321098 76543210 98765432 10987654 3
				2109876 54321098 76543210 
                             C  ;AAAAAAAA BCCCCCCC CCCCCCCC CCCCCCCC CCCCCCCC C
				CCCCCCC CCCCCCCC CCCCCCCC 
                             C  ;[$FAC  ] [$FAC-1] [$FAC-2] [$FACLO] [$DFACL  [
				$DFACL  [$DFACL  [$DFACL] 
                             C  ;                                       +3  ]  
				  +2  ]    +1  ] 
                             C  ; 
                             C  ;WHERE A=EXPONENT BIASED 128 
                             C  ;      B=SIGN(1=NEGATIVE,0=POSITIVE) OF NUMBER 
                             C  ;      C=BITS 2-56 OF MANTISSA (BIT 1 IS UNDERS
				TOOD 1) 
                             C  ;        (ALSO BIT 54 IS HIGH ORDER BIT) 
                             C  ;NOTE:THE BINARY POINT IS TO THE LEFT OF THE UN
				DERSTOOD 1 
                             C  ; 
                             C  ;**********************************************
				****************** 
                             C   
 12D3  E8 09FA R             C  FADDX1: CALL	$MOVFA		;MOVE DOUBLE PREC ARG TO F
				AC 
 12D6  C3                    C  FADDX2: RET 
 12D7                        C  $FSUBD:			;($FAC):=($ARG)-($FAC) 
 12D7  A1 FFFF E             C  	MOV	AX,WORD PTR $FAC-1 
 12DA  0A E4                 C  	OR	AH,AH		;IF ZF=1 ARG IS ANSWER 
 12DC  74 F5                 C  	JZ	FADDX1 
 12DE  80 36 FFFF E 80       C  	XOR	BYTE PTR $FAC-1,LOW 200 ;FLIP SIGN OF FAC 
 12E3                        C  DADD: 
 12E3                        C  $FADDD:			;($FAC):=($ARG)+($FAC) 
 12E3  B0 00                 C  	MOV	AL,LOW 0	;WANT TO ZERO OVERFLOW BYTES 
 12E5  A2 FFFF E             C  	MOV	BYTE PTR $DFACL-1,AL 
 12E8  A2 FFFF E             C  	MOV	BYTE PTR $ARGLO-1,AL 
 12EB  A0 0000 E             C  	MOV	AL,BYTE PTR $ARG	;IF ($ARG)=0 THEN JUST RE
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-81
$FADDD  DOUBLE PRECISION FLOATING POINT ADDITION            

				T 
 12EE  0A C0                 C  	OR	AL,AL		; 
 12F0  74 E4                 C  	JZ	FADDX2		;RETURN 
 12F2  A1 FFFF E             C  	MOV	AX,WORD PTR $FAC-1	; 
 12F5  0A E4                 C  	OR	AH,AH		;IF EXPONENT=0, NO. IS ZERO 
 12F7  74 DA                 C  	JZ	FADDX1		;ARG IS THE ANSWER 
 12F9  8B 1E FFFF E          C  	MOV	BX,WORD PTR $ARG-1	;FETCH SIGN AND EXPONEN
				T 
 12FD  80 0E FFFF E 80       C  	OR	BYTE PTR $FAC-1,LOW 200 ;RESTORE HIDDEN 1 M
				ANTISSA BIT 
 1302  80 0E FFFF E 80       C  	OR	BYTE PTR $ARG-1,LOW 200 
 1307  8A CC                 C  	MOV	CL,AH		;WILL FORM SHIFT COUNT IN (CL) 
 1309  2A CF                 C  	SUB	CL,BH		; 
 130B  A2 0001 E             C  	MOV	BYTE PTR $FAC+1,AL	;ASSUME SIGN OF FAC 
 130E  74 22                 C  	JZ	FDD25		;PROCEED IF EXPONENTS EQUAL 
 1310  73 12                 C  	JNB	FDD20		;IF FAC LARGER (OR EQUAL) JUMP 
                             C  ;**********************************************
				********************** 
                             C  ; $ARG HAS THE LARGER EXPONENT SO WE MUST EXCHA
				NGE FAC AND ARG AND 
                             C  ;USE SIGN OF THE ARG 
                             C  ;**********************************************
				********************** 
 1312  86 C3                 C  	XCHG	AL,BL		;HIGH MANTISSA BYTE EXCHANGE 
 1314  F6 D9                 C  	NEG	CL		;NED POS. SHIFT COUNT 
 1316  A2 0001 E             C  	MOV	BYTE PTR $FAC+1,AL	;ADAPT ARG SIGN 
 1319  88 3E 0000 E          C  	MOV	BYTE PTR $FAC,BH	;ADAPT ARG EXPONENT 
 131D  50                    C  	PUSH	AX		;SAVE ARG MANTISSA BITS 
 131E  51                    C  	PUSH	CX		;WILL NEED AS COUNT FOR LOOP 
 131F  E8 09A0 R             C  	CALL	$XCGAF		;EXCHANGE ARG AND FAC 
 1322  59                    C  	POP	CX		;RECALL OLD CX 
 1323  58                    C  	POP	AX		;GET MANTISSA BYTES BACK 
 1324                        C  FDD20:				;WE NOW HAVE THE SUSPECTED LARGER NO 
				IN THE FAC, WE NEED 
                             C  				;TO KNOW IF WE ARE TO SUBTRACT (SIGNS ARE D
				IFFERENT) AND 
                             C  				;WE NEED TO RESTORE THE HIDDEN MANTISSA BIT
				 
                             C  				;FURTHER, IF THERE IS TO BE MORE THAN 56 BI
				TS SHIFTED 
                             C  				;TO ALIGN THE BINARY POINTS THEN THE LESSOR
				 NO. IS 
                             C  				;INSIGNIFICANT IN COMPARISON TO THE LARGER 
				NO. SO WE 
                             C  				;CAN JUST RETURN AND CALL THE LARGER NO. TH
				E ANSWER. 
 1324  80 F9 39              C  	CMP	CL,LOW 57D	;THIS MUST SET CF TO CONTINUE 
 1327  73 5E                 C  	JNB	FDD95		;RETURN IF CF=0 
 1329  53                    C  	PUSH	BX		;SAVE MANTISSA BITS 
 132A  F8                    C  	CLC			;SO WE DON'T GET CF IN THERE 
 132B  E8 0961 R             C  	CALL	$SHRA		;SHIFT ARG RIGHT (CL) BITS 
 132E  A0 0001 E             C  	MOV	AL,BYTE PTR $FAC+1	;RECALL SIGN (AL DESTRO
				YED 
                             C  				;BY $SHRA) 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-82
$FADDD  DOUBLE PRECISION FLOATING POINT ADDITION            

 1331  5B                    C  	POP	BX 
 1332  32 C3                 C  FDD25:	XOR	AL,BL		;WILL NOW DETERMINE IF ADD/SU
				B 
 1334  BB FFFF E             C  	MOV	BX,OFFSET $DFACL-1 
 1337  BE FFFF E             C  	MOV	SI,OFFSET $ARGLO-1 
 133A  B9 0004               C  	MOV	CX,4		;4 SIXTEEN BIT OPERATIONS 
 133D  F8                    C  	CLC			;CF=0 
                             C  ;**********************************************
				****************** 
                             C  ;WE ARE NOW STAGED TO DO THE ADD/SUBTRACT. IT W
				ILL BE DONE AS 4 
                             C  ;SIXTEEN BIT OPERATIONS. 
                             C  ;**********************************************
				****************** 
 133E  FC                    C  	CLD			;SO LODW WILL INCB 
                             C  				;Note 9-Aug-82/MLC - This CLD is 
                             C  				;for the LODWs at both FDD30 and 
                             C  				;FDD50. 
 133F  78 1E                 C  	JS	FDD50		;IF SF=1 GO SUBTRACT 
 1341  AD                    C  FDD30:	LODSW			;FETCH NEXT BYTE ARG 
                             C  				;Note 9-Aug-82/MLC - CLD is outside 
                             C  				;loop above. 
 1342  11 07                 C  	ADC	WORD PTR 0[BX],AX	;ADD IT TO FAC 
 1344  43                    C  	INC	BX 
 1345  43                    C  	INC	BX 
 1346  E2 F9                 C  	LOOP	FDD30 
 1348  73 12                 C  	JNB	FDD40		;GO ROUND IF CF=0 
                             C  ;**********************************************
				*************** 
                             C  ;WE HAD OVERFLOW OUT OF THE HIGH MANTISSA BIT. 
				WE MUST INCREMENT 
                             C  ;THE EXPONENT AND SHIFT THE OVERFLOW BIT BACK I
				NTO THE FAC BY 
                             C  ;SHIFTING THE FAC RIGHT 1 BIT. 
                             C  ;**********************************************
				*************** 
 134A  BB 0000 E             C  FDD35:	MOV	BX,OFFSET $FAC	;FETCH ADDRESS OF EXP
				ONENT 
 134D  FE 07                 C  	INC	BYTE PTR 0[BX]	;INCREMENT THE EXPONENT 
 134F  74 33                 C  	JZ	FDD90		;IF ZF=1 - OVERFLOW 
 1351  4B                    C  	DEC	BX 
 1352  4B                    C  	DEC	BX		;BX POINTS TO $FAC-2 
 1353  B9 0004               C  	MOV	CX,4		;4 SIXTEEN BIT SHIFTS 
                             C  ;**********************************************
				**************** 
                             C  ;WE ARE NOW SET TO SHIFT THE FAC RIGHT 1 BIT. R
				ECALL WE GOT HERE 
                             C  ;WITH CF=1. THE INSTRUCTIONS SINCE WE GOT HERE 
				HAVEN'T AFFECTED 
                             C  ;CF SO WHEN WE SHIFT RIGHT WE WILL SHIFT CF INT
				O THE HIGH MANTISSA 
                             C  ;BIT. 
                             C  ;**********************************************
				*************** 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-83
$FADDD  DOUBLE PRECISION FLOATING POINT ADDITION            

 1356  D1 1F                 C  FDD37:	RCR	WORD PTR 0[BX],1 
 1358  4B                    C  	DEC	BX 
 1359  4B                    C  	DEC	BX 
 135A  E2 FA                 C  	LOOP	FDD37 
 135C  E9 1F8C R             C  FDD40:	JMP	$ROUND		;GO ROUND THE RESULT 
 135F                        C  FDD50: 
                             C  ;**********************************************
				**************** 
                             C  ;TO GET HERE THE SIGNS OF THE FAC AND ARG WERE 
				DIFFERENT THUS 
                             C  ;IMPLYING A DESIRED SUBTRACT. 
                             C  ;**********************************************
				**************** 
 135F  AD                    C  	LODSW			;FETCH NEXT WORD OF ARG 
                             C  				;Note 9-Aug-82/MLC - The CLD is 
                             C  				;just above FDD30. 
 1360  19 07                 C  	SBB	WORD PTR 0[BX],AX	;SUBTRACT FROM FAC 
 1362  43                    C  	INC	BX 
 1363  43                    C  	INC	BX 
 1364  E2 F9                 C  	LOOP	FDD50 
 1366  73 19                 C  	JNB	FDD80		;GO NORMALIZE AND ROUND 
                             C  ;**********************************************
				************** 
                             C  ;TO GET HERE FAC TURNED OUT SMALLER THAN THE AR
				G. TO CORRECT 
                             C  ;THE ANSWER IN THE FAC WE MUST NEGATE THE MANTI
				SSA BITS 
                             C  ;AND THE SIGN IN $FAC+1 
                             C  ;**********************************************
				************* 
 1368  F6 57 01              C  	NOT	BYTE PTR 1[BX]	;COMPLEMENT SIGN 
 136B  B9 0004               C  	MOV	CX,4		;4 SIXTEEN BIT COMPLEMENTS 
 136E  4B                    C  FDD60:	DEC	BX 
 136F  4B                    C  	DEC	BX 
 1370  F7 17                 C  	NOT	WORD PTR 0[BX]	;COMPLEMENT FAC 
 1372  E2 FA                 C  	LOOP	FDD60 
                             C  ;**********************************************
				************* 
                             C  ;MUST NOW ADD 1 FOR 2'S COMPLEMENT ARITH. 
                             C  ;**********************************************
				************* 
 1374  B9 0004               C  	MOV	CX,4 
 1377  FF 07                 C  FDD70:	INC	WORD PTR 0[BX]	;IF ZF=1 THEN CARRY 
 1379  75 06                 C  	JNZ	FDD80		;SINCE THEY DON'T SET CF 
 137B  43                    C  	INC	BX 
 137C  43                    C  	INC	BX 
 137D  E2 F8                 C  	LOOP	FDD70 
 137F  74 C9                 C  	JZ	FDD35		;IF ZF=1 MUST INCREMENT EXP 
 1381  E9 1C99 R             C  FDD80:	JMP	$NORMD		;GO NORMALIZE 
 1384  E9 0775 R             C  FDD90:	JMP	$OVFLS		;OVERFLOW! 
 1387  E9 1FB4 R             C  FDD95:	JMP	$ROUNX		;PUT IN THE SIGN AND DONE 
                             C   
                             C  	SUBTTL	 $FADDS  SINGLE PRECISION FLOATING POIN
				T ADD/SUB 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-84
$FADDS  SINGLE PRECISION FLOATING POINT ADD/SUB             

                             C  ;**********************************************
				*********** 
                             C  ; 
                             C  ;       $FADDS  FLOATING POINT ADDITION FOR SIN
				GLE PRECISION 
                             C  ;               $FADDS FORMS THE SUM OF (BXDX) 
				AND ($FAC) AND 
                             C  ;               LEAVES THE RESULT IN THE ($FAC)
				. 
                             C  ; 
                             C  ;       CALLING SEQUENCE:       CALL    $FADDS 
                             C  ;       $FSUBS  FLOATING POINT SUBTRACTION FOR 
				SINGLE PRECISION 
                             C  ;               $FSUBS FORMS THE DIFFERENCE (BX
				DX)-(FAC) AND 
                             C  ;               LEAVES THE RESULT IN THE (FAC).
				 
                             C  ;       CALLING SEQUENCE:       CALL    $FSUBS 
                             C  ; 
                             C  ;**********************************************
				************ 
                             C   
 138A  89 1E FFFF E          C  FEXIT1: MOV	WORD PTR $FAC-1,BX	;MOV (BXDX) TO $
				FAC 
 138E  89 16 0000 E          C  	MOV	WORD PTR $FACLO,DX 
 1392  C3                    C  EXIT2:	RET 
 1393  A1 FFFF E             C  $FSUBS: MOV	AX,WORD PTR $FAC-1	;FETCH FAC 
 1396  0A E4                 C  	OR	AH,AH		;IF ZF=1 (BXDX) IS ANSWER 
 1398  74 F0                 C  	JZ	FEXIT1		;(BXDX) IS THE ANSWER 
 139A  80 36 FFFF E 80       C  	XOR	BYTE PTR $FAC-1,LOW 200 ;FLIP SIGN 
 139F                        C  $FADDS:			;($FAC)=(BXDX)+($FAC) 
 139F  0A FF                 C  	OR	BH,BH		;WILL FIRST CHECK EXPONENT OF (BXDX)
				 
 13A1  74 EF                 C  	JZ	EXIT2		;ANS ALREADY IN $FAC 
 13A3  A1 FFFF E             C  	MOV	AX,WORD PTR $FAC-1	;WILL NOW CHECK $FAC AN
				D IF ZERO 
 13A6  0A E4                 C  	OR	AH,AH		;ANSWER IN (BXDX) AND MUST MOVE 
 13A8  74 E0                 C  	JZ	FEXIT1		;MOVE (BXDX) TO FAC 
                             C  				;******************************************
				********** 
                             C  				;KNOW AT THIS POINT THAT NEITHER (BXDX) NOR
				 THE 
                             C  				;$FAC ARE ZERO. THE SUM WILL BE PERFORMED B
				Y EXAMINATION 
                             C  				;OF THE EXPONENTS, PLACING THE NUMBER WITH 
				THE LARGER 
                             C  				;EXPONENT IN THE $FAC,AND SHIFTING THE SMAL
				LER NUMBER RIGHT 
                             C  				;UNTIL BINARY POINTS ALIGN, THEN ADDING THE
				 MANTISSAS 
                             C  				;IF THE SIGNS ARE THE SAME OR SUBTRACTING T
				HE MANTISSAS 
                             C  				;IF THE SIGNS ARE DIFFERENT. THE EXPONENT O
				F THE ANSWER 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-85
$FADDS  SINGLE PRECISION FLOATING POINT ADD/SUB             

                             C  				;IS THE EXPONENT OF THE LARGER NUMBER. THE 
				FORMAT OF 
                             C  				;FLOATING POINT NUMBERS IS AS FOLLOWS: 
                             C  				; 
                             C  				;BIT    33222222 22221111 11111100 00000000
				 
                             C  				;       10987654 32109876 54321098 76543210
				 
                             C  				;       AAAAAAAA BCCCCCCC CCCCCCCC CCCCCCCC
				 
                             C  				;BYTE   [ $FAC ] [$FAC-1] [$FAC-2] [$FAC-3]
				 
                             C  				;                                  [$FACLO]
				 
                             C  				; 
                             C  				;WHERE  A=BITS OF EXPONENT BIASED BY 128 
                             C  				;       B=0 IF NUMBER IS POSITIVE,1 IF NEGA
				TIVE 
                             C  				;       C=BITS 2-24 OF MANTISSA(BIT 1 IS UN
				DERSTOOD 1) 
                             C  				;NOTE:THE BINARY POINT IS TO THE LEFT OF TH
				E UNDERSTOOD 1 
                             C  				; 
                             C  				;******************************************
				************ 
                             C   
 13AA  33 C9                 C  	XOR	CX,CX		;(CX)=0 
 13AC  8B 36 0000 E          C  	MOV	SI,WORD PTR $FACLO	;(SI)=($FAC-2,$FACLO) 
 13B0  A2 0001 E             C  	MOV	BYTE PTR $FAC+1,AL	;ASSUME SIGN OF $FAC 
 13B3  8A CC                 C  	MOV	CL,AH		;SINCE ASSUME $FAC LARGER 
 13B5  2A CF                 C  	SUB	CL,BH		;CL WILL HOLD SHIFT COUNT 
 13B7  73 0D                 C  	JNB	FA20		;JUMP IF $FAC EXP EQUAL OR LARGER 
 13B9  F6 D9                 C  	NEG	CL		;NEED POS. SHIFT COUNT 
 13BB  86 DF                 C  	XCHG	BL,BH 
 13BD  89 1E 0000 E          C  	MOV	WORD PTR $FAC,BX	;SINCE (BXDX) LARGER MAGN
				ITUDE 
 13C1  86 DF                 C  	XCHG	BL,BH		;GET EXP/SGN CORRECT AGAIN 
 13C3  93                    C  	XCHG	BX,AX		;WILL EXCHANGE (BXDX) AND (AXSI) 
 13C4  87 D6                 C  	XCHG	DX,SI		; 
 13C6                        C  FA20:				;*************************************
				******************* 
                             C  				;AT THIS POINT SUSPECTED LARGER NUMBER IS I
				N (AXSI) WITH 
                             C  				;SMALLER IN (BXDX). THIS WILL BE THE CASE U
				NLESS THE EXPONENTS 
                             C  				;WERE EQUAL. IF THE EXPONENTS WERE EQUAL AN
				D THIS IS 
                             C  				;TO BE A SUBTRACTION A NEGATIVE MANTISSA CO
				ULD RESULT. IF THIS 
                             C  				;HAPPENS, WE MUST COMPLEMENT THE MANTISSA A
				ND THE SIGN OF THE 
                             C  				;RESULT. 
                             C  				;******************************************
				************** 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-86
$FADDS  SINGLE PRECISION FLOATING POINT ADD/SUB             

 13C6  8A E0                 C  	MOV	AH,AL		;WILL NOW DETERMINE IF ADD OR 
 13C8  32 E3                 C  	XOR	AH,BL		;SUBTRACT 
 13CA  9C                    C  	PUSHF			;SF=1 IF SUBTRACT 
 13CB  B4 80                 C  	MOV	AH,LOW 200	;WILL REPLACE UNDERSTOOD 1 
 13CD  0A C4                 C  	OR	AL,AH 
 13CF  0A DC                 C  	OR	BL,AH 
 13D1  32 E4                 C  	XOR	AH,AH		;(AH) WILL BE OVERFLOW BYTE 
 13D3  8A FC                 C  	MOV	BH,AH		;(AH)=(BH)=0 
 13D5  0B C9                 C  FA22:	OR	CX,CX		;ZF=1 IF EXPONENTS THE SAME 
 13D7  74 51                 C  	JZ	FA40		;IF EXPONENTS SAME JUMP 
 13D9  83 F9 19              C  	CMP	CX,31		;MUST SEE IF WITHIN 24 BITS 
 13DC  72 12                 C  	JB	FA23		;IF SO PROCEED 
                             C  ;**********************************************
				*************** 
                             C  ;THE NUMBERS WE ARE TRYING TO ADD/SUBTRACT ARE 
				OF SUCH DIFFERENCE 
                             C  ;IN MAGNITUDE THAT THE SMALLER IS NEGLIGIBLE WI
				TH RESPECT TO THE 
                             C  ;LARGER. OUR ANSWER THEREFORE IS THE NUMBER WIT
				H THE ABSOLUTE 
                             C  ;LARGER MAGNITUDE. THE MANTISSA OF THIS NO. IS 
				IN (AL:SI) 
                             C  ;**********************************************
				**************** 
 13DE  9D                    C  	POPF			;CLEAR SUBTRACT/ADD FLAG 
 13DF  89 36 0000 E          C  	MOV	WORD PTR $FACLO,SI	;RESTORE LOWER MANTISSA
				 BITS 
 13E3  8A 26 0001 E          C  	MOV	AH,BYTE PTR $FAC+1	;FETCH SIGN 
 13E7  25 807F               C  	AND	AX,100177	;CLEAR SIGN IN AH, ALL BUT SIGN 
				IN AL 
 13EA  0A C4                 C  	OR	AL,AH		;RESTORE SIGN 
 13EC  A2 FFFF E             C  	MOV	BYTE PTR $FAC-1,AL	;$FAC NOW CORRECTLY BUI
				LT 
 13EF  C3                    C  	RET 
 13F0                        C  FA23: 
                             C  				;WILL TRY FOR BYTE MOVES 
 13F0  80 F9 08              C  	CMP	CL,LOW 10	;NEED AT LEAST 8 BITS 
 13F3  72 27                 C  	JB	FA27		;IF NOT PROCEED AS NORMAL 
 13F5  8B F8                 C  	MOV	DI,AX		;WILL WANT TO CHECK THIS FOR ST 
 13F7  8A E2                 C  	MOV	AH,DL		;SHIFT OVERFLOW BITS 
 13F9  F7 C7 FF00            C  	TEST	DI,177400O	;DID WE SHIFT THROUGH ST? 
 13FD  74 03                 C  	JZ	FA24 
 13FF  80 CC 20              C  	OR	AH,LOW 40	;PUT ST BACK IN 
 1402                        C  FA24: 
 1402  8A D6                 C  	MOV	DL,DH 
 1404  8A F3                 C  	MOV	DH,BL 
 1406  32 DB                 C  	XOR	BL,BL		;CLEAR UPPER BITS 
 1408  80 E9 08              C  	SUB	CL,LOW 10 
 140B  F6 C4 1F              C  	TEST	AH,LOW 37	;SHIFT THRU ST 
 140E  74 C5                 C  	JZ	FA22		;IF NOT TRY AGAIN 
 1410  80 CC 20              C  	OR	AH,LOW 40 
 1413  EB C0                 C  	JMP	SHORT FA22 
 1415  80 CC 20              C  FA25:	OR	AH,LOW 40	;"OR" IN ST BIT 
 1418  E2 03                 C  	LOOP	FA30		;CONTINUE LOOP 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-87
$FADDS  SINGLE PRECISION FLOATING POINT ADD/SUB             

 141A  EB 0E                 C  	JMP	SHORT FA40	;IF FINISHED JUMP 
 141C  F8                    C  FA27:	CLC			;MAKE SURE CARRY CLEAR BEFORE SHIFT
				 
 141D  D0 DB                 C  FA30:	RCR	BL,1 
 141F  D1 DA                 C  	RCR	DX,1 
 1421  D0 DC                 C  	RCR	AH,1		;SHIFT (BLDXAH)RIGHT ONE BIT 
 1423  F6 C4 10              C  	TEST	AH,LOW 20	;SEE IF ST SET 
 1426  75 ED                 C  	JNZ	FA25 
                             C  				;CARRY INTO HIGH BIT 
 1428  E2 F3                 C  	LOOP	FA30		;LOOP UNTIL (CX)=0 
 142A  9D                    C  FA40:	POPF			;IF SF=1 WE MUST SUBTRACT MANTISSA
				S 
 142B  79 25                 C  	JNS	FA50		;IF SF=0 GO ADD MANTISSAS 
 142D  2A CC                 C  	SUB	CL,AH		;SUBTRACT UNDERFLOW BYTE 
 142F  8A E1                 C  	MOV	AH,CL		;MUST GO TO NORMS WITH MANT. IN (BL
				DXCL) 
 1431  1B F2                 C  	SBB	SI,DX 
 1433  8B D6                 C  	MOV	DX,SI 
 1435  1A C3                 C  	SBB	AL,BL		;IF CARRY (CF) NOT SET THEN 
 1437  8A D8                 C  	MOV	BL,AL 
 1439  73 2F                 C  	JNB	FA90		;ASSUMPTION OF $FAC LARGER VALID 
 143B  F6 16 0001 E          C  	NOT	BYTE PTR $FAC+1 ;MUST USE OTHER SIGN $FAC 
				WASN'T 
 143F  F6 D4                 C  	NOT	AH		;LARGER 
 1441  F7 D2                 C  	NOT	DX 
 1443  F6 D3                 C  	NOT	BL 
 1445  FE C4                 C  	INC	AH		;INCREMENT BY ONE AND SET CARRY 
 1447  75 21                 C  	JNZ	FA90		;IF ZF=0 GO NORMALIZE 
 1449  42                    C  	INC	DX		;INCREMENT BY ONE 
 144A  75 1E                 C  	JNZ	FA90		;IF ZF=0 GO NORMALIZE 
 144C  FE C3                 C  	INC	BL		;INCREMENT BY ONE 
 144E  75 1A                 C  	JNZ	FA90		;IF ZF=0 GO NORMALIZE 
 1450  EB 06                 C  	JMP	SHORT FA60 
 1452                        C  FA50: 
                             C  ;**********************************************
				************** 
                             C  ;SIGNS OF THE NUMBERS WERE THE SAME SO WE ADD M
				ANTISSAS HERE 
                             C  ;**********************************************
				*************** 
 1452  03 D6                 C  	ADD	DX,SI		;ADDITION OF LOW BITS 
 1454  12 D8                 C  	ADC	BL,AL		;ADDITION OF HIGH BITS 
 1456  73 0C                 C  	JNB	FA70 
 1458                        C  FA60:				;HERE WHEN WE HAVE OVERFLOWED THE HIGH
				 MANTISSA BYTE 
                             C  				;AND MUST INCREMENT THE EXPONENT 
 1458  FE 06 0000 E          C  	INC	BYTE PTR $FAC	;INCREMENT THE EXPONENT 
 145C  74 09                 C  	JZ	FA80		;OVERFLOW! 
 145E  D0 DB                 C  	RCR	BL,1		;MUST SHIFT RIGHT ONE BIT 
 1460  D1 DA                 C  	RCR	DX,1 
 1462  D0 DC                 C  	RCR	AH,1 
 1464  E9 1FC6 R             C  FA70:	JMP	$ROUNS 
 1467  E9 0775 R             C  FA80:	JMP	$OVFLS		;DO OVERFLOW CODE 
 146A  E9 1CE4 R             C  FA90:	JMP	$NORMS		;GO NORMALIZE 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-88
$FADDS  SINGLE PRECISION FLOATING POINT ADD/SUB             

                             C   
                             C  	SUBTTL	 DDIV	 DOUBLE PRECISION DIVIDE (FAC)=(A
				RG)/(FAC) 
                             C  ;**********************************************
				******************* 
                             C  ; 
                             C  ;       $FDIVD  THIS ROUTINE DIVIDES THE ARG BY
				 THE FAC LEAVING THE 
                             C  ;               QUOTIENT IN THE FAC 
                             C  ;       CALLING SEQUENCE:       CALL    $FDIVD 
                             C  ; 
                             C  ;**********************************************
				********************* 
                             C   
 146D  E9 08A7 R             C  EXIT1:	JMP	$DZERO		;ZERO THE FAC 
 1470  79 FB                 C  DOVCKJ: JNS	EXIT1 
 1472  E9 0775 R             C  	JMP	$OVFLS 
 1475                        C  DDIV: 
 1475  BE 0000 E             C  DDIVFA: MOV	SI,OFFSET $DFACL 
 1478  BF 0000 E             C  	MOV	DI,OFFSET $ARGLO 
 147B  EB 06                 C  	JMP	SHORT $DDIV 
 147D                        C  $FDIVD: 
 147D  BE 0000 E             C  	MOV	SI,OFFSET $ARGLO 
 1480  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 1483                        C  $DDIV: 
 1483  8B 44 06              C  	MOV	AX,WORD PTR 6[SI]	;High half of numerator 
 1486  8B 4D 06              C  	MOV	CX,WORD PTR 6[DI]	;High half of denominato
				r 
 1489  32 C1                 C  	XOR	AL,CL		;Compute sign 
 148B  A2 0001 E             C  	MOV	BYTE PTR $FAC+1,AL	;and store in $FAC 
 148E  0A ED                 C  	OR	CH,CH		;Denominator zero? 
 1490  74 63                 C  	JZ	DDIV0 
 1492  0A E4                 C  	OR	AH,AH		;Numerator zero? 
 1494  74 D7                 C  	JZ	EXIT1 
 1496  80 EC 80              C  	SUB	AH,LOW 128D	;Remove bias from exponents 
 1499  80 ED 80              C  	SUB	CH,LOW 128D 
 149C  2A E5                 C  	SUB	AH,CH		;Compute result exponent 
 149E  70 D0                 C  	JO	DOVCKJ 
                             C   
                             C  ;AH has the (tentative) true exponent of the re
				sult. It is correct if the 
                             C  ;result needs normalizing one bit. If not, 1 wi
				ll be added to it. A true 
                             C  ;exponent of -128, not normally allowed except 
				to represent zero, is OK 
                             C  ;here because of this possible future increment
				ing. 
                             C   
 14A0  FC                    C  	CLD			;9-Aug-82/MLC - Good for the LODC, 
                             C  				;LODW, LODW, and LODW which follow. 
 14A1  80 C4 80              C  	ADD	AH,LOW 128D	;Put bias back 
 14A4  50                    C  	PUSH	AX		;SAVE sign and exponent 
 14A5  AC                    C  	LODSB			;Load up dividend 
 14A6  8A E8                 C  	MOV	CH,AL 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-89
DDIV	 DOUBLE PRECISION DIVIDE (FAC)=(ARG)/(FAC)             

 14A8  32 C9                 C  	XOR	CL,CL 
 14AA  AD                    C  	LODSW 
 14AB  93                    C  	XCHG	AX,BX 
 14AC  AD                    C  	LODSW 
 14AD  92                    C  	XCHG	AX,DX 
 14AE  AD                    C  	LODSW 
 14AF  80 CC 80              C  	OR	AH,LOW 200O	;Set implied bit 
 14B2  92                    C  	XCHG	AX,DX		;Divisor in DX:AX:BX:CX 
                             C   
                             C  ;Move divisor to FAC so we can get at it easily
				. More importantly, get it in 
                             C  ;the necessary form - extended to 64 bits with 
				zeros, implied bit set. 
                             C  ;The form we want it in will have the mantissa 
				MSB where the exponent usually 
                             C  ;is, so by moving high to low we will not destr
				oy the divisor even if it is 
                             C  ;already in the FAC. 
                             C   
 14B3  8B F7                 C  	MOV	SI,DI 
 14B5  83 C6 05              C  	ADD	SI,5		;Point to high end of divisor 
 14B8  BF FFFF E             C  	MOV	DI,OFFSET $FAC-1 
 14BB  FD                    C  	STD			;Direction DOWN 
 14BC  A5                    C  	MOVSW			;Move divisor to FAC 
 14BD  A5                    C  	MOVSW 
 14BE  A5                    C  	MOVSW 
 14BF  46                    C  	INC	SI 
 14C0  47                    C  	INC	DI 
 14C1  A4                    C  	MOVSB 
 14C2  FC                    C  	CLD			;DRESTR direction 
 14C3  C6 05 00              C  	MOV	BYTE PTR 0[DI],LOW 0	;Extend to 64 bits wi
				th a zero 
 14C6  80 0E 0000 E 80       C  	OR	BYTE PTR $FAC,LOW 200O	;Set implied bit 
                             C   
                             C  ;Now we're all set: 
                             C  ;       DX:AX:BX:CX has dividend 
                             C  ;       FAC has divisor (not in normal format) 
                             C  ;Both are extended to 64 bits with zeros and ha
				ve implied bit set. 
                             C  ;Top of stack has sign and tentative exponent. 
                             C   
 14CB  D1 EA                 C  	SHR	DX,1		;Make sure dividend is smaller than 
				divisor 
 14CD  D1 D8                 C  	RCR	AX,1		;   by dividing it by two 
 14CF  D1 DB                 C  	RCR	BX,1 
 14D1  D1 D9                 C  	RCR	CX,1 
 14D3  E8 14FB R             C  	CALL	DDIV16		;Get a quotient digit 
 14D6  57                    C  	PUSH	DI 
 14D7  E8 14FB R             C  	CALL	DDIV16 
 14DA  57                    C  	PUSH	DI 
 14DB  E8 14FB R             C  	CALL	DDIV16 
 14DE  57                    C  	PUSH	DI 
 14DF  E8 14FB R             C  	CALL	DDIV16 
 14E2  0B C3                 C  	OR	AX,BX		;Remainder zero? 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-90
DDIV	 DOUBLE PRECISION DIVIDE (FAC)=(ARG)/(FAC)             

 14E4  0B C1                 C  	OR	AX,CX 
 14E6  0B C2                 C  	OR	AX,DX 
 14E8  8B D7                 C  	MOV	DX,DI		;Get lowest word in position 
 14EA  74 03                 C  	JZ	DNSTK1 
 14EC  80 CA 01              C  	OR	DL,LOW 1	;Set sticky bit if not 
 14EF                        C  DNSTK1: 
 14EF  59                    C  	POP	CX		;Recover quotient digits 
 14F0  5B                    C  	POP	BX 
 14F1  5F                    C  	POP	DI 
 14F2  E9 157F R             C  	JMP	DNRMCHK 
                             C   
 14F5  A2 0001 E             C  DDIV0:	MOV	BYTE PTR $FAC+1,AL 
 14F8  E9 0786 R             C  	JMP	$DIV0S 
                             C   
 14FB                        C  DDIV16: 
 14FB  8B 36 0006 E          C  	MOV	SI,WORD PTR $DFACL+6	;Get high word of div
				isor 
 14FF  33 FF                 C  	XOR	DI,DI		;Initialize quotient digit to zero 
 1501  3B D6                 C  	CMP	DX,SI		;Will we overflow? 
 1503  73 5C                 C  	JAE	DMXQUO		;If so, go handle special 
 1505  0B D2                 C  	OR	DX,DX		;Is dividend small? 
 1507  75 04                 C  	JNZ	DODIV 
 1509  3B F0                 C  	CMP	SI,AX		;Will divisor fit at all? 
 150B  77 3B                 C  	JA	ZERQUO		;No - quotient is zero 
 150D                        C  DODIV: 
 150D  F7 F6                 C  	DIV	SI		;AX is our digit "guess" 
 150F  52                    C  	PUSH	DX		;SAVE remainder 
 1510  97                    C  	XCHG	AX,DI		;Quotient digit in DI 
 1511  33 ED                 C  	XOR	BP,BP		;Initialize quotient * divisor 
 1513  8B F5                 C  	MOV	SI,BP 
 1515  A1 0000 E             C  	MOV	AX,WORD PTR $DFACL 
 1518  0B C0                 C  	OR	AX,AX		;If zero, SAVE multiply time 
 151A  74 04                 C  	JZ	REM2 
 151C  F7 E7                 C  	MUL	DI		;Begin computing quotient * divisor 
 151E  8B F2                 C  	MOV	SI,DX 
 1520                        C  REM2: 
 1520  50                    C  	PUSH	AX		;SAVE lowest word of quotient * divis
				or 
 1521  A1 0002 E             C  	MOV	AX,WORD PTR $DFACL+2 
 1524  0B C0                 C  	OR	AX,AX 
 1526  74 06                 C  	JZ	REM3 
 1528  F7 E7                 C  	MUL	DI 
 152A  03 F0                 C  	ADD	SI,AX 
 152C  13 EA                 C  	ADC	BP,DX 
 152E                        C  REM3: 
 152E  A1 0004 E             C  	MOV	AX,WORD PTR $DFACL+4 
 1531  0B C0                 C  	OR	AX,AX 
 1533  74 08                 C  	JZ	REM4 
 1535  F7 E7                 C  	MUL	DI 
 1537  03 E8                 C  	ADD	BP,AX 
 1539  83 D2 00              C  	ADC	DX,0 
 153C  92                    C  	XCHG	AX,DX 
 153D                        C  REM4:				;Quotient * divisor in AX:BP:SI:[SP] 
 153D  5A                    C  	POP	DX		;Recover lowest word of quotient * div
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-91
DDIV	 DOUBLE PRECISION DIVIDE (FAC)=(ARG)/(FAC)             

				isor 
 153E  F7 DA                 C  	NEG	DX		;Subtract from dividend 
 1540  1B CE                 C  	SBB	CX,SI 
 1542  1B DD                 C  	SBB	BX,BP 
 1544  5D                    C  	POP	BP		;Remainder from DIV 
 1545  1B E8                 C  	SBB	BP,AX 
 1547  95                    C  	XCHG	AX,BP 
 1548                        C  ZERQUO:			;Remainder in AX:BX:CX:DX 
 1548  92                    C  	XCHG	AX,DX 
 1549  91                    C  	XCHG	AX,CX 
 154A  93                    C  	XCHG	AX,BX 
 154B  73 13                 C  	JNB	RETRES		;Remainder in DX:AX:BX:CX 
 154D                        C  DRESTR: 
 154D  4F                    C  	DEC	DI		;Drop quotient since it didn't fit 
 154E  03 0E 0000 E          C  	ADD	CX,WORD PTR $DFACL	;Add divisor back in un
				til remainder goes + 
 1552  13 1E 0002 E          C  	ADC	BX,WORD PTR $DFACL+2 
 1556  13 06 0004 E          C  	ADC	AX,WORD PTR $DFACL+4 
 155A  13 16 0006 E          C  	ADC	DX,WORD PTR $DFACL+6 
 155E  73 ED                 C  	JNB	DRESTR 
 1560  C3                    C  RETRES: RET 
                             C   
 1561                        C  DMXQUO: 
 1561  4F                    C  	DEC	DI		;DI=FFFF=2**16-1 
 1562  2B 0E 0000 E          C  	SUB	CX,WORD PTR $DFACL 
 1566  1B 1E 0002 E          C  	SBB	BX,WORD PTR $DFACL+2 
 156A  1B 06 0004 E          C  	SBB	AX,WORD PTR $DFACL+4 
 156E  03 0E 0002 E          C  	ADD	CX,WORD PTR $DFACL+2 
 1572  13 1E 0004 E          C  	ADC	BX,WORD PTR $DFACL+4 
 1576  13 C2                 C  	ADC	AX,DX 
 1578  8B 16 0000 E          C  	MOV	DX,WORD PTR $DFACL 
 157C  F5                    C  	CMC 
 157D  EB C9                 C  	JMP	SHORT ZERQUO 
 157F                        C  DNRMCHK: 
 157F  58                    C  	POP	AX		;Get exp. and sign back 
 1580  0B FF                 C  	OR	DI,DI		;See if normalized 
 1582  78 0F                 C  	JS	DINCEX		;Yes - increment exponent 
 1584  D1 E2                 C  	SHL	DX,1		;Normalize 
 1586  D1 D1                 C  	RCL	CX,1 
 1588  D1 D3                 C  	RCL	BX,1 
 158A  D1 D7                 C  	RCL	DI,1 
 158C  0A E4                 C  	OR	AH,AH 
 158E  75 07                 C  	JNZ	DDRND 
 1590  E9 08A7 R             C  	JMP	$DZERO 
 1593                        C  DINCEX: 
 1593  FE C4                 C  	INC	AH 
 1595  74 1E                 C  	JZ	DDOVFL 
 1597                        C  $DROUND: 
 1597                        C  DDRND: 
 1597  80 FA 80              C  	CMP	DL,LOW 200O	;Check extended bits 
 159A  77 07                 C  	JA	FPRNDUP 
 159C  72 1A                 C  	JB	DDSV 
                             C  ;Extended bits equal exactly one-half LSB, so r
				ound even 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-92
DDIV	 DOUBLE PRECISION DIVIDE (FAC)=(ARG)/(FAC)             

 159E  F6 C6 01              C  	TEST	DH,LOW 1	;Already even? 
 15A1  74 15                 C  	JZ	DDSV 
 15A3                        C  FPRNDUP: 
 15A3  80 C6 01              C  	ADD	DH,LOW 1 
 15A6  83 D1 00              C  	ADC	CX,0 
 15A9  83 D3 00              C  	ADC	BX,0		;Propagate carry 
 15AC  83 D7 00              C  	ADC	DI,0 
 15AF  73 07                 C  	JNB	DDSV		;Overflow? 
                             C  ;If we overflowed, DI:BX:CX:DH must now be zero
				, so we can leave it that way. 
 15B1  FE C4                 C  	INC	AH		;Increment exponent 
 15B3  75 03                 C  	JNZ	DDSV 
 15B5  E9 0775 R             C  DDOVFL: JMP	$OVFLS 
 15B8                        C  DDSV: 
 15B8  24 80                 C  	AND	AL,LOW 200O	;Strip to sign bit 
 15BA  87 DF                 C  	XCHG	BX,DI 
 15BC  80 E7 7F              C  	AND	BH,LOW 177O	;Mask off implied bit 
 15BF  0A C7                 C  	OR	AL,BH		;Combine sign with mantissa 
 15C1  A3 0006 E             C  	MOV	WORD PTR $DFACL+6,AX 
 15C4  88 1E FFFE E          C  	MOV	BYTE PTR $FAC-2,BL 
 15C8  8B DF                 C  	MOV	BX,DI 
 15CA  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 15CD  8A C6                 C  	MOV	AL,DH 
 15CF  FC                    C  	CLD 
 15D0  AA                    C  	STOSB 
 15D1  91                    C  	XCHG	AX,CX 
 15D2  AB                    C  	STOSW 
 15D3  93                    C  	XCHG	AX,BX 
 15D4  AB                    C  	STOSW 
 15D5  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 SDIV	 SINGLE PRECISION FLOATING POINT 
				DIVIDE 
                             C  ;**********************************************
				****************** 
                             C  ; 
                             C  ;       $FDIVS  THIS ROUTINE FORMS THE QUOTIENT
				 (BXDX)/(FAC) 
                             C  ;               AND RETURNS IT TO THE FAC 
                             C  ; 
                             C  ;**********************************************
				******************** 
                             C   
                             C  ;$DIV0S IS THE DIVIDE BY ZERO ENTRY INTO OVERFL
				OW CODE 
                             C  ;$SIGNS WILL SET THE CONDITION CODES ACCORDING 
				TO THE VALUE OF THE 
                             C  ;       FAC,I.E. ZF=1 IF (FAC)=0, SF=1 IF FAC N
				EGATIVE, AND NEITHER 
                             C  ;       OF THESE IF (FAC) GREATER THAN 0 
                             C  ;$ZERO CLEARS THE 4 BYTES OF THE FAC 
 15D6  E8 08BE R             C  $FDIVS: CALL	$SIGNS		;MUST BE SURE (FAC) NOT ZE
				RO 
 15D9  75 07                 C  	JNZ	FDS00 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-93
SDIV	 SINGLE PRECISION FLOATING POINT DIVIDE                

 15DB  88 1E 0001 E          C  	MOV	BYTE PTR $FAC+1,BL	;PUT IN FOR CORRECT OVE
				RFLOW SIGN 
 15DF  E9 0786 R             C  	JMP	$DIV0S		;IF SO OVERFLOW! 
 15E2                        C  FDS00: 
 15E2  0A FF                 C  	OR	BH,BH		;IF (BXDX)=0 ANSWER IS ZERO 
 15E4  75 03                 C  	JNZ	FDS10		;PROCEED IF (BXDX) NON-ZERO 
 15E6  E9 08B4 R             C  FDS05:	JMP	$ZERO 
 15E9                        C  FDS10: 
 15E9  89 16 0000 E          C  	MOV	WORD PTR $DFACL,DX	;WILL PUT NUMERATOR IN 
				$DFAC 
 15ED  89 1E 0002 E          C  	MOV	WORD PTR $DFACL+2,BX 
 15F1  BE 0000 E             C  	MOV	SI,OFFSET $DFACL 
 15F4  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
                             C  ;***  $SDIV - Single precision divide 
                             C  ; 
                             C  ; Inputs: 
                             C  ;       SI = Address of Dividend (Numerator) 
                             C  ;       DI = Address of Divisor (Denominator) 
                             C  ; Function: 
                             C  ;       FAC = 0(.SI) / 0(.DI) 
                             C  ; Outputs: 
                             C  ;       Result in FAC. 
                             C  ; Registers: 
                             C  ;       All except BP destroyed. 
                             C   
 15F7                        C  $SDIV: 
 15F7  8B 4D 02              C  	MOV	CX,WORD PTR 2[DI]	;Exponent and sign of de
				nominator 
 15FA  8B 44 02              C  	MOV	AX,WORD PTR 2[SI]	;Exponent and sign of nu
				merator 
 15FD  32 C1                 C  	XOR	AL,CL		;Compute sign 
 15FF  A2 0001 E             C  	MOV	BYTE PTR $FAC+1,AL	;Save sign in case OVER
				FLOW 
 1602  80 EC 80              C  	SUB	AH,LOW 128D	;Remove bias from exponents 
 1605  80 ED 80              C  	SUB	CH,LOW 128D 
 1608  2A E5                 C  	SUB	AH,CH		;Compute result exponent 
 160A  70 33                 C  	JO	OVCHKJ 
                             C   
                             C  ;AH has the (tentative) true exponent of the re
				sult. It is correct if the 
                             C  ;result needs normalizing one bit. If not, 1 wi
				ll be added to it. A true 
                             C  ;exponent of -128, not normally allowed except 
				to represent zero, is OK 
                             C  ;here because of this possible future increment
				ing. 
                             C   
 160C  80 C4 80              C  	ADD	AH,LOW 128D	;Put bias back 
 160F  50                    C  	PUSH	AX		;Save sign and exponent 
 1610  80 C9 80              C  	OR	CL,LOW 200O	;Set implied bit 
 1613  8B 54 01              C  	MOV	DX,WORD PTR 1[SI]	;Most significant part o
				f numerator mantissa 
 1616  8A 24                 C  	MOV	AH,BYTE PTR 0[SI]	;Least significant part 
 1618  32 C0                 C  	XOR	AL,AL		;Extend with zero 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-94
SDIV	 SINGLE PRECISION FLOATING POINT DIVIDE                

 161A  80 CE 80              C  	OR	DH,LOW 200O	;And set implied bit 
 161D  8B 5D 01              C  	MOV	BX,WORD PTR 1[DI]	;Load denominator into B
				X:CX 
 1620  8A 2D                 C  	MOV	CH,BYTE PTR 0[DI] 
 1622  32 C9                 C  	XOR	CL,CL 
 1624  80 CF 80              C  	OR	BH,LOW 200O 
                             C   
                             C  ;Now we have the following configuration: 
                             C  ;       Numerator in DX:AX 
                             C  ;       Denominator in BX:CX 
                             C  ; Both are extended to 32 bits with trailing ze
				ros and have implied bit set 
                             C  ;       Result will go in BX:DX 
                             C  ; 
                             C  ;The algorithm used here is similar to Algorith
				m D, p.237, Knuth vol. 2. 
                             C  ;It is basically just ordinary long division, e
				xcept the base is 2^16. This 
                             C  ;means we are dividing two 2-digit numbers, whe
				re each "digit" takes a whole 
                             C  ;word. We "guess" at a quotient digit, multiply
				 it by the divisor, and subtract 
                             C  ;from the current dividend to get a remainder. 
				This remainder could be 
                             C  ;negative, so we try a quotient digit one small
				er. 
                             C  ; 
                             C  ;The "guess" at the quotient digit simply uses 
				the 8086 DIV instruction. 
                             C  ;Computing the remainder takes advantage of the
				 remainder from this divide. If 
                             C  ;the remainder comes out negative, new quotient
				 digits are tried by repeated 
                             C  ;addition, rather than another multiply. Theore
				m B on p.237 of Knuth vol. 2 
                             C  ;guarantees that this repeated addition will ha
				ppen no more than twice. 
                             C   
 1627  D1 EA                 C  	SHR	DX,1 
 1629  D1 D8                 C  	RCR	AX,1		;Ensure DX<BX so divide won't OVERFL
				OW 
 162B  E8 164B R             C  	CALL	DIV16		;Get first 16 bits of quotient 
 162E  56                    C  	PUSH	SI		;Save high half of quotient on stack 
 162F  E8 1647 R             C  	CALL	CDIV16		;Get second 16 bits of quotient 
 1632  0B C2                 C  	OR	AX,DX		;Remainder 0? 
 1634  8B D6                 C  	MOV	DX,SI		;Want low half of result in DX 
 1636  74 03                 C  	JZ	NSTK1 
 1638  80 CA 01              C  	OR	DL,LOW 1	;Set sticky bit if remainder not z
				ero 
 163B                        C  NSTK1: 
 163B  5B                    C  	POP	BX		;Recover high half of result 
 163C  EB 2A 90              C  	JMP	NORMCHK 
                             C   
 163F                        C  OVCHKJ: 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-95
SDIV	 SINGLE PRECISION FLOATING POINT DIVIDE                

 163F  79 A5                 C  	JNS	FDS05		;ZERO THE FAC 
 1641                        C  SDIVOVFL: 
 1641  E9 0775 R             C  	JMP	$OVFLS		;OVERFLOW 
 1644  E9 0786 R             C  DIV0:	JMP	$DIV0S 
                             C   
 1647                        C  CDIV16: 
 1647  3B D3                 C  	CMP	DX,BX		;Will we OVERFLOW on divide? 
 1649  73 5B                 C  	JAE	MAXQUO		;Special code for maximum quotient
				 
 164B                        C  DIV16: 
 164B  F7 F3                 C  	DIV	BX		;32 by 16 bit division 
 164D  96                    C  	XCHG	AX,SI		;Put 16-bit quotient in SI 
 164E  33 C0                 C  	XOR	AX,AX		;DX:AX has remainder 
 1650  E3 15                 C  	JCXZ	RETJ		;Is this complete result? 
 1652  8B FA                 C  	MOV	DI,DX		;Save remainder while we multiply 
 1654  8B C6                 C  	MOV	AX,SI 
 1656  F7 E1                 C  	MUL	CX		;Low half of divisor times quotient 
 1658  F7 D8                 C  	NEG	AX		;Subtract from remainder, whose low ha
				lf is 0 
 165A  1B FA                 C  	SBB	DI,DX 
 165C  8B D7                 C  	MOV	DX,DI		;Remainder again in DX:AX 
 165E  73 07                 C  	JNB	RETJ		;If not negative, divide was good 
 1660                        C  RESTORE: 
 1660  4E                    C  	DEC	SI		;Quotient is too big 
 1661  03 C1                 C  	ADD	AX,CX		;And remainder too small (negative)
				 
 1663  13 D3                 C  	ADC	DX,BX		;So add divisor back in till positi
				ve 
 1665  73 F9                 C  	JNB	RESTORE 
 1667  C3                    C  RETJ:	RET 
 1668                        C  NORMCHK: 
 1668  58                    C  	POP	AX		;Get exp. and sign back 
 1669  0A FF                 C  	OR	BH,BH		;See if normalized 
 166B  78 0B                 C  	JS	INCEXP		;Yes-increment exponent 
 166D  D1 E2                 C  	SHL	DX,1		;Normalize 
 166F  D1 D3                 C  	RCL	BX,1 
 1671  0A E4                 C  	OR	AH,AH		;test exponent 
 1673  75 07                 C  	JNZ	ROUND		;brif exponent not zero 
 1675  E9 08B4 R             C  	JMP	$ZERO		;underflow if exponent zero 
                             C   
 1678                        C  INCEXP: 
 1678  FE C4                 C  	INC	AH 
 167A  74 C5                 C  	JZ	SDIVOVFL 
 167C                        C  $SRND: 
                             C  ;Round single precision and store in $FACLO 
                             C   
 167C                        C  ROUND: 
 167C  80 FA 80              C  	CMP	DL,LOW 200O	;Check extended bits 
 167F  77 07                 C  	JA	ROUNDUP 
 1681  72 11                 C  	JB	SAVE 
                             C  ;Extended bits equal exactly one-half LSB, so r
				ound even 
 1683  F6 C6 01              C  	TEST	DH,LOW 1	;Already even? 
 1686  74 0C                 C  	JZ	SAVE 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-96
SDIV	 SINGLE PRECISION FLOATING POINT DIVIDE                

 1688                        C  ROUNDUP: 
 1688  80 C6 01              C  	ADD	DH,LOW 1 
 168B  83 D3 00              C  	ADC	BX,0		;Propagate carry 
 168E  73 04                 C  	JNB	SAVE		;OVERFLOW? 
                             C  ;If we OVERFLOWed, BX:DH must now be zero, so w
				e can leave it that way. 
 1690  FE C4                 C  	INC	AH		;Increment exponent 
 1692  74 AD                 C  	JZ	SDIVOVFL 
 1694                        C  SAVE: 
 1694  24 80                 C  	AND	AL,LOW 200O	;Strip to sign bit 
 1696  80 E7 7F              C  	AND	BH,LOW 177O	;Mask off implied bit 
 1699  0A C7                 C  	OR	AL,BH		;Combine sign with mantissa 
 169B  A3 0002 E             C  	MOV	WORD PTR $FACLO+2,AX 
 169E  8A E3                 C  	MOV	AH,BL 
 16A0  8A C6                 C  	MOV	AL,DH 
 16A2  A3 0000 E             C  	MOV	WORD PTR $FACLO,AX	;Save lower part of man
				tissa 
 16A5  C3                    C  	RET 
 16A6                        C  MAXQUO: 
                             C  ;Come here if divide instruction would OVERFLOW
				. This must mean that DX=BX, 
                             C  ;i.e., the high half of the divisor and dividen
				d are equal. Assume a result 
                             C  ;of (2^16)-1, which will give us a remainder eq
				ual to divisor plus (low half 
                             C  ;of dividend minus low half of divisor, times 2
				^16). 
                             C   
 16A6  BE FFFF               C  	MOV	SI,-1		;Quotient of (2^16)-1 
 16A9  2B C1                 C  	SUB	AX,CX		;Dividend - divisor (always negativ
				e) 
 16AB  03 D0                 C  	ADD	DX,AX		;Add to high half of divisor 
 16AD  8B C1                 C  	MOV	AX,CX 
 16AF  73 AF                 C  	JNB	RESTORE	;Carry means it's not negative any
				 more 
 16B1  C3                    C  	RET 
                                 
                             C  	include	math2.asm 
                             C  	SUBTTL	 $FIDIG  ADD TEXT DIGIT TO CURRENT ACCU
				MULATED NUMBER 
                             C  ;**********************************************
				***************** 
                             C  ; 
                             C  ;       $FIDIG  CONVERTS DIGIT POINTED TO BY (B
				X) TO BINARY 
                             C  ;               VALUE AND ADDS TO NUMBER ACCUMU
				LATED. AT THE 
                             C  ;               APPROPRIATE TIMES CONVERSION WI
				LL TAKE 
                             C  ;               PLACE TO THE NEXT HIERARCHY OF 
				NUMBERS,I.E. 
                             C  ;               INTEGER-SINGLE PRECISION-DOUBLE
				 PRECISION. 
                             C  ;       CALLING SEQUENCE:       CALL    $FIDIG 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-97
$FIDIG  ADD TEXT DIGIT TO CURRENT ACCUMULATED NUMBER        

                             C  ;               WITH (BX) POINTING TO NUMBER IN
				 THE 
                             C  ;               TEXT BUFFER. NUMBER IS ACCUMULA
				TED IN THE FAC. 
                             C  ; 
                             C  ;**********************************************
				****************** 
                             C   
                             C  ;**********************************************
				******************** 
                             C  ;AS $FIDIG IS ENTERED CF=1 AND (DI) WILL HOLD P
				LACES TO THE RIGHT OF 
                             C  ;DECIMAL POINT (IF DECIMAL POINT HAS OCCURRED).
				(CX) WILL BE EITHER 
                             C  ;ALL BITS SET OR ALL BITS CLEARED. ALL BITS SET
				 INDICATES A DECIMAL 
                             C  ;POINT HAS NOT BEEN SEEN YET AND (CX)=0 INDICAT
				ES D. P. SEEN 
                             C  ;**********************************************
				******************** 
 16B2  13 F9                 C  $FIDIG: ADC	DI,CX		;(DI) INCREMENTED ONLY IF D.
				P. SEEN 
 16B4  53                    C  	PUSH	BX		;MUST NOW SAVE ALL NECESSARY REGS. 
 16B5  57                    C  	PUSH	DI 
 16B6  51                    C  	PUSH	CX 
 16B7  2C 30                 C  	SUB	AL,LOW "0"      ;SUBTRACT OUT ASCII BIAS 
 16B9  50                    C  	PUSH	AX		;SAVE ON STACK 
 16BA  E8 08EE R             C  	CALL	$GETYP		;SET CONDITION CODES 
 16BD  58                    C  	POP	AX		;RECALL DIGIT 
 16BE  98                    C  	CBW			;ZERO AH 
 16BF  79 1E                 C  	JNS	FI05		;MUST BE S.P. OR D.P. ALREADY 
 16C1  8B 1E 0000 E          C  	MOV	BX,WORD PTR $FACLO	;FETCH THE INTEGER ALRE
				ADY ACCUM. 
 16C5  81 FB 0CCD            C  	CMP	BX,3277D	;IS IT ALREADY TOO BIG TO ADD 
                             C  				;ANOTHER DIGIT TO? 
 16C9  73 19                 C  	JNB	FFI10		;IF SO GO MAKE S.P. FIRST 
 16CB  8B CB                 C  	MOV	CX,BX		;SAVE ORIGINAL (BX) 
 16CD  D1 E3                 C  	SHL	BX,1		;(BX)=(BX)*2 
 16CF  D1 E3                 C  	SHL	BX,1		;(BX)=(BX)*4 
 16D1  03 D9                 C  	ADD	BX,CX		;(BX)=(BX)*5 
 16D3  D1 E3                 C  	SHL	BX,1		;(BX)=(BX)*10 
 16D5  03 D8                 C  	ADD	BX,AX		;ADD IN THE DIGIT 
 16D7  78 0B                 C  	JS	FFI10		;IF SF=1 WE HAVE 32768 OR 32769 
 16D9  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX	;STORE IN $FAC 
 16DD  EB 48                 C  	JMP	SHORT FI50 
 16DF                        C  FI05:				;TO GET HERE NUMBER WAS ALREADY S.P. O
				R D.P. 
 16DF  50                    C  	PUSH	AX		;SAVE THE NUMBER 
 16E0  72 08                 C  	JB	FFFI20		;IT'S CURRENTLY SINGLE PRECISION 
 16E2  EB 33                 C  	JMP	SHORT FI40	;DOUBLE PRECISION 
 16E4                        C  FFI10:				;TO GET HERE NUMBER WAS PREVIOUSLY AN
				 INTEGER BUT HAS 
                             C  				;GROWN TOO LARGE - MUST MAKE IT SINGLE PREC
				ISION 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-98
$FIDIG  ADD TEXT DIGIT TO CURRENT ACCUMULATED NUMBER        

 16E4  50                    C  	PUSH	AX		;SAVE THE NUMBER 
 16E5  E8 17E5 R             C  	CALL	$CSI		;CONVERT INTEGER TO S.P. 
 16E8  EB 14                 C  	JMP	SHORT FI30	;MUL BY 10 AND ADD IN DIGIT 
 16EA                        C  FFFI20:			;TO GET HERE NUMBER WAS ALREADY SINGL
				E PRECISION 
                             C  				;MUST CHECK TO SEE IF ACCURACY MIGHT BE LOS
				T IF WE 
                             C  				;MULTIPLY OUR FAC BY 10,I.E. FAC MUST BE SM
				ALLER 
                             C  				;THAN 1000000. 
 16EA  C7 06 0004 E 2400     C  	MOV	WORD PTR $DBUFF+4,22000 
 16F0  C7 06 0006 E 9474     C  	MOV	WORD PTR $DBUFF+6,112164 
 16F6  BB 0006 E             C  	MOV	BX,OFFSET $DBUFF+6 
 16F9  E8 0A80 R             C  	CALL	$COMPM		;COMPARE TO $FAC 
 16FC  79 16                 C  	JNS	FI35		;GO DO D.P. IF TOO LARGE FOR S.P. 
 16FE  E8 091E R             C  FI30:	CALL	$MUL10		;MULTIPLY $FAC BY 10 
 1701  5A                    C  	POP	DX		;RECALL DIGIT 
 1702  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 1706  FF 36 FFFF E          C  	PUSH	WORD PTR $FAC-1 ;FAC PUSHED ON STACK 
 170A  E8 184E R             C  	CALL	$FLT		;CONVERT INTEGER TO S.P. 
 170D  5B                    C  	POP	BX		;RECALL FAC 
 170E  5A                    C  	POP	DX 
 170F  E8 139F R             C  	CALL	$FADDS		;ADD IN THE NEW DIGIT 
 1712  EB 13                 C  	JMP	SHORT FI50	;GET STACK RIGHT AND RETURN 
 1714                        C  FI35:				;TO GET HERE WE ALREADY HAVE 7 DIGITS 
				AND WOULD 
                             C  				;HAVE A LOSS OF ACCURACY IF WE CONTINUED IN
				 S.P. SO WE 
                             C  				;NEED TO CONVERT TO D.P. MULTIPLY BY 10 AND
				 ADD IN THE DIG. 
 1714  E8 17D7 R             C  	CALL	$CDS		;CONVERT THE SINGLE TO D.P. 
 1717  E8 091E R             C  FI40:	CALL	$MUL10		;MULTIPLY BY 10 
 171A  E8 09E7 R             C  	CALL	$MOVAF		;MOVE $FAC TO $ARG 
 171D  5A                    C  	POP	DX		;RECALL DIGIT 
 171E  E8 184E R             C  	CALL	$FLT		;CONVERT TO S.P. 
 1721  E8 17D7 R             C  	CALL	$CDS		;CONVERT TO D.P. 
 1724  E8 12E3 R             C  	CALL	$FADDD		;ADD IN THE OLD ACCUMULATED VALUE
				 
 1727  59                    C  FI50:	POP	CX		;GET DECIMAL POINT FLAG BACK 
 1728  5F                    C  	POP	DI		;GET NO. DIGITS TO RIGHT OF DECIMAL PT
				. 
 1729  5B                    C  	POP	BX		;GET TEXT POINTER BACK 
 172A  C3                    C  	RET			;COMPLETE 
                             C   
                             C  	SUBTTL	 $FINEX  EXPONENT INPUT ROUTINE 
                             C  ;**********************************************
				*************** 
                             C  ; 
                             C  ;       $FINEX  THE PURPOSE OF THIS ROUTINE IS 
				TO DETERMINE 
                             C  ;               THE INPUT EXPONENT BASE 10 AND 
				LEAVE IN (DX). 
                             C  ;               ADDITIONALLY IF A MINUS "-" SIG
				N IS ENCOUNTERED 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-99
$FINEX  EXPONENT INPUT ROUTINE                              

                             C  ;               $FINEX WILL SET ALL BITS OF (SI
				). OTHERWISE ALL 
                             C  ;               BITS OF (SI) WILL BE CLEARED. 
                             C  ;       CALLING SEQUENCE:       CALL    $FINEX 
                             C  ;               WITH THE SIGNIFICANT DIGITS OF 
				THE NUMBER IN 
                             C  ;               THE FAC. 
                             C  ; 
                             C  ;**********************************************
				***************** 
                             C   
 172B  9F                    C  $FINEX: LAHF			;SAVE STATUS 
 172C  80 3E 0000 E 08       C  	CMP	BYTE PTR $VALTP,LOW 10	;SEE IF ALREADY D.P
				. 
 1731  75 04                 C  	JNZ	EXA 
 1733  9E                    C  	SAHF			;GET STACK RIGHT 
 1734  EB 09 90              C  	JMP	EXB 
 1737  9E                    C  EXA:	SAHF			;RESTORE CODES 
 1738  53                    C  	PUSH	BX		;SAVE IMPORTANT REGISTERS 
 1739  57                    C  	PUSH	DI		;PRECISION ACCORDING TO ZF. IF 
 173A  E8 1797 R             C  	CALL	$FINFC		;ZF=1 S.P.:ZF=0 THEN D.P. 
 173D  5F                    C  	POP	DI		;RECALL DIGITS TO RIGHT OF D.P. 
 173E  5B                    C  	POP	BX		;RECALL TEXT POINTER 
 173F  33 F6                 C  EXB:	XOR	SI,SI		;IN CASE EXPONENT IS POSITIVE 
 1741  8B D6                 C  	MOV	DX,SI		;WILL BUILD EXPONENT IN DX 
 1743  E8 0E5B R             C  	CALL	$CHRGT		;GET FIRST CHARACTER OF EXPONENT 
 1746  72 13                 C  	JB	FX20		;NO SIGN SO DEFAULT POS. 
 1748  3C 2D                 C  	CMP	AL,LOW "-"      ;NEGATIVE EXPONENT 
 174A  75 04                 C  	JNZ	FX00		;IF NOT MUST BE POSITIVE 
 174C  F7 D6                 C  	NOT	SI		;NEGATIVE EXPONENT 
 174E  EB 05                 C  	JMP	SHORT FX10	;GO GET NEXT CHARACTER 
 1750  3C 2B                 C  FX00:	CMP	AL,LOW "+" 
 1752  74 01                 C  	JZ	FX10 
                             C  				;ILLEGAL CHARACTER MUST LEAVE 
 1754  C3                    C  	RET			;(BX) POINTING HERE 
 1755  E8 0E5B R             C  FX10:	CALL	$CHRGT		;GET NEXT CHARACTER 
 1758  72 01                 C  	JB	FX20		;IF DIGIT PROCESS AS EXPONENT 
 175A  C3                    C  	RET			;OTHERWISE RETURN 
 175B  81 FA 0CCC            C  FX20:	CMP	DX,3276D	;OVERFLOW IF THIS DOESN'T GE
				T CF=1 
 175F  72 05                 C  	JB	FX30		;NO-USE THIS DIGIT 
 1761  BA 7FFF               C  	MOV	DX,32767D	;TO ASSURE OVERFLOW 
 1764  EB EF                 C  	JMP	SHORT FX10 
 1766  50                    C  FX30:	PUSH	AX		;SAVE NEW DIGIT 
 1767  B8 000A               C  	MOV	AX,10D		;MUST MULTIPLY DX BY 10 
 176A  F7 E2                 C  	MUL	DX		;ANSWER NOW IN AX 
 176C  5A                    C  	POP	DX		;RECALL DIGIT TO DX 
 176D  80 EA 30              C  	SUB	DL,LOW 60	;SUBTRACT OUT ASCII BIAS 
 1770  32 F6                 C  	XOR	DH,DH		;TO BE SURE AX HAS CORRECT NO. 
 1772  03 D0                 C  	ADD	DX,AX		;ADD TO DX 
 1774  EB DF                 C  	JMP	SHORT FX10 
                             C   
                             C  	SUBTTL	 FINFC	 INPUT FORCE ROUTINES FOR "#","%
				","!" 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-100
FINFC	 INPUT FORCE ROUTINES FOR "#","%","!"                 

                             C  ;**********************************************
				*********** 
                             C  ; 
                             C  ;       FINFC   THIS MODULE CONTAINS THE ROUTIN
				ES $FINI, 
                             C  ;               $FIND, AND $FINS FOR FORCING TH
				E INPUT TO 
                             C  ;               INTEGER, DOUBLE PRECISION OR SI
				NGLE PRECISION 
                             C  ;               RESPECTIVELY IN RESPONSE TO AN 
				INPUT "$","#", OR 
                             C  ;               "!". ADDITIONALLY THIS MODULE C
				ONTAINS 
                             C  ;               THE UTILITY ROUTINES $FI,$FS,$F
				D,$CSI,$CSD,$CDS 
                             C  ;               FOR FORCING INTEGER,SINGLE,DOUB
				LE,CONVERTING 
                             C  ;               INTEGER TO SINGLE,CONVERTING DO
				UBLE TO SINGLE, AND 
                             C  ;               CONVERTING SINGLE TO DOUBLE, RE
				SPECTIVELY 
                             C  ;       CALLING SEQUENCE:       CALL    $FINI 
                             C  ;               OR              CALL    $FIND 
                             C  ;               OR              CALL    $FINS 
                             C  ;               OR              CALL    $FS 
                             C  ;               OR              CALL    $FD 
                             C  ;               OR              CALL    $FI 
                             C  ;               OR              CALL    $CSI 
                             C  ;               OR              CALL    $CSD 
                             C  ;               OR              CALL    $CDS 
                             C  ;               WITH THE FAC CONTAINING THE CUR
				RENT ACCUMULATED 
                             C  ;               NUMBER. 
                             C  ; 
                             C  ;**********************************************
				************* 
                             C   
 1776                        C  $FIND:				;FORCE INPUT TO DOUBLE PRECISION 
 1776  0C 01                 C  	OR	AL,LOW 1	;TO SIGNAL DOUBLE PRECISION 
 1778                        C  $FINS:				;FORCE INPUT TO SINGLE PRECISION (cal
				ler has set Z flag) 
 1778  53                    C  	PUSH	BX		;SAVE TEXT POINTER 
 1779  57                    C  	PUSH	DI		;SAVE NO DIGITS AFTER DECIMAL POINT 
 177A  75 05                 C  	JNZ	FC10		;Force to double for $FIND callers. 
 177C  E8 1799 R             C  	CALL	$FS		;Force to single for $FINS callers. 
 177F  EB 03                 C  	JMP	SHORT FC20	;Skip over $FD call. 
                             C   
 1781  E8 17C8 R             C  FC10:	CALL	$FD		;FORCE FAC TO DOUBLE PREC. 
 1784  5F                    C  FC20:	POP	DI		;RECALL NO DIGITS TO RT. OF DEC P
				T 
 1785  5B                    C  	POP	BX		;RECALL TEXT POINTER 
 1786  33 F6                 C  	XOR	SI,SI		;SINCE THIS IS A FORCED 
 1788  8B D6                 C  	MOV	DX,SI		;NO. EXPONENT IS ZERO 
 178A  E8 0704 R             C  	CALL	$FINE		;DO IMPLIED EXPONENT FIX-UP 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-101
FINFC	 INPUT FORCE ROUTINES FOR "#","%","!"                 

 178D  43                    C  FC30:	INC	BX		;Point past the force character a
				nd 
 178E  C3                    C  	RET			;return. 
                             C   
 178F  E8 08EE R             C  $FINI:	CALL	$GETYP		;SET COND CODES ACCORDING T
				O TYPE 
 1792  78 F9                 C  	JS	FC30 
 1794  E9 0000 E             C  	JMP	$SNERR		;CAN'T MAKE INTEGER IF NOT ALREADY
				 
 1797  74 2F                 C  $FINFC: JZ	$FD		;IF ZF=1 THEN DOUBLE PRECISION 
 1799                        C  FRCSNG: 
 1799                        C  $FS:				;FORCE SINGLE PRECISION 
 1799  E8 08EE R             C  	CALL	$GETYP		;SET COND CODES ACC. TO TYPE 
 179C  7B 52                 C  	JPO	FC200		;IF ALREADY S.P. RETURN 
 179E  75 03                 C  	JNZ	FS10 
 17A0  E9 0000 E             C  	JMP	$TMERR		;CAN'T FORCE A STRING 
 17A3                        C  FS10: 
 17A3  79 05                 C  	JNS	$CSD		;IF NOT INTEGER FORCE DOUBLE TO S.P.
				 
 17A5  E8 17E5 R             C  	CALL	$CSI		;FORCE INTEGER TO SINGLE 
 17A8  EB 46                 C  	JMP	SHORT FC200 
 17AA                        C  $CSD:				;CONVERT DOUBLE TO SINGLE PRECISION 
 17AA  B0 04                 C  	MOV	AL,LOW 4	;SINGLE PREC DESIGNATION 
 17AC  A2 0000 E             C  	MOV	BYTE PTR $VALTP,AL 
 17AF  8A 1E FFFF E          C  	MOV	BL,BYTE PTR $FAC-1	;FETCH HIGH MANTISSA BI
				TS 
 17B3  88 1E 0001 E          C  	MOV	BYTE PTR $FAC+1,BL	;MOVE SIGN TO $FAC+1 
 17B7  8B 16 FFFD E          C  	MOV	DX,WORD PTR $FAC-3	;FETCH REST OF MANTISSA
				 
 17BB  8A 26 FFFC E          C  	MOV	AH,BYTE PTR $FAC-4	;FETCH OVERFLOW BITS 
 17BF  80 CC 40              C  	OR	AH,LOW 100	;WANT ROUND-UP IF HIGH BIT SET 
 17C2  80 CB 80              C  	OR	BL,LOW 200	;PUT IN UNDERSTOOD 1 
 17C5  E9 1FC9 R             C  	JMP	$ROUNM		;GO ROUND THE NUMBER 
 17C8                        C  FRCDBL: 
 17C8                        C  $FD:				;FORCE TO DOUBLE PRECISION 
 17C8  E8 08EE R             C  	CALL	$GETYP		;DETERMINE CURRENT TYPE 
 17CB  73 23                 C  	JNB	FC200		;IF ALREADY DOUBLE EXIT 
 17CD  75 03                 C  	JNZ	FD10 
                             C   
 17CF  E9 0000 E             C  	JMP	$TMERR 
 17D2                        C  FD10: 
 17D2  79 03                 C  	JNS	$CDS		;IF NOT INTEGER PROCEED 
 17D4  E8 17E5 R             C  	CALL	$CSI		;CONVERT INTEGER TO SINGLE PREC. 
 17D7  B0 08                 C  $CDS:	MOV	AL,LOW 10	;DOUBLE PREC. INDICATOR 
 17D9  A2 0000 E             C  	MOV	BYTE PTR $VALTP,AL	;SET TYPE TO D.P. 
 17DC  33 C0                 C  	XOR	AX,AX		;MUST ZERO OVERFLOW BYTES 
 17DE  A3 0000 E             C  	MOV	WORD PTR $DFACL,AX 
 17E1  A3 0002 E             C  	MOV	WORD PTR $DFACL+2,AX 
 17E4  C3                    C  	RET 
 17E5  52                    C  $CSI:	PUSH	DX		;SAVE (DX) 
 17E6  56                    C  	PUSH	SI		;SAVE (SI) 
 17E7  8B 16 0000 E          C  	MOV	DX,WORD PTR $FACLO	;FETCH THE INTEGER 
 17EB  E8 184E R             C  	CALL	$FLT		;FLOAT THE INTEGER AND STORE IN FAC
				 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-102
FINFC	 INPUT FORCE ROUTINES FOR "#","%","!"                 

 17EE  5E                    C  	POP	SI		;GET REGISTERS RIGHT 
 17EF  5A                    C  	POP	DX 
 17F0  C3                    C  FC200:	RET 
 17F1                        C  FRCINT: 
 17F1                        C  $FI:				;FORCE INTEGER 
 17F1  E8 08EE R             C  	CALL	$GETYP		;SEE WHAT WE'RE IN FOR 
 17F4  79 05                 C  	JNS	FI10		;IF NOT INTEGER ALREADY - JUMP 
 17F6  8B 1E 0000 E          C  	MOV	BX,WORD PTR $FACLO 
 17FA  C3                    C  	RET 
 17FB                        C  FI10: 
 17FB  75 03                 C  	JNZ	FFI20 
 17FD  E9 0000 E             C  	JMP	$TMERR		;IF STRING - ERROR 
 1800                        C  FFI20: 
 1800                        C  $CINC:				;Single precision, operand in FAC 
 1800                        C  $CIND:				;Double precision uses same routine 
 1800  50                    C  	PUSH	AX 
 1801  51                    C  	PUSH	CX 
 1802  A1 0000 E             C  	MOV	AX,WORD PTR $FACM1	;Get exponent 
 1805  8B 0E 0000 E          C  	MOV	CX,WORD PTR $FACLO	;Get mantissa 
 1809                        C  CINT: 
 1809  33 DB                 C  	XOR	BX,BX		;Set up zero result 
 180B  80 EC 80              C  	SUB	AH,LOW 200O	;Take bias out of exponent 
 180E  72 1F                 C  	JB	CXRET		;Return zero if no integer part 
 1810  8A F8                 C  	MOV	BH,AL		;Highest byte of mantissa 
 1812  8A DD                 C  	MOV	BL,CH 
 1814  91                    C  	XCHG	AX,CX 
 1815  B1 10                 C  	MOV	CL,LOW 16D 
 1817  2A CD                 C  	SUB	CL,CH		;Number of bits to shift mantissa r
				ight 
 1819  8A E7                 C  	MOV	AH,BH		;Save sign 
 181B  72 2E                 C  	JB	OVERFLOW	;If negative shift, it won't fit i
				n 16 bits 
 181D  74 22                 C  	JZ	OVCHK		;Only -32768 has 16 bits - go check 
				for it 
 181F  80 CF 80              C  	OR	BH,LOW 200O	;Set implied bit 
 1822  D3 EB                 C  	SHR	BX,CL		;Position the integer 
 1824  83 D3 00              C  	ADC	BX,0		;Perform rounding 
 1827  70 12                 C  	JO	POSBOVER 
 1829  0A E4                 C  	OR	AH,AH		;Check sign now 
 182B  79 02                 C  	JNS	CXRET 
 182D  F7 DB                 C  	NEG	BX 
 182F                        C  CXRET: 
 182F  59                    C  	POP	CX 
 1830  58                    C  	POP	AX 
 1831  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX	;Result in both FAC and
				 BX 
                             C   
 1835                        C  VALINT: 
 1835  C6 06 0000 E 02       C  $VALNT: MOV	BYTE PTR $VALTP,LOW 2 
 183A  C3                    C  	RET 
 183B                        C  POSBOVER:			;Here for either -32768 or overflow
				 
 183B  0A E4                 C  	OR	AH,AH		;If signed then -32768 
 183D  78 F0                 C  	JS	CXRET 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-103
FINFC	 INPUT FORCE ROUTINES FOR "#","%","!"                 

 183F  EB 0A                 C  	JMP	SHORT OVERFLOW 
 1841                        C  OVCHK: 
                             C  ;Come here if no shift is needed on the number,
				 i.e., it requires a full 
                             C  ;16 bits. Only -32768 (8000H) is allowed. 
 1841  81 FB 8000            C  	CMP	BX,100000O	;The 1 is sign bit (negative), 
				not implied bit 
 1845  75 04                 C  	JNZ	OVERFLOW 
 1847  A8 80                 C  	TEST	AL,LOW 200O	;Should we be rounding up? 
 1849  74 E4                 C  	JZ	CXRET		;If so, that causes overflow 
 184B                        C  OVERFLOW: 
 184B  E9 0000 E             C  	JMP	$OVERR 
                             C   
                             C  	SUBTTL	 $FLT	 CONVERT INTEGER IN (DX) TO REAL 
				AND STORE IN FAC 
                             C  ;**********************************************
				****************** 
                             C  ;       $FLT    CONVERTS THE SIGNED INTEGER IN 
				(DX) TO A REAL 
                             C  ;               (FLOATING POINT ) NUMBER AND ST
				ORES IT IN THE FAC 
                             C  ;               AND SETS $VALTP=4 
                             C  ;**********************************************
				******************* 
 184E  33 DB                 C  $FLT:	XOR	BX,BX		;CLEAR HIGH MANTISSA BYTE (BL)
				 
 1850  32 E4                 C  	XOR	AH,AH		;CLEAR OVERFLOW BYTE 
 1852  BE 0001 E             C  	MOV	SI,OFFSET $FAC+1	;FETCH $FAC ADDRESS TO (S
				I) 
 1855  C6 44 FF 90           C  	MOV	BYTE PTR -1[SI],LOW 220 ;SET EXPONENT TO 1
				6 
 1859  C6 04 00              C  	MOV	BYTE PTR 0[SI],LOW 0	;SET SIGN POSITIVE 
 185C  0B D2                 C  	OR	DX,DX		;SETS SF=1 IF NEGATIVE NO. 
 185E  79 05                 C  	JNS	FLT10		;IF POSITIVE PROCEED 
 1860  F7 DA                 C  	NEG	DX		;NEED POSTIVE MAGNITUDE 
 1862  C6 04 80              C  	MOV	BYTE PTR 0[SI],LOW 200	;SET SIGN TO NEGATI
				VE 
 1865  8A DE                 C  FLT10:	MOV	BL,DH		;WILL MOVE (DX) TO (BLDH) 
 1867  8A F2                 C  	MOV	DH,DL		; 
 1869  8A D7                 C  	MOV	DL,BH		;SET (DL)=0 
 186B  C6 06 0000 E 04       C  	MOV	BYTE PTR $VALTP,LOW 4	;SET TYPE TO S.P. 
 1870  E9 1CE4 R             C  	JMP	$NORMS		;GO NORMALIZE 
                             C   
                             C  	SUBTTL	 $FMULD  DOUBLE PRECISION MULTIPLICATIO
				N 
                             C  ;**********************************************
				**************** 
                             C  ; 
                             C  ;       $FMULD  THIS ROUTINE FORMS THE DOUBLE P
				RECISION PRODUCT 
                             C  ;               ($FAC):=($FAC)*($ARG) 
                             C  ;               THE TECHNIQUE USED IS DESCRIBED
				 IN KNUTH, VOL II 
                             C  ;               P.233 AND IS CALLED ALGORITHM "
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-104
$FMULD  DOUBLE PRECISION MULTIPLICATION                     

				M" 
                             C  ;       CALLING SEQUENCE:       CALL    $FMULD 
                             C  ;               WITH THE MULTIPLIER AND MULTIPL
				ICAND IN THE 
                             C  ;               $FAC AND $ARG 
                             C  ; 
                             C  ;**********************************************
				**************** 
                             C   
 1873                        C  DMULT: 
 1873                        C  $FMULD:			;DOUBLE PRECISION MULT., (FAC)=(FAC)*
				(ARG) 
 1873  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC	;WILL FIRST SEE IF FAC IS
				 ZERO 
 1876  0A C0                 C  	OR	AL,AL		;AND IF SO JUST RETURN 
 1878  74 0A                 C  	JZ	FMD10 
 187A  A0 0000 E             C  	MOV	AL,BYTE PTR $ARG	;WILL NOW SEE IF ARG IS Z
				ERO AND 
 187D  0A C0                 C  	OR	AL,AL		;IF SO SET FAC TO ZERO AND RETURN 
 187F  75 04                 C  	JNZ	FMD20		;IF NOT ZERO PROCEED TO MULTIPLY 
 1881  E9 08A7 R             C  	JMP	$DZERO		;ZERO THE FAC 
 1884  C3                    C  FMD10:	RET 
 1885                        C  FMD20: 
 1885  8B 1E FFFF E          C  	MOV	BX,WORD PTR $ARG-1	;FETCH SIGN AND EXP. TO
				 BX 
 1889  E8 11FC R             C  	CALL	$AEXPS		;ADD THE EXPONENTS 
 188C  FF 36 0000 E          C  	PUSH	WORD PTR $FAC	;EXPONENT,SIGN 
 1890  89 1E FFFF E          C  	MOV	WORD PTR $ARG-1,BX	;REPLACE UNPACKED MANTI
				SSA 
                             C  				;PUT THE SIGN OF THE PRODUCT IN 
                             C  				;FAC+1 
 1894  E8 0B3E R             C  	CALL	$SETDB		;MOVE THE FAC TO $DBUFF SO PRODUC
				T 
                             C  				;CAN BE FORMED IN THE FAC, AND ZERO 
                             C  				;THE FAC AND RETURNS WITH (AX)=0 
 1897  8B F0                 C  	MOV	SI,AX		;J 
 1899  A3 0000 E             C  	MOV	WORD PTR $FAC,AX 
 189C  BB 0000 E             C  	MOV	BX,OFFSET $DBUFF	; 
 189F  A3 0000 E             C  	MOV	WORD PTR $ARG,AX 
 18A2  BD 0000 E             C  	MOV	BP,OFFSET $ARGLO	;POINT TO MULTIPLICAND BA
				SE 
 18A5  8B 00                 C  M1:	MOV	AX,WORD PTR 0[BX+SI]	;FETCH MULTIPLIER 
				V(J) 
 18A7  0B C0                 C  	OR	AX,AX		;SEE IF ZERO 
 18A9  74 2C                 C  	JZ	M4D		;IF ZERO W(J)=0 
 18AB  BF 0000               C  	MOV	DI,0		;I 
 18AE  8B CF                 C  	MOV	CX,DI		;K 
 18B0  8B 00                 C  M4:	MOV	AX,WORD PTR 0[BX+SI]	;FETCH MULTIPLIER 
				V(J) 
 18B2  F7 23                 C  	MUL	WORD PTR 0[BP+DI]	;FORM PRODUCT V(J)*U(J) 
				IN (DXAX) 
 18B4  53                    C  	PUSH	BX		;SAVE PTR. TO MULTIPLIER BASE 
 18B5  8B DE                 C  	MOV	BX,SI		; 
 18B7  03 DF                 C  	ADD	BX,DI		;I+J 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-105
$FMULD  DOUBLE PRECISION MULTIPLICATION                     

 18B9  81 C3 FFF8 E          C  	ADD	BX,OFFSET $DFACL-10	;W(I+J) ADDRESS IN BX 
 18BD  03 07                 C  	ADD	AX,WORD PTR 0[BX]	;(DXAX)=U(I)*V(J)+W(I+J)
				 
 18BF  73 01                 C  	JNB	M4A 
 18C1  42                    C  	INC	DX 
 18C2  03 C1                 C  M4A:	ADD	AX,CX		;T=U(I)*V(J)+W(I+J)+K 
 18C4  73 01                 C  	JNB	M4B 
 18C6  42                    C  	INC	DX 
 18C7  89 07                 C  M4B:	MOV	WORD PTR 0[BX],AX	;W(I+J)= T MOD 2^16 
 18C9  8B CA                 C  	MOV	CX,DX		;K=INT(T/2^16) 
 18CB  5B                    C  	POP	BX		;RECALL PTR TO MULTIPLIER BASE 
 18CC  83 FF 06              C  	CMP	DI,6		;FINISHED INNER LOOP? 
 18CF  74 04                 C  	JZ	M4C		;IF SO JUMP AND SET W(J) 
 18D1  47                    C  	INC	DI 
 18D2  47                    C  	INC	DI 
 18D3  EB DB                 C  	JMP	SHORT M4 
 18D5  8B C1                 C  M4C:	MOV	AX,CX		;(AX)=K 
 18D7  53                    C  M4D:	PUSH	BX		;SAVE PTR TO MULTIPLIER BASE 
 18D8  BB 0000 E             C  	MOV	BX,OFFSET $DFACL 
 18DB  89 00                 C  	MOV	WORD PTR 0[BX+SI],AX	;W(J)=K OR 0 (0 IF V(
				J) WERE 0) 
 18DD  5B                    C  	POP	BX		;RECALL PTR TO MULTIPLIER BASE 
 18DE  83 FE 06              C  	CMP	SI,6		;FINISHED OUTER LOOP? 
 18E1  74 04                 C  	JZ	M5 
 18E3  46                    C  	INC	SI 
 18E4  46                    C  	INC	SI 
 18E5  EB BE                 C  	JMP	SHORT M1 
 18E7                        C  M5:				;MULTIPLICATION COMPLETE AND IN FAC 
 18E7  BE FFFE E             C  	MOV	SI,OFFSET $DFACL-2	;WILL NOW SET ST 
 18EA  FD                    C  	STD			;WANT NON-ZERO BYTE ASAP SO PROB. 
                             C  				;SEEMS HIGHER OF GETTING ONE IF 
                             C  				;(SI) IS DECREMENTED 
 18EB  B9 0007               C  	MOV	CX,7		;7-BYTE CHECK 
 18EE  AC                    C  M5AA:	LODSB			;FETCH NEXT BYTE 
 18EF  0A C0                 C  	OR	AL,AL 
 18F1  E1 FB                 C  	LOOPZ	M5AA 
 18F3  74 05                 C  	JZ	M5AB		;DON'T NEED TO SET ST 
 18F5  80 0E FFFF E 20       C  	OR	BYTE PTR $DFACL-1,LOW 40	;"OR" IN ST BIT 
 18FA                        C  M5AB: 
 18FA  A0 FFFF E             C  	MOV	AL,BYTE PTR $FAC-1	;SEE IF WE NEED TO INC 
				EXPONENT 
 18FD  0A C0                 C  	OR	AL,AL 
 18FF  8F 06 0000 E          C  	POP	WORD PTR $FAC	;RESTORE EXPONENT,SIGN 
 1903  78 0F                 C  	JS	M6 
 1905  BB FFFF E             C  	MOV	BX,OFFSET $DFACL-1	;MUST SHIFT 1 BIT LEFT 
 1908  B9 0004               C  	MOV	CX,4 
 190B  D1 17                 C  M5A:	RCL	WORD PTR 0[BX],1 
 190D  43                    C  	INC	BX 
 190E  43                    C  	INC	BX 
 190F  E2 FA                 C  	LOOP	M5A 
 1911  E9 1F8C R             C  M5B:	JMP	$ROUND		;NOW ROUND 
 1914  FE 06 0000 E          C  M6:	INC	BYTE PTR $FAC	;INCREMENT EXPONENT 
 1918  75 F7                 C  	JNZ	M5B 
 191A  E9 0775 R             C  	JMP	$OVFLS		;OVERFLOW! 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-106
$FMULD  DOUBLE PRECISION MULTIPLICATION                     

                             C   
                             C  	SUBTTL	 $FMULS  SINGLE PRECISION 8086 MULTIPLI
				CATION 
                             C  ;**********************************************
				************ 
                             C  ;       $FMULS  FMULS MULTIPLIES THE SINGLE PRE
				CISION 
                             C  ;               FLOATING POINT QUANTITIES (BXDX
				) AND (FAC) 
                             C  ;               AND RETURNS THE PRODUCT IN THE 
				(FAC). ONLY 
                             C  ;               SEGMENT REGISTERS ARE PRESERVED
				. 
                             C  ;**********************************************
				************* 
                             C   
 191D                        C  $FMULS:			;(FAC)=(BXDX)*(FAC) 
 191D  E8 08BE R             C  	CALL	$SIGNS		;ZF=1 WILL BE SET IF (FAC)=0 
 1920  74 04                 C  	JZ	FMS00		;JUST RETURN IF (FAC)=0 
 1922  0A FF                 C  	OR	BH,BH		;IF EXPONENT OF (BXDX) IS ZERO 
 1924  75 03                 C  	JNZ	FMS05		;PROCEED IF NON-ZERO 
 1926  E9 08B4 R             C  FMS00:	JMP	$ZERO		;THE NUMBER IS ZERO. 
 1929                        C  FMS05: 
 1929  E8 11FC R             C  	CALL	$AEXPS		;ADD THE S.P. EXPONENTS 
                             C  ;**********************************************
				***************** 
                             C  ;WILL NOW PROCEED TO MULTIPLY THE MANTISSAS. TH
				E MULTIPLICATION 
                             C  ;WILL UTILIZE THE 16 BIT MUL INSTRUCTION AND TH
				US WILL TAKE 
                             C  ;PLACE AS PARTIAL PRODUCTS SINCE WE HAVE 24 BIT
				 MANTISSAS TO 
                             C  ;MULTIPLY. 
                             C  ;**********************************************
				***************** 
 192C  8B 0E FFFF E          C  	MOV	CX,WORD PTR $FAC-1	;(CH)=($FAC):(CL)=($FAC
				-1) 
 1930  32 ED                 C  	XOR	CH,CH		;(CX) CONTAINS HIGH MANTISSA BITS 
 1932  A1 FFFD E             C  	MOV	AX,WORD PTR $FAC-3	;(AX) CONTAINS LOW MANT
				ISSA BITS OF FAC 
 1935  8A FD                 C  	MOV	BH,CH		;SET (BH)=0 AS WELL 
                             C  ;**********************************************
				*************** 
                             C  ;AT THIS POINT WE HAVE THE FAC MANTISSA IN (CLA
				X) AND THE 
                             C  ;(BXDX) MANTISSA IN (BLDX). THE UNDERSTOOD LEAD
				ING MANTISSA 
                             C  ;BIT WAS INSTALLED BY $AEXPS AND THE SIGN OF TH
				E PRODUCT 
                             C  ;WAS STORED IN FAC+1 
                             C  ;THE PRODUCT WILL BE FORMED IN (BXCX) BY PARTIA
				L PRODUCTS. 
                             C  ;FIRST THE NECESSARY ELEMENTS WILL BE PUSHED ON
				 THE STACK 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-107
$FMULS  SINGLE PRECISION 8086 MULTIPLICATION                

                             C  ;THEN UTILIZED IN REVERSE ORDER(THAT'S THE BEST
				 WAY TO 
                             C  ;GET THE THEM OFF THE LIFO STACK -TURKEY!) 
                             C  ;**********************************************
				************** 
 1937  8B F3                 C  	MOV	SI,BX 
 1939  8B F9                 C  	MOV	DI,CX 
 193B  8B EA                 C  	MOV	BP,DX 
 193D  51                    C  	PUSH	CX		;HIGH FAC MANTISSA BITS 
 193E  50                    C  	PUSH	AX		;LOW FAC MANTISSA BITS 
 193F  F7 E2                 C  	MUL	DX		;32 BIT PRODUCT FORMED(ONLY NEED 
 1941  8B CA                 C  	MOV	CX,DX		;MOST 16 SIGNIFICANT BITS) 
 1943  58                    C  	POP	AX		;LOW FAC MANTISSA BITS 
 1944  F7 E3                 C  	MUL	BX		;TIMES HIGH MANTISSA BITS OF (BLDX) 
 1946  03 C8                 C  	ADD	CX,AX		;ADD TO PREVIOUS CALCULATION 
 1948  73 01                 C  	JNB	FMS10		;IF CARRY NOT PRODUCED PROCEED 
 194A  42                    C  	INC	DX 
 194B  8B DA                 C  FMS10:	MOV	BX,DX		;PROBABLY ONLY 8 BITS HERE 
 194D  5A                    C  	POP	DX		;HIGH FAC MANTISSA BITS 
 194E  8B C5                 C  	MOV	AX,BP		;LOW 16 MANTISSA BITS OF (BLDX) 
 1950  F7 E2                 C  	MUL	DX		; 
 1952  03 C8                 C  	ADD	CX,AX		;ADD IN LOW ORDER BITS 
 1954  73 01                 C  	JNB	FMS20		;JUMP IF CARRY NOT PRODUCED 
 1956  42                    C  	INC	DX		; 
 1957  03 DA                 C  FMS20:	ADD	BX,DX		;CAN'T PRODUCE CARRY HERE 
 1959  8B D7                 C  	MOV	DX,DI		;HIGH FAC MANTISSA BITS 
 195B  8B C6                 C  	MOV	AX,SI		;HIGH FAC MANTISSA BITS 
 195D  F6 E2                 C  	MUL	DL		;(AX) HAS ENTIRE PRODUCT 
 195F  03 D8                 C  	ADD	BX,AX		;ADD IT IN 
 1961  73 0D                 C  	JNB	FMS30		;IF NO CARRY PROCEED 
 1963  D1 DB                 C  	RCR	BX,1		;MOVE EVERYTHING RIGHT 
 1965  D1 D9                 C  	RCR	CX,1		; 
 1967  FE 06 0000 E          C  	INC	BYTE PTR $FAC	;MUST NOW CHECK FOR OVERFLOW
				 
 196B  75 03                 C  	JNZ	FMS30		;PROCEED IF NON-ZERO 
 196D  E9 0775 R             C  	JMP	$OVFLS 
 1970                        C  FMS30:				;PRODUCT FORMED, MUST NOW GET MANTISS
				A IN (BLDXAH) FOR ROUNS 
                             C  				;PRODUCT IS CURRENTLY IN (BXCX) 
 1970  0A FF                 C  	OR	BH,BH		;MUST BE SURE PRODUCT LEFT JUSTIFIED
				 
 1972  79 09                 C  	JNS	FMS35		;IN (BXCX) 
 1974  FE 06 0000 E          C  	INC	BYTE PTR $FAC	;NEED TO INCREMENT EXP. 
 1978  75 07                 C  	JNZ	FMS37		;IF NOT OVERFLOW PROCEED 
 197A  E9 0775 R             C  	JMP	$OVFLS		;OVERFLOW JUMP 
 197D                        C  FMS35: 
 197D  D1 D1                 C  	RCL	CX,1 
 197F  D1 D3                 C  	RCL	BX,1 
 1981                        C  FMS37: 
 1981  8A D5                 C  	MOV	DL,CH 
 1983  8A F3                 C  	MOV	DH,BL 
 1985  8A DF                 C  	MOV	BL,BH 
 1987  8A E1                 C  	MOV	AH,CL		;OVERFLOW BYTE 
 1989  E9 1FC6 R             C  	JMP	$ROUNS		;GO ROUND 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-108
$FMULS  SINGLE PRECISION 8086 MULTIPLICATION                

 198C  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $FOTAN  ROUTINE TO PUT IN DECIMAL POIN
				T AND LEADING ZEROS 
                             C  ;**********************************************
				******************* 
                             C  ; 
                             C  ;       $FOTAN  THIS ROUTINE IS CALLED BY THE F
				REE FORMAT OUTPUT 
                             C  ;               CODE TO OUTPUT DECIMAL POINT AN
				D LEADING ZEROS. 
                             C  ;       $FOTED  THIS ROUTINE IS CALLED BY BOTH 
				THE FREE FORMAT 
                             C  ;               OUTPUT ROUTINE AND THE PRINT US
				ING CODE TO OUTPUT 
                             C  ;               THE DECIMAL POINT WHEN NECESSAR
				Y AND TO PUT IN 
                             C  ;               COMMAS "," AFTER EACH THREE DIG
				ITS IF THIS OPTION 
                             C  ;               IS INVOKED. 
                             C  ;       CALLING SEQUENCE:       CALL    $FOTAN 
                             C  ;                               CALL    $FOTED 
                             C  ;               WITH $FMTCX CONTAINING NUMBER P
				LACES PRIOR TO 
                             C  ;               DECIMAL POINT(NEGATIVELY) IN UP
				PER BYTE AND 
                             C  ;               NO PLACES BEFORE NEXT COMMA IN 
				LOW BYTE 
                             C  ; 
                             C  ;**********************************************
				********************* 
                             C   
 198D                        C  $FOTAN: 
 198D  FE CD                 C  	DEC	CH		;IF NEGATIVE THEN LEADING ZEROS 
 198F  79 16                 C  	JNS	FTD05		; 
 1991  89 1E 0000 E          C  	MOV	WORD PTR $DPADR,BX	;SAVE DECIMAL POINT COU
				NT 
 1995  C6 07 2E              C  	MOV	BYTE PTR 0[BX],LOW "."  ;MOVE IN DECIMAL P
				OINT 
 1998  43                    C  FTN10:	INC	BX		;POINT TO NEXT OUTPUT POSITION 
 1999  C6 07 30              C  	MOV	BYTE PTR 0[BX],LOW "0"  ;PUT IN LEADING ZE
				RO 
 199C  FE C5                 C  	INC	CH		;WILL INCREMENT CH UNTIL ZERO 
 199E  75 F8                 C  	JNZ	FTN10		;PUT IN LEADING ZEROS UNTIL CH ZERO
				 
 19A0  43                    C  	INC	BX		;POINT TO NEXT BUFFER POSITION 
 19A1  33 C9                 C  	XOR	CX,CX		;ZERO OUT DECIMAL POINT AND COMMA C
				TS. 
 19A3  EB 1A                 C  	JMP	SHORT FTD20	;GET STACK RIGHT AND RETURN 
 19A5                        C  $FOTED: 
 19A5  FE CD                 C  	DEC	CH		;SEE IF TIME FOR D.P. 
 19A7  75 0C                 C  FTD05:	JNZ	FTD10		;IF NOT D.P. TIME SEE IF COMM
				A TIME 
 19A9  C6 07 2E              C  	MOV	BYTE PTR 0[BX],LOW "."  ;PUT IN D.P. 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-109
$FOTAN  ROUTINE TO PUT IN DECIMAL POINT AND LEADING ZEROS   

 19AC  89 1E 0000 E          C  	MOV	WORD PTR $DPADR,BX	;SAVE ADDR OF DECIMAL P
				OINT 
 19B0  43                    C  	INC	BX		;INCREMENT PAST D.P. 
 19B1  33 C9                 C  	XOR	CX,CX		;ZERO COUNTS & SET ZF=1 
 19B3  EB 0A                 C  	JMP	SHORT FTD20	;GET STACK RIGHT AND RETURN 
 19B5  FE C9                 C  FTD10:	DEC	CL		;IF ZERO TIME FOR COMMA 
 19B7  75 06                 C  	JNZ	FTD20 
 19B9  C6 07 2C              C  	MOV	BYTE PTR 0[BX],LOW 54O	;COMMA 
 19BC  43                    C  	INC	BX		;POINT TO NEXT BUFFER POSITION 
 19BD  B1 03                 C  	MOV	CL,LOW 3	; 
 19BF  89 0E 0000 E          C  FTD20:	MOV	WORD PTR $FMTCX,CX	;UPDATE D.P.&COMM
				A COUNTS 
 19C3  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $FOTCV  CONVERT FAC TO ASCII DIGITS 
                             C  ;**********************************************
				************** 
                             C  ; 
                             C  ;       $FOTCV  CONVERSION OF SINGLE OR DOUBLE 
				PRECISION 
                             C  ;               NUMBER TO ASCII DIGITS.IF DOUBL
				E PRECISION 
                             C  ;               10 DIGITS WILL BE CONVERTED WIT
				H DOUBLE 
                             C  ;               PRECISION POWER OF TEN INTEGERS
				, 3 DIGITS 
                             C  ;               WITH SINGLE PRECISION POWER OF 
				TEN INTEGERS 
                             C  ;               AND 3 DIGITS WITH INTEGER POWER
				S OF TEN 
                             C  ;       CALLING SEQUENCE:       CALL    $FOTCV 
                             C  ;               WITH THE NUMBER TO BE CONVERTED
				 HAVING PREVIOUSLY 
                             C  ;               BEEN OPERATED ON BY $FOTNV TO B
				RACKET THE 
                             C  ;               NUMBER AND HAVE ALL DIGITS IN T
				HE INTEGER PORTION 
                             C  ;               OF THE FAC. AND THE CORRESPONDI
				NG EXPONENT WILL 
                             C  ;               BE SAVED ON THE STACK AND CONVE
				RTED LATER. 
                             C  ; 
                             C  ;**********************************************
				**************** 
                             C   
 19C4  E8 08EE R             C  $FOTCV: CALL	$GETYP		;SET CONDITION CODES FOR V
				ALTYP 
 19C7  7B 6A                 C  	JPO	FCV40		;IF SINGLE PRECISION GO PROCESS 
 19C9  51                    C  	PUSH	CX		;SAVE DIGIT AND COMMA COUNT 
 19CA  53                    C  	PUSH	BX		;SAVE BUFFR PTR. 
 19CB  BE 0000 E             C  	MOV	SI,OFFSET $DFACL	;WILL MOVE FAC TO ARG 
 19CE  BF 0000 E             C  	MOV	DI,OFFSET $ARGLO 
 19D1  B9 0004               C  	MOV	CX,4 
 19D4  FC                    C  	CLD 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-110
$FOTCV  CONVERT FAC TO ASCII DIGITS                         

 19D5  F3/ A5                C   REP	MOVSW 
 19D7  E8 1B65 R             C  	CALL	$DINT		;WILL SEE IF FAC ALREADY INTEGER 
 19DA  53                    C  	PUSH	BX		;NEED TO CALL VCOMP WITH BX=ARG-1 
 19DB  BB FFFF E             C  	MOV	BX,OFFSET $ARG-1 
 19DE  E8 0A38 R             C  	CALL	$VCOMP		;DO COMPARE 
 19E1  5B                    C  	POP	BX		;GET BUFFER POINTER BACK 
 19E2  BE 0000 E             C  	MOV	SI,OFFSET $ARGLO	;WILL MOVIE ARG TO FAC 
 19E5  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 19E8  B9 0004               C  	MOV	CX,4 
 19EB  FC                    C  	CLD 
 19EC  F3/ A5                C   REP	MOVSW 
 19EE  74 03                 C  	JZ	FCV05		;DON'T ADD .5 IF NO DIFF. 
 19F0  E8 08FF R             C  	CALL	$DADDH		;ADD .5 TO NUMBER 
 19F3  8A 0E 0000 E          C  FCV05:	MOV	CL,BYTE PTR $FAC	;SHIFT COUNT IN (CL
				) 
 19F7  80 E9 B8              C  	SUB	CL,LOW 270 
 19FA  F6 D9                 C  	NEG	CL		;MAKE SHIFT COUNT POSITIVE 
 19FC  F8                    C  	CLC			;TO TELL DINT NOT TO NORMALIZE 
 19FD  E8 1B70 R             C  	CALL	$FTDNT		;MAKE SURE ITS STILL INTEGER 
 1A00  5B                    C  	POP	BX		;RECALL BUFFER PTR. 
 1A01  59                    C  	POP	CX		;RECALL DIGIT AND COMMA COUNT 
 1A02  BE 04D5 R             C  	MOV	SI,OFFSET $FODTB	;DOUBLE PRECISION OUTPUT 
				INTEGERS 
 1A05  B0 09                 C  	MOV	AL,LOW 9D	;9 DIGITS TO BE CONVERTED WITH D
				.P. 
 1A07  E8 19A5 R             C  FCV10:	CALL	$FOTED		;SEE IF DECIMAL POINT NEEDE
				D 
 1A0A  50                    C  	PUSH	AX		;SAVE DIGIT COUNT 
 1A0B  B0 2F                 C  	MOV	AL,LOW OFFSET "0"-1     ;WILL FORM DIGIT I
				N (AL) 
 1A0D  50                    C  	PUSH	AX 
 1A0E  58                    C  FCV20:	POP	AX		;RECALL DIGIT 
 1A0F  FE C0                 C  	INC	AL		;INCREMENT TO NEXT DIGIT 
 1A11  50                    C  	PUSH	AX		;SAVE DIGIT 
 1A12  E8 1A9A R             C  	CALL	DSUBI		;SUBTRACT POWER OF TEN 
 1A15  73 F7                 C  	JNB	FCV20 
 1A17  E8 1AAE R             C  	CALL	DADDI		;ADD POWER 10 BACK IN 
                             C  				;AND ADVANCE SI TO NEXT POWER 10 
 1A1A  58                    C  	POP	AX		;GET DIGIT BACK 
 1A1B  88 07                 C  	MOV	BYTE PTR 0[BX],AL	;PUT IN ASCII DIGIT 
 1A1D  43                    C  	INC	BX		;POINT TO NEXT BUFFER POSITION 
 1A1E  58                    C  	POP	AX		;GET DIGIT COUNT 
 1A1F  FE C8                 C  	DEC	AL		;SEE IF 10 DIGITS FORMED 
 1A21  75 E4                 C  	JNZ	FCV10		;IF NOT CONTINUE THE ALGORITHM 
 1A23  51                    C  	PUSH	CX		;SAVE DECIMAL POINT COUNT 
 1A24  BE 0000 E             C  	MOV	SI,OFFSET $DFACL	;WILL MOVE INTO FAC 
 1A27  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
 1A2A  B9 0002               C  	MOV	CX,2 
 1A2D  FC                    C  	CLD 
 1A2E  F3/ A5                C   REP	MOVSW 
 1A30  59                    C  	POP	CX		;RECALL DECIMAL POINT COUNT 
 1A31  EB 29                 C  	JMP	SHORT FCV50	;GO DO THE REST OF THE DIGITS 
 1A33                        C  FCV40: 
                             C  ;**********************************************
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-111
$FOTCV  CONVERT FAC TO ASCII DIGITS                         

				**************** 
                             C  ;CODE BELOW WORKS WITH SINGLE PRECISION NUMBERS
				 
                             C  ;**********************************************
				***************** 
 1A33  53                    C  	PUSH	BX		;SAVE BUFFER PTR 
 1A34  51                    C  	PUSH	CX		;SAVE DIGIT AND COMMA COUNTS 
 1A35  E8 0BBD R             C  	CALL	$PUSHF		;SAVE $FAC ON STACK 
 1A38  E8 1BD4 R             C  	CALL	$INT		;WILL SEE IF INTEGER CURRENTLY 
 1A3B  5A                    C  	POP	DX		;RECALL FAC 
 1A3C  5B                    C  	POP	BX 
 1A3D  E8 0A40 R             C  	CALL	$FCOMP		;COMPARE IF EQUAL DON'T ADD .5 
 1A40  74 0B                 C  	JZ	FCV45 
 1A42  89 1E FFFF E          C  	MOV	WORD PTR $FAC-1,BX	;MOVE BACK TO FAC 
 1A46  89 16 0000 E          C  	MOV	WORD PTR $FACLO,DX 
 1A4A  E8 090B R             C  	CALL	$FADDH		;ADD .5 TO NUMBER 
 1A4D  B0 01                 C  FCV45:	MOV	AL,LOW 1	;FLAG TO QINT WE HAVE A POS
				. NO. 
 1A4F  E8 1C37 R             C  	CALL	$QINT		;GET INTEGER INTO (BLDX) 
 1A52  89 1E FFFF E          C  	MOV	WORD PTR $FAC-1,BX 
 1A56  89 16 0000 E          C  	MOV	WORD PTR $FACLO,DX	;MOVE TO FAC 
 1A5A  59                    C  	POP	CX		;RECALL DIGIT AND COMMA COUNTS 
 1A5B  5B                    C  	POP	BX		;RECALL BUFFER PTR 
                             C   
                             C   
 1A5C                        C  FCV50: 
 1A5C  B0 03                 C  	MOV	AL,LOW 3	;WILL CONVERT 3 DIGITS IN THIS CO
				DE 
 1A5E  BA 051B R             C  	MOV	DX,OFFSET $FOSTB	;Print S.P. numbers with 
				7 digits 
 1A61  E8 19A5 R             C  FCV60:	CALL	$FOTED		;SEE IF NEED A DECIMAL POIN
				T OR COMMA 
 1A64  50                    C  	PUSH	AX		;SAVE DIGIT COUNT 
 1A65  53                    C  	PUSH	BX		;SAVE BUFFER POINTER 
 1A66  52                    C  	PUSH	DX		;SAVE POWER OF TEN POINTER 
 1A67  E8 0A0E R             C  	CALL	$MOVRF		;FETCH INTEGER 
 1A6A  5D                    C  	POP	BP		;FETCH POWER TEN POINTER 
 1A6B  B0 2F                 C  	MOV	AL,LOW OFFSET "0"-1     ;WILL BUILD DIGIT 
				IN (AL) 
 1A6D  50                    C  	PUSH	AX		;SAVE DIGIT 
 1A6E  58                    C  FCV70:	POP	AX		;RECALL DIGIT 
 1A6F  FE C0                 C  	INC	AL		;GO TO NEXT DIGIT 
 1A71  50                    C  	PUSH	AX 
 1A72  E8 0B01 R             C  	CALL	$RSUBM		;SUBTRACT NO. POINTED TO BY (BP) 
                             C  				;FROM (BLDX) 
 1A75  73 F7                 C  	JNB	FCV70		;CONTINUE UNTIL CF=1 
                             C  				;POWER TEN TABLE IN CODE SEGMENT 
 1A77  2E: 03 56 00          C  	ADD	DX,WORD PTR CS:0[BP]	;ADD WORD PORTION 
 1A7B  2E: 12 5E 02          C  	ADC	BL,BYTE PTR CS:2[BP] 
                             C  				;SINCE WE SUBTRACTED ONE TOO MANY 
 1A7F  45                    C  	INC	BP		;INCREMENT TO NEXT POWER OF TEN 
 1A80  45                    C  	INC	BP 
 1A81  45                    C  	INC	BP 
 1A82  E8 0A05 R             C  	CALL	$MOVFR		;SAVE (BLDX) IN FAC 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-112
$FOTCV  CONVERT FAC TO ASCII DIGITS                         

 1A85  58                    C  	POP	AX		;RECALL DIGIT 
 1A86  87 D5                 C  	XCHG	DX,BP		;SAVE POWER TEN PTR. IN DX 
 1A88  5B                    C  	POP	BX		;RECALL BUFFER POINTER 
 1A89  88 07                 C  	MOV	BYTE PTR 0[BX],AL	;SEND OUT DIGIT 
 1A8B  43                    C  	INC	BX		;INCREMENT TO NEXT BUFFER POSITION 
 1A8C  58                    C  	POP	AX		;RECALL DIGIT COUNT 
 1A8D  FE C8                 C  	DEC	AL		;SEE IF FINISHED 
 1A8F  75 D0                 C  	JNZ	FCV60		;IF NOT CONTINUE 
 1A91  42                    C  	INC	DX		;NEED TO INCREMENT PAST 1ST 
 1A92  42                    C  	INC	DX		;INTEGER SO THAT FOTCI WILL 
 1A93  8B EA                 C  	MOV	BP,DX		;FOTCI IS EXPECTING POINTER IN BP 
 1A95  B4 04                 C  	MOV	AH,LOW 4	;CONVERT ONLY 4 DIGITS 
 1A97  E9 0005 R             C  	JMP	$FCI4 
                             C  				;INTEGER ARITHMETIC 
 1A9A                        C  DSUBI:				;SUBTRACT 7 BYTE INTEGER POINTED TO B
				Y (SI) FROM $DFACL 
 1A9A  51                    C  	PUSH	CX		;FIRST SAVE CX,SI,DI 
 1A9B  56                    C  	PUSH	SI 
 1A9C  B9 0007               C  	MOV	CX,7		;7 BYTES 
 1A9F  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 1AA2  F8                    C  	CLC			;CF=0 
 1AA3  FC                    C  	CLD			;SO LODC WILL INCREMENT 
 1AA4                        C  DSUBI1:			;NEED NO. FROM CODE SEGMENT 
 1AA4  2E: AC                C  	LODS	BYTE PTR ?CSLAB ;FETCH BYTE TO AL 
 1AA6  18 05                 C  	SBB	BYTE PTR 0[DI],AL	;SUBTRACT 
 1AA8  47                    C  	INC	DI 
 1AA9  E2 F9                 C  	LOOP	DSUBI1 
 1AAB  5E                    C  	POP	SI 
 1AAC  59                    C  	POP	CX 
 1AAD  C3                    C  	RET 
 1AAE                        C  DADDI:				;ADD 7 BYTE INTEGER POINTED TO BY (SI
				) FROM $DFACL 
 1AAE  51                    C  	PUSH	CX		;SAVE CX,SI,DI 
 1AAF  B9 0007               C  	MOV	CX,7 
 1AB2  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 1AB5  F8                    C  	CLC 
 1AB6  FC                    C  	CLD			;SO LODC WILL INCREMENT SI 
 1AB7                        C  DADDI1:			;WANT NO. FETCHED FROM CODE SEGMENT 
 1AB7  2E: AC                C  	LODS	BYTE PTR ?CSLAB ;FETCH NEXT BYTE TO ADD 
 1AB9  10 05                 C  	ADC	BYTE PTR 0[DI],AL	;ADD IT IN 
 1ABB  47                    C  	INC	DI 
 1ABC  E2 F9                 C  	LOOP	DADDI1 
 1ABE  59                    C  	POP	CX 
 1ABF  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $FOTNV  BRACKET FAC SO PRINTABLE DIGIT
				S IN INTEGER PART 
                             C  ;**********************************************
				****************** 
                             C  ; 
                             C  ;       $FOTNV  THIS ROUTINE MULTIPLIES THE FAC
				 BY APPROPRIATE 
                             C  ;               VALUES SO THAT THE PRINTABLE DI
				GITS (7 FOR SINGLE 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-113
$FOTNV  BRACKET FAC SO PRINTABLE DIGITS IN INTEGER PART     

                             C  ;               PRECISION, 16 FOR DOUBLE PRECIS
				ION) ARE IN THE 
                             C  ;               INTEGER PART OF THE FAC . IT RE
				TURNS THE COMPLEMENT- 
                             C  ;               ING EXPONENT IN (AL). 
                             C  ;       CALLING SEQUENCE:       CALL    $FOTNV 
                             C  ;               WITH THE FAC CONTAINING THE DES
				IRED VALUE TO PRINT 
                             C  ;               REGISTERS (BX) AND (CX) WILL RE
				TAIN THEIR VALUES 
                             C  ; 
                             C  ;**********************************************
				******************* 
                             C   
 1AC0                        C  $FOTNV: 
 1AC0  53                    C  	PUSH	BX		;WON'T ALTER (BX) OR (CX) 
 1AC1  51                    C  	PUSH	CX 
 1AC2  33 FF                 C  	XOR	DI,DI		;INITIALIZE EXPONENT 
 1AC4  57                    C  	PUSH	DI		;SAVE EXPONENT 
 1AC5  BB 0259 R             C  FNV10:	MOV	BX,OFFSET $FOTB ;ADDRESS OF BRACKET 
				CONTROL TABLE 
 1AC8  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC	;FETCH THE EXPONENT 
                             C  				;MUST FETCH FROM CODE SEGMENT 
 1ACB  2E: D7                C  	XLAT	BYTE PTR ?CSLAB ;GET MULTIPLIER 
 1ACD  0A C0                 C  	OR	AL,AL		;IF ZERO - DONE 
 1ACF  74 0C                 C  	JZ	FNV20 
 1AD1  5F                    C  	POP	DI		;RECALL EXPONENT 
 1AD2  98                    C  	CBW			;CONVERT AL TO WORD 
 1AD3  2B F8                 C  	SUB	DI,AX		;GET EXPONENT CORRECT 
 1AD5  57                    C  	PUSH	DI		;SAVE EXPONENT 
 1AD6  8B D0                 C  	MOV	DX,AX		;DX:=exponent for MDPTEN. 
 1AD8  E8 0710 R             C  	CALL	MDPTEN		;Multiply or divide by power of t
				en. 
 1ADB  EB E8                 C  	JMP	SHORT FNV10	;See if need to do it again. 
                             C   
 1ADD  BB 0395 R             C  FNV20:	MOV	BX,OFFSET $DP06+4	;LOWER BOUND 
 1AE0  E8 09B3 R             C  	CALL	$MOVBS		;MOVE OUT TO "DS" AREA 
 1AE3  E8 0A80 R             C  	CALL	$COMPM		;ONE MORE MULT. POSSIBLE 
                             C  				;$COMPM WILL SET CF=1 IF $DP06 
                             C  				;IS LARGER, CF=0 FOR EQ OR GT 
 1AE6  73 06                 C  	JNB	FNV30		;JUMP IF NOT NEEDED 
 1AE8  E8 091E R             C  	CALL	$MUL10		;MULTIPLY BY TEN 
 1AEB  5F                    C  	POP	DI		;RECALL EXPONENT 
 1AEC  4F                    C  	DEC	DI		;ACCOUNT FOR MULTIPLY BY 10. 
 1AED  57                    C  	PUSH	DI 
 1AEE  E8 08EE R             C  FNV30:	CALL	$GETYP		;SET CONDITION CODES FOR TY
				PE 
                             C   
                             C   
 1AF1  72 1F                 C  	JB	FNV40		;done if single precision 
                             C   
 1AF3  BB 03A9 R             C  	MOV	BX,OFFSET $DP09 ;MUST MULTIPLY BY 10^9 
 1AF6  E8 09CF R             C  	CALL	$MOVAC		;MOVE 10^9 TO $ARG 
 1AF9  E8 1873 R             C  	CALL	$FMULD		;PERFORM MULTIPLICATION 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-114
$FOTNV  BRACKET FAC SO PRINTABLE DIGITS IN INTEGER PART     

 1AFC  58                    C  	POP	AX		;RECALL EXPONENT 
 1AFD  2C 09                 C  	SUB	AL,LOW 11	;SUBTRACT 9 
 1AFF  50                    C  	PUSH	AX		;Resave the exponent. 
 1B00  BB 1B18 R             C  	MOV	BX,OFFSET HIDBL ;Is the number too big?  (
				Will it 
 1B03  E8 09BB R             C  	CALL	$MOVBF		;overflow when $FOTCV adds .5 to 
				it?) 
 1B06  E8 0AD2 R             C  	CALL	$DCMPM 
 1B09  76 07                 C  	JNA	FNV40		;No. 
 1B0B  E8 0914 R             C  FNV44:	CALL	$DIV10		;Yes, divide by ten and fix
				 up the 
                             C  				;the decimal exponent. 
 1B0E  58                    C  	POP	AX		;restore the exponent 
 1B0F  FE C0                 C  	INC	AL		;adjust for $DIV10 
 1B11  50                    C  	PUSH	AX 
 1B12  58                    C  FNV40:	POP	AX		;recall exponent 
 1B13  59                    C  FNV50:	POP	CX		;restore registers 
 1B14  5B                    C  	POP	BX 
 1B15  0A C0                 C  	OR	AL,AL		;SET CONDITION CODES ACCORDING TO EX
				P 
 1B17  C3                    C  	RET 
                             C   
                             C  ; 
                             C  ; The largest double precision value that .5 ca
				n be added to without 
                             C  ; overflow occuring. 
                             C  ; 
                             C   
 1B18  FD FF 03 BF C9 1B 0E  C  HIDBL:	DB	375,377,3,277,311,33,16,266	;99999999
				99999999. 
       B6                    C  
                             C   
                             C   
                             C   
                             C  	SUBTTL	 $FOUT	 CONTROL OUTPUT CONVERSION 
                             C  ;**********************************************
				***************** 
                             C  ; 
                             C  ;       $FOUT   THIS ROUTINE PROVIDES TOP-LEVEL
				 CONTROL OF THE 
                             C  ;               FREE FORMAT OUTPUT FUNCTION. 
                             C  ;       CALLING SEQUENCE:       CALL    $FOUT 
                             C  ; 
                             C  ;**********************************************
				****************** 
                             C   
 1B20  BB 0001 E             C  S:	MOV	BX,OFFSET $FBUFF+1	;FETCH BUFFER POINTER
				 
 1B23  C6 07 20              C  	MOV	BYTE PTR 0[BX],LOW " "  ;MOVE IN SPACE FOR
				 POSSIBLE SIGN 
 1B26  53                    C  	PUSH	BX		;SAVE BUFFER POINTER 
 1B27  E8 08BE R             C  	CALL	$SIGNS		;DETERMINE SIGN OF NUMBER 
 1B2A  5B                    C  	POP	BX		;RECALL BUFFER POINTER 
 1B2B  9C                    C  	PUSHF			;SAVE FLAGS FOR LATER 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-115
$FOUT	 CONTROL OUTPUT CONVERSION                            

 1B2C  79 0A                 C  	JNS	FO20		;JUMP IF POSITIVE 
 1B2E  C6 07 2D              C  	MOV	BYTE PTR 0[BX],LOW "-"  ;PUT IN MINUS SGN 
 1B31  53                    C  	PUSH	BX		;SAVE TEXT POINTER 
 1B32  E8 0B1F R             C  	CALL	$VNEG		;NEGATE NO. SO WE WORK ONLY WITH 
 1B35  5B                    C  	POP	BX		;RECALL TEXT POINTER 
 1B36  0C 01                 C  	OR	AL,LOW 1	;POS. NOS. AND SET ZF=0 
 1B38  43                    C  FO20:	INC	BX		;POINT TO NEXT BUFFER POSITION 
 1B39  C6 07 30              C  	MOV	BYTE PTR 0[BX],LOW "0"  ;PUT IN ZERO IN CA
				SE NO IS ZERO 
 1B3C  9D                    C  	POPF			;RECALL FLAGS 
 1B3D  C3                    C  	RET 
 1B3E                        C  FOUT: 
 1B3E                        C  $FOUT:				;FREE-FORMAT ENTRY POINT 
 1B3E  E8 1B20 R             C  	CALL	S		;DO SIGN FIX-UP 
 1B41  75 08                 C  	JNZ	$FOUT2		;IF NON-ZERO PROCEED 
 1B43  43                    C  	INC	BX		;POINT TO NEXT OUTPUT BUFFER POS. 
 1B44  C6 07 00              C  	MOV	BYTE PTR 0[BX],LOW 0	;INDICATE END OF NUMB
				ER 
 1B47  BB 0001 E             C  	MOV	BX,OFFSET $FBUFF+1	;POINT (BX) TO START PO
				SITION 
 1B4A  C3                    C  	RET 
 1B4B  E8 08EE R             C  $FOUT2: CALL	$GETYP		;GET TYPE NO. 
 1B4E  79 12                 C  	JNS	FO50		;GO FORMAT SINGLE OR DOUBLE PREC. 
 1B50  B9 0700               C  	MOV	CX,OFFSET 7*400 ;default 7 digits prior to
				 dp. 
 1B53  33 C0                 C  	XOR	AX,AX		;CLEAR COMMA COUNT 
 1B55  A3 0000 E             C  	MOV	WORD PTR $FMTAX,AX 
 1B58  89 0E 0000 E          C  	MOV	WORD PTR $FMTCX,CX 
 1B5C  E8 0000 R             C  	CALL	$FOTCI		;CONVERT INTEGER TO ASCII 
 1B5F  E9 00D4 R             C  	JMP	$FOTZS		;DO LEADING ZERO SUPPRESSION 
 1B62  E9 07EB R             C  FO50:	JMP	$FOFMT		;SINGLE OR DOUBLE PREC. OUTPU
				T 
                             C   
                             C  	SUBTTL	 $INT	 CONVERT PRESENT NO. TO INTEGER B
				Y TRUNCATION 
                             C  ;**********************************************
				************* 
                             C  ; 
                             C  ;       $INT    SINGLE PRECISION INT ROUTINE 
                             C  ;       $DINT   DOUBLE PRECISION INT ROUTINE 
                             C  ;       $QINT   CONVERT TO INT AND LEAVE IN (BL
				DX) 
                             C  ;       $FTDNT  FOUT ENTRY TO CONVERT TO INT AN
				D LEAVE RT.ADJUSTED 
                             C  ;       $SHRD   SHIFT DOUBLE PRECISION MANTISSA
				 RIGHT 
                             C  ; 
                             C  ;**********************************************
				************ 
                             C  ;**********************************************
				************ 
                             C  ;THE INT TECHNIQUE IS PRETTY STRAIGHT FORWARD E
				XCEPT 
                             C  ;FOR NEGATIVE NON-INTEGERS. THE RUB WITH THESE 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-116
$INT	 CONVERT PRESENT NO. TO INTEGER BY TRUNCATION          

				NOS. IS THAT 
                             C  ;IF THEY HAVE ANY FRACTIONAL BITS THE ANSWER IS
				 TO 
                             C  ;BE THE NEXT LOWER VALUE INTEGER. FOR EXAMPLE :
				 INT(-1.1) SHOULD 
                             C  ;RETURN -2 WHEREAS INT(1.1) SHOULD RETURN 1. TH
				E TRICK USED TO 
                             C  ;EFFECT THIS IS TO SUBTRACT 1 FROM NEGATIVE NON
				-INTEGER MANTISSAS 
                             C  ;PRIOR TO SHIFTING OUT FRACTIONAL BITS THEN ADD
				 1 BACK TO THE 
                             C  ;MANTISSA ONCE FRACTIONAL BITS HAVE BEEN SHIFTE
				D OUT. WITH THE 
                             C  ;FOLLOWING EXAMPLE (IN BINARY) WATCH HOW THIS T
				ECHNIQUE WORKS: 
                             C  ;FIND INT(10011.011) 
                             C  ;       (1)     SINCE THIS IS A POSITIVE NO WE 
				JUST SHIFT OUT 
                             C  ;               THE FRACTIONAL BITS AND NORMALI
				ZE 
                             C  ;FIND INT(-10011.011) 
                             C  ;       (1)     SUBTRACT ONE FROM THE MANTISSA 
				YIELDING -10011.010 
                             C  ;       (2)     SHIFT OUT THE FRACTIONAL BITS Y
				IELDING -10011. 
                             C  ;       (3)     ADD 1 TO MANTISSA YIELDING -101
				00 THE CORRECT VALUE 
                             C  ;FIND INT(-10011.000) 
                             C  ;       (1)     SUBTRACT ONE FROM MANTISSA YIEL
				DING -10010.111 
                             C  ;       (2)     SHIFT OUT THE FRACTIONAL BITS Y
				IELDING -10010. 
                             C  ;       (3)     ADD 1 TO MANTISSA YIELDING -100
				11. THE CORRECT VALUE 
                             C  ;**********************************************
				******************** 
 1B65                        C  $DINT:				;DOUBLE PRECISION INT FUNCTION 
 1B65  8A 0E 0000 E          C  	MOV	CL,BYTE PTR $FAC	;CL:=exponent. 
 1B69  80 E9 B8              C  	SUB	CL,LOW 270	;Is there a fractional part? 
 1B6C  73 3E                 C  	JNB	DNT20		;RETURN IF NO FRACTIONAL BITS 
 1B6E  F6 D9                 C  	NEG	CL		;CL NOW POSITIVE 
 1B70  9C                    C  $FTDNT: PUSHF			;FOUT ENTRY POINT. THIS IS SEPA
				RATE 
                             C  				;ENTRY POINT BECAUSE FOUT WISHES 
                             C  				;TO HAVE INTEGER RIGHT ADJUSTED 
                             C  				;IN THE MANTISSA BITS. WE WILL DO 
                             C  				;THE NECESSARY SHIFTS AND RETURN 
                             C  				;PRIOR TO NORMALIZATION IF CALLED 
                             C  				;BY FOUT (SIGNIFIED BY CF=0) 
 1B71  F6 06 0000 E FF       C  	TEST	BYTE PTR $FAC,LOW 377O	;Is the exponent z
				ero? 
 1B76  75 02                 C  	JNE	DINTNZ		;No, proceed. 
 1B78  9D                    C  	POPF			;Yes, if the exponent is zero the 
 1B79  C3                    C  	RET			;number is zero.  Don't operate on 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-117
$INT	 CONVERT PRESENT NO. TO INTEGER BY TRUNCATION          

                             C  				;the possible garbage in the mantissa. 
 1B7A  BB FFFE E             C  DINTNZ: MOV	BX,OFFSET $FAC-2 
 1B7D  8A 47 01              C  	MOV	AL,BYTE PTR 1[BX]	;FETCH SIGN BYTE 
 1B80  88 47 03              C  	MOV	BYTE PTR 3[BX],AL	;AND PUT IN $FAC+1  FOR 
				$NORMD 
 1B83  0A C0                 C  	OR	AL,AL		;SEE IF NEGATIVE 
 1B85  9C                    C  	PUSHF 
 1B86  0C 80                 C  	OR	AL,LOW 200	;RESTORE HIDDEN 1 
 1B88  88 47 01              C  	MOV	BYTE PTR 1[BX],AL	;AND REPLACE 
 1B8B  C6 47 02 B8           C  	MOV	BYTE PTR 2[BX],LOW 270	;SET EXPONENT FOR P
				OST SHIFT VALUE 
 1B8F  9D                    C  	POPF			;RECALL SF 
 1B90  9C                    C  	PUSHF 
 1B91  79 03                 C  	JNS	DNT10		;IF POSITIVE PROCEED 
                             C  ;**********************************************
				******************* 
                             C  ;NEGATIVE NO. MUST DO THE FANCY FOOTWORK DESCRI
				BED ABOVE 
                             C  ;**********************************************
				******************* 
 1B93  E8 1BB8 R             C  	CALL	DINTA		;SUBTRACT 1 FROM MANTISSA BITS 
 1B96  32 ED                 C  DNT10:	XOR	CH,CH		;(CX)=SHIFT COUNT 
 1B98  E8 1BAD R             C  	CALL	$SHRD		;DOUBLE PRECISION SHIFT RIGHT 
 1B9B  9D                    C  	POPF			;RECALL SF 
 1B9C  79 03                 C  	JNS	DNT15		;IF POSITIVE PROCEED 
 1B9E  E8 1BC7 R             C  	CALL	ADD1D		;ADD 1 TO MANTISSA BITS 
 1BA1  C6 06 FFFF E 00       C  DNT15:	MOV	BYTE PTR $DFACL-1,LOW 0 ;ZERO THE OV
				ERFLOW BYTE 
 1BA6  9D                    C  	POPF			;SEE IF CALLED BY FOUT (CF=0) 
 1BA7  73 03                 C  	JNB	DNT20		;IF SO JUST RETURN 
 1BA9  E9 1C99 R             C  	JMP	$NORMD		;OTHERWISE NORMALIZE 
 1BAC  C3                    C  DNT20:	RET 
                             C   
 1BAD                        C  $SHRD:				;SHIFT RIGHT DOUBLE PRECISION 
                             C   
 1BAD  51                    C  SHRD10: PUSH	CX		;SAVE OUTER LOOP VARIABLE (BIT
				S TO 
                             C  				;BE SHIFTED RIGHT) 
 1BAE  53                    C  	PUSH	BX		;SAVE POINTER TO HIGH BYTE TO SHIFT 
 1BAF  F8                    C  	CLC			;CF=0 
 1BB0  E8 0950 R             C  	CALL	$SHDR		;SHIFT 1 BIT RIGHT 
 1BB3  5B                    C  	POP	BX 
 1BB4  59                    C  	POP	CX		;GET OUTER LOOP VARIABLE 
 1BB5  E2 F6                 C  	LOOP	SHRD10 
 1BB7  C3                    C  	RET 
                             C   
 1BB8  53                    C  DINTA:	PUSH	BX 
 1BB9  BB 0000 E             C  	MOV	BX,OFFSET $DFACL	;BEGINNING ADDRESS FOR SU
				BTRACT 
 1BBC  83 2F 01              C  DINA10: SUB	WORD PTR 0[BX],1	;NEED CF SO CAN'T 
				USE DEC 
 1BBF  73 04                 C  	JNB	DINA20 
 1BC1  43                    C  	INC	BX 
 1BC2  43                    C  	INC	BX		;CAN DO WORD SUBTRACTS SINCE HIGH BIT 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-118
$INT	 CONVERT PRESENT NO. TO INTEGER BY TRUNCATION          

                             C  				;OF MANTISSA IS SET (THUS PROTECTING 
                             C  				;THE EXPONENT FROM THE SUBTRACT) 
 1BC3  EB F7                 C  	JMP	SHORT DINA10 
 1BC5  5B                    C  DINA20: POP	BX 
 1BC6  C3                    C  	RET 
                             C   
 1BC7                        C  ADD1D:				;ADD 1 TO DOUBLE PRECISION MANTISSA B
				ITS 
 1BC7  53                    C  	PUSH	BX		; 
 1BC8  BB 0000 E             C  	MOV	BX,OFFSET $DFACL 
 1BCB  FE 07                 C  ADD10:	INC	BYTE PTR 0[BX] 
 1BCD  75 03                 C  	JNZ	ADD20 
 1BCF  43                    C  	INC	BX		;POINT TO NEXT BYTE THERE WAS A CARRY 
 1BD0  EB F9                 C  	JMP	SHORT ADD10 
 1BD2  5B                    C  ADD20:	POP	BX 
 1BD3  C3                    C  	RET 
                             C   
 1BD4                        C  INT: 
 1BD4                        C  $INT:				;SINGLE PRECISION INT FUNCTION 
 1BD4  8A 0E 0000 E          C  	MOV	CL,BYTE PTR $FAC	;FETCH EXPONENT 
 1BD8  80 E9 98              C  	SUB	CL,LOW 230	;CALCULATE SHIFT COUNT 
 1BDB  73 4C                 C  	JNB	INT20		;ALREADY INTEGER PROCEED 
 1BDD  F6 D9                 C  	NEG	CL		;GET POSITIVE SHIFT COUNT 
                             C  ; 
                             C  ; Note - At this point the carry is set.  This 
				will be used 
                             C  ; to indicate that this is not a QINT call.  Al
				so note that 
                             C  ; if the exponent is zero the above subtraction
				 did set the 
                             C  ; carry so the check for the zero exponent case
				 below is 
                             C  ; guaranteed to be executed. 
                             C  ; 
 1BDF                        C  QINTX:				; $QINTX'S ENTRY POINT 
 1BDF  8B 16 0000 E          C  	MOV	DX,WORD PTR $FACLO	;FETCH LOW MANTISSA BIT
				S 
 1BE3  8B 1E FFFF E          C  	MOV	BX,WORD PTR $FAC-1	;FETCH EXP,SIGN,HIGH MA
				NTISSA BITS 
 1BE7  FE C7                 C  	INC	BH		;Is the exponent zero?  (Test for zero
				 
 1BE9  FE CF                 C  	DEC	BH		;without affecting the carry.) 
 1BEB  75 05                 C  	JNE	QINTNZ		;No, proceed. 
 1BED  32 DB                 C  	XOR	BL,BL		;Yes, put zero into BL,DX for QINT 
 1BEF  33 D2                 C  	XOR	DX,DX		;rather than work with the possible
				 
 1BF1  C3                    C  	RET			;garbage in the mantissa (an exponent 
                             C  				;of zero means the number is zero). 
 1BF2  9C                    C  QINTNZ: PUSHF			;Save carry which if clear indi
				cates 
                             C  				;this is a QINT call. 
 1BF3  0A DB                 C  	OR	BL,BL		;SEE IF NEGATIVE 
 1BF5  9C                    C  	PUSHF			;SAVE 
 1BF6  88 1E 0001 E          C  	MOV	BYTE PTR $FAC+1,BL	;SAVE SIGN FOR NORMS 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-119
$INT	 CONVERT PRESENT NO. TO INTEGER BY TRUNCATION          

 1BFA  C6 06 0000 E 98       C  	MOV	BYTE PTR $FAC,LOW 230	;SET EXP FOR POST SH
				IFT 
 1BFF  80 CB 80              C  	OR	BL,LOW 200	;RESTORE HIDDEN 1 
 1C02  9D                    C  	POPF 
 1C03  9C                    C  	PUSHF			;SAVE SIGN 
 1C04  79 06                 C  	JNS	INT10		; 
 1C06  83 EA 01              C  	SUB	DX,1		;CAN'T DO A 'DEC' BECAUSE NEED CF 
 1C09  80 DB 00              C  	SBB	BL,LOW 0	;DO APPROPRIATE SUBTRACT TO HIGH 
				BYTE 
 1C0C  32 ED                 C  INT10:	XOR	CH,CH		;CX HAS LOOP COUNT 
 1C0E  0A C9                 C  	OR	CL,CL		;IF SHIFT COUNT ZERO MUST JUMP OVER 
 1C10  74 06                 C  	JZ	INT12		;RIGHT SHIFTS 
 1C12  D0 EB                 C  INT11:	SHR	BL,1		;SHIFT RIGHT INTO CF 
 1C14  D1 DA                 C  	RCR	DX,1		;ROTATE RIGHT 
 1C16  E2 FA                 C  	LOOP	INT11		;WILL DO (CX) RIGHT SHIFTS 
 1C18  9D                    C  INT12:	POPF			;RECALL SIGN OF NO. 
 1C19  9F                    C  	LAHF			;STORE FLAGS TEMPORARILY 
 1C1A  79 05                 C  	JNS	INT15		;PROCEED IF POSITIVE 
 1C1C  42                    C  	INC	DX 
 1C1D  75 02                 C  	JNZ	INT15 
 1C1F  FE C3                 C  	INC	BL 
 1C21                        C  INT15: 
 1C21  9D                    C  	POPF			;CF=0 IF CALLED BY QINT 
 1C22  73 05                 C  	JNB	INT20		;JUST RETURN IF QINT CALL 
 1C24  32 E4                 C  	XOR	AH,AH		;CLEAR OVERFLOW BYTE 
 1C26  E9 1CE4 R             C  	JMP	$NORMS		;NORMALIZE AND RETURN 
 1C29  9E                    C  INT20:	SAHF			;MUST SEE IF NEGATIVE 
 1C2A  79 0A                 C  NGBLDX: JNS	INT30		;IF NOT PROCEED AS NORMAL 
 1C2C  F7 D2                 C  	NOT	DX		;COMPLEMENT DX 
 1C2E  F6 D3                 C  	NOT	BL		;AND BL 
 1C30  83 C2 01              C  	ADD	DX,1		;NEED CF SET IF DX OVERFLOWS 
 1C33  80 D3 00              C  	ADC	BL,LOW 0	;2's COMPLEMENT NOW FORMED 
 1C36  C3                    C  INT30:	RET 
 1C37                        C  QINT: 
 1C37                        C  $QINT:				;DO INT(FAC) AND LEAVE IN (BLDX) 
 1C37  B1 98                 C  	MOV	CL,LOW 230 
 1C39  2A 0E 0000 E          C  	SUB	CL,BYTE PTR $FAC	;GET SHIFT COUNT TO CL 
 1C3D  F8                    C  	CLC			;CF=0 
 1C3E  EB 9F                 C  	JMP	SHORT QINTX	;LEAVE RIGHT ADJUSTED 
                             C   
                             C  	SUBTTL	 $LOG	 SINGLE PRECISION NATURAL LOG FUN
				CTION 
                             C  ;**********************************************
				************ 
                             C  ; 
                             C  ;       $LOG    COMPUTE THE NATURAL LOG OF THE 
				VALUE IN THE FAC 
                             C  ;       CALLING SEQUENCE:       CALL    $LOG 
                             C  ;               WITH INPUT ARGUMENT IN THE FAC 
                             C  ;       MLLN2   IF THIS ENTRY POINT IS USED THE
				 FAC WILL BE 
                             C  ;               MULTIPLIED BY LN(2) 
                             C  ; 
                             C  ;**********************************************
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-120
$LOG	 SINGLE PRECISION NATURAL LOG FUNCTION                 

				************** 
                             C   
 1C40                        C  LOG: 
 1C40  E8 08BE R             C  $LOG:	CALL	$SIGNS		;ERROR IF ($FAC).LE..0 
 1C43  7E 51                 C  	JLE	LG100 
                             C  ;**********************************************
				****************** 
                             C  ;       WILL NOW PERFORM SPECIAL TEST FOR ARGUM
				ENT OF 1.0 AND IF 
                             C  ;       FOUND EQUAL ANSWER IS 0 
                             C  ;**********************************************
				******************* 
 1C45  BA 0000               C  	MOV	DX,0		;FETCH 1.0 TO (BXDX) 
 1C48  BB 8100               C  	MOV	BX,100400 
 1C4B  E8 0A40 R             C  	CALL	$FCOMP 
 1C4E  75 09                 C  	JNZ	LOG10		;PROCEED IF NOT 1.0 
 1C50  89 16 0000 E          C  	MOV	WORD PTR $FACLO,DX	;WILL ZERO $FAC AND RET
				URN 
 1C54  89 16 0000 E          C  	MOV	WORD PTR $FACM1,DX 
 1C58  C3                    C  	RET 
 1C59                        C  LOG10: 
 1C59  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC	;FETCH EXPONENT 
 1C5C  2C 80                 C  	SUB	AL,LOW 200	;TAKE OUT BIAS 
 1C5E  98                    C  	CBW			;CONVERT BYTE TO WORD 
 1C5F  50                    C  	PUSH	AX		;AND SAVE 
 1C60  C6 06 0000 E 80       C  	MOV	BYTE PTR $FAC,LOW 200	;ZERO THE EXPONENT 
 1C65  E8 0BBD R             C  	CALL	$PUSHF		;SAVE ARG FOR Q(X) CALCULATION 
 1C68  BB 04A5 R             C  	MOV	BX,OFFSET $LOGP ;NOW TO USE HART APPROX FO
				R P(X) 
 1C6B  E8 1D30 R             C  	CALL	$POLY 
 1C6E  5A                    C  	POP	DX		;GET X OFF THE STACK 
 1C6F  5B                    C  	POP	BX 
 1C70  E8 0BBD R             C  	CALL	$PUSHF		;SAVE P(X) 
 1C73  E8 0A05 R             C  	CALL	$MOVFR		;MOVE X TO FAC 
 1C76  BB 04B6 R             C  	MOV	BX,OFFSET $LOGQ 
 1C79  E8 1D30 R             C  	CALL	$POLY		;CALCULATE Q(X) 
 1C7C  5A                    C  	POP	DX		;RECALL P(X) 
 1C7D  5B                    C  	POP	BX 
 1C7E  E8 15D6 R             C  	CALL	$FDIVS		;CALCULATE P(X)/Q(X) 
 1C81  5A                    C  	POP	DX		;FETCH RAW EXPONENT 
 1C82  E8 0BBD R             C  	CALL	$PUSHF		;SAVE FAC ON THE STACK 
 1C85  E8 184E R             C  	CALL	$FLT		;FLOAT THE VALUE INTO THE $FAC 
 1C88  5A                    C  	POP	DX		;RECALL LOG2 VALUE 
 1C89  5B                    C  	POP	BX 
 1C8A  E8 139F R             C  	CALL	$FADDS		;ADD 
 1C8D  BB 8031               C  MLLN2:	MOV	BX,100061	;FETCH LN(2) TO (BXDX) 
 1C90  BA 7218               C  	MOV	DX,71030 
 1C93  E9 191D R             C  	JMP	$FMULS		;MULTIPLY TO COMPLETE 
 1C96  E9 0000 E             C  LG100:	JMP	$FCERR 
                             C   
                             C  	SUBTTL	 $NORMD  DOUBLE PRECISION NORMALIZATION
				 ROUTINE 
                             C  ;**********************************************
				******************** 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-121
$NORMD  DOUBLE PRECISION NORMALIZATION ROUTINE              

                             C  ; 
                             C  ;       $NORMD  NORMALIZES THE NUMBER IN $FAC+1
				 THRU $DFACL-1 
                             C  ;               AND JUMPS TO $ROUND 
                             C  ;       CALLING SEQUENCE:       CALL    $NORMD 
                             C  ;               OR              JMP     $NORMD 
                             C  ;               WILL RESULT IN NORMALIZATION FO
				LLOWED BY ROUNDING 
                             C  ;               AND PACKING THE $FAC. 
                             C  ; 
                             C  ;**********************************************
				********************* 
                             C   
 1C99  B2 39                 C  $NORMD: MOV	DL,LOW 71	;MAX BITS TO SHIFT LEFT 
 1C9B  BB FFFF E             C  	MOV	BX,OFFSET $DFACL-1 
 1C9E  BF FFFF E             C  NORD5:	MOV	DI,OFFSET $FAC-1 
 1CA1  BE 0000 E             C  	MOV	SI,OFFSET $FAC 
 1CA4  EB 15                 C  	JMP	SHORT NORD30 
 1CA6                        C  NORD10: 
 1CA6  B9 0004               C  	MOV	CX,4 
 1CA9  F8                    C  	CLC			;CF=0 
 1CAA  D1 17                 C  NORD20: RCL	WORD PTR 0[BX],1 
 1CAC  43                    C  	INC	BX 
 1CAD  43                    C  	INC	BX		;POINT TO NEXT WORD 
 1CAE  E2 FA                 C  	LOOP	NORD20 
 1CB0  BB FFFF E             C  	MOV	BX,OFFSET $DFACL-1	;POINT BACK TO END OF N
				UMBER 
 1CB3                        C  NORD25: 
 1CB3  FE 0C                 C  	DEC	BYTE PTR 0[SI]	;DECREMENT EXPONENT 
 1CB5  74 25                 C  	JZ	NORD40		;DO CLEAN-UP IF UNDERFLOW 
 1CB7  FE CA                 C  	DEC	DL		;SEE IF MAX BITS SHIFTED 
 1CB9  74 21                 C  	JZ	NORD40		;IF SO TERMINATE SHIFTS 
 1CBB  F6 05 FF              C  NORD30: TEST	BYTE PTR 0[DI],LOW 377	;SF=1 IF NO
				W NORMALIZED 
 1CBE  78 1C                 C  	JS	NORD40		;NORMALIZED 
                             C   
 1CC0  75 E4                 C  	JNZ	NORD10		;MUST SHIFT BIT AT A TIME 
                             C  ;**********************************************
				***************** 
                             C  ;CAN DO AT 1 BYTE MOVE LEFT 
                             C  ;**********************************************
				***************** 
 1CC2  80 2C 08              C  	SUB	BYTE PTR 0[SI],LOW 10	;SUBTRACT 8 
 1CC5  76 15                 C  	JBE	NORD40		;UNDERFLOW 
 1CC7  80 EA 08              C  	SUB	DL,LOW 10	;SEE IF MAX BITS SHIFTED 
 1CCA  76 10                 C  	JBE	NORD40		;AND IF SO QUIT 
 1CCC  BE FFFE E             C  	MOV	SI,OFFSET $FAC-2 
 1CCF  B9 0007               C  	MOV	CX,7		;7 BYTES TO MOVE 
 1CD2  FD                    C  	STD			;SO FOLLOWING MOVB WILL DECREMENT 
                             C  		     ;REPEAT CX TIMES (THE MOVB) 
 1CD3  F3/ A4                C   REP	MOVSB			;MOVE 
 1CD5  C6 06 FFFF E 00       C  	MOV	BYTE PTR $DFACL-1,LOW 0 ;ZERO OVERFLOW 
 1CDA  EB C2                 C  	JMP	SHORT NORD5	;SEE IF MORE CASES 
 1CDC  76 03                 C  NORD40: JBE	NORD50		;UNDERFLOW JUMP 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-122
$NORMD  DOUBLE PRECISION NORMALIZATION ROUTINE              

 1CDE  E9 1F8C R             C  	JMP	$ROUND 
 1CE1                        C  NORD50: 
 1CE1  E9 08A7 R             C  	JMP	$DZERO 
                             C   
                             C  	SUBTTL	 $NORMS  SINGLE PRECISION NORMALIZATION
				 ROUTINE 
                             C  ;**********************************************
				************** 
                             C  ; 
                             C  ;       $NORMS  SINGLE PRECISION NORMALIZATION 
				ROUTINE 
                             C  ;               $NORMS SHIFTS (BLDXAH) LEFT UNT
				IL THE SIGN 
                             C  ;               BIT OF (BL)IS 1. FOR EACH LEFT 
				SHIFT 
                             C  ;               $NORMS WILL DECREMENT THE FAC 
                             C  ;               ONCE THIS PROCESS IS COMPLETE, 
				$NORMS WILL 
                             C  ;               JUMP TO $ROUNS TO ROUND THE NUM
				BER AND 
                             C  ;               PACK IT INTO THE FAC BYTES. 
                             C  ; 
                             C  ;**********************************************
				*************** 
                             C   
 1CE4                        C  $NORMS: 
 1CE4  8A 3E 0000 E          C  	MOV	BH,BYTE PTR $FAC	;EXPONENT TO BH 
 1CE8  B9 0004               C  	MOV	CX,4 
 1CEB  0A DB                 C  NOR10:	OR	BL,BL		;SEE IF SIGN BIT SET 
 1CED  78 21                 C  	JS	NOR20		;IF SO NORMALIZATION COMPLETE 
 1CEF  75 11                 C  	JNZ	NOR15		;UPPER BYTE NON-ZERO 
 1CF1  80 EF 08              C  	SUB	BH,LOW 10	;CAN WE SUBTRACT 8 W/O UNDERFLOW
				? 
 1CF4  76 17                 C  	JBE	NOR17 
 1CF6  8A DE                 C  	MOV	BL,DH 
 1CF8  8A F2                 C  	MOV	DH,DL 
 1CFA  8A D4                 C  	MOV	DL,AH 
 1CFC  32 E4                 C  	XOR	AH,AH		;CLEAR OVERFLOW BYTE 
 1CFE  E2 EB                 C  	LOOP	NOR10 
 1D00  74 0B                 C  	JZ	NOR17		;UNDERFLOW! 
 1D02                        C  NOR15: 
 1D02  F8                    C  	CLC			;CLEAR CARRY FLAG [CF] 
 1D03  D0 D4                 C  	RCL	AH,1		;SHIFT OVERFLOW BYTE LEFT. 
 1D05  D1 D2                 C  	RCL	DX,1		;SHIFT LOWER MANTISSA WORD LEFT 
 1D07  D0 D3                 C  	RCL	BL,1		;SHIFT HIGH MANTISSA BYTE LEFT 
 1D09  FE CF                 C  NOR16:	DEC	BH		;DECREMENT EXPONENT 
 1D0B  75 DE                 C  	JNZ	NOR10		;CONTINUE UNLESS UNDERFLOW 
 1D0D  E9 08B4 R             C  NOR17:	JMP	$ZERO		;ZERO THE FAC AND RETURN 
 1D10  88 3E 0000 E          C  NOR20:	MOV	BYTE PTR $FAC,BH	;UPDATE EXPONENT 
 1D14  E9 1FC6 R             C  	JMP	$ROUNS 
                             C   
                             C  	SUBTTL $POLY	 SINGLE PRECISION POLYNOMIAL EVAL
				UATOR 
                             C  ;**********************************************
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-123
$POLY	 SINGLE PRECISION POLYNOMIAL EVALUATOR                

				*********** 
                             C  ; 
                             C  ;       $POLY   EVALUATES THE POLYNOMIAL: 
                             C  ;                       P(X)=C0+C1X+C2X2+...+CN
				XN 
                             C  ;               THE EVALUATION IS ACCOMPLISHED 
				VIA HORNER'S 
                             C  ;               RULE (SEE "THE ART OF COMPUTER 
				PROGRAMMING" 
                             C  ;               VOL.2 PP423, BY KNUTH) 
                             C  ;       $POLYX  PERFORMS THE EVALUATION X(P(X**
				2)) ON THE 
                             C  ;               POLYNOMIAL MENTIONED ABOVE 
                             C  ;       CALLING SEQUENCE:       CALL $POLY 
                             C  ;               OR              CALL    $POLYX 
                             C  ;               WITH X STORED IN THE $FAC AND (
				BX) 
                             C  ;               POINTING TO THE FOLLOWING: 
                             C  ;                                       N+1 
                             C  ;                                       CN 
                             C  ;                                       CN-1 
                             C  ;                                       . 
                             C  ;                                       . 
                             C  ;                                       . 
                             C  ;                                       C0 
                             C  ; 
                             C  ;**********************************************
				************* 
                             C   
 1D17                        C  $POLYX: 
 1D17  8B 16 0000 E          C  	MOV	DX,WORD PTR $FACLO	;FETCH LOW BYTES 
 1D1B  8B 2E 0000 E          C  	MOV	BP,WORD PTR $FACM1	;AND HIGH BYTES 
 1D1F  52                    C  	PUSH	DX		;SAVE X ON THE STACK 
 1D20  55                    C  	PUSH	BP		; 
 1D21  53                    C  	PUSH	BX		;SAVE COEFFICIENT POINTER 
 1D22  8B DD                 C  	MOV	BX,BP		;(BXDX)=X 
 1D24  E8 191D R             C  	CALL	$FMULS		;FORM X**2 
 1D27  5B                    C  	POP	BX		;RECALL COEFFICIENT POINTER 
 1D28  E8 1D30 R             C  	CALL	$POLY		;FORM P(X**2) 
 1D2B  5B                    C  	POP	BX		;FETCH X TO REGISTERS 
 1D2C  5A                    C  	POP	DX 
 1D2D  E9 191D R             C  	JMP	$FMULS 
                             C   
 1D30  FC                    C  $POLY:	CLD			;9-Aug-82/MLC - Good for LODC, MOV
				W, 
                             C  				;and MOVW down to POL10. 
 1D31  8B F3                 C  	MOV	SI,BX		;SO WE CAN USE STRING MOVES 
                             C  				;MUST FETCH FROM THE CODE SEG 
 1D33  2E: AC                C  	LODS	BYTE PTR ?CSLAB ;FETCH NUMBER OF COEFFICI
				ENTS 
 1D35  98                    C  	CBW			;(AH)=0 
 1D36  50                    C  	PUSH	AX		;PUSH NUMBER ELEMENTS ON STACK 
 1D37  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 ;SAVE THE FAC ON THE STAC
				K 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-124
$POLY	 SINGLE PRECISION POLYNOMIAL EVALUATOR                

 1D3B  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 1D3F  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
                             C  				;WANT TO FETCH COEFF FROM 
 1D42  2E: A5                C  	MOVS	WORD PTR ES:[DI],WORD PTR CS:[SI] 
                             C  				;FETCH FROM CODE SEGMENT 
 1D44  2E: A5                C  	MOVS	WORD PTR ES:[DI],WORD PTR CS:[SI] 
 1D46                        C  POL10: 
 1D46  5A                    C  	POP	DX		;FETCH LOW X 
 1D47  5B                    C  	POP	BX		;FETCH HIGH X 
 1D48  58                    C  	POP	AX		;RECALL COEFFICIENT COUNTER 
 1D49  48                    C  	DEC	AX		;DECREMENT 
 1D4A  74 16                 C  	JZ	POL30		;JUMP WHEN COMPLETE 
 1D4C  50                    C  	PUSH	AX		;SAVE COUNTER 
 1D4D  53                    C  	PUSH	BX		;SAVE X ON THE STACK 
 1D4E  52                    C  	PUSH	DX 
 1D4F  56                    C  	PUSH	SI		;SAVE POINTER TO COEFFICIENTS 
 1D50  E8 191D R             C  	CALL	$FMULS		;MULTIPLY BY X 
 1D53  5E                    C  	POP	SI		;FETCH COEFFICIENT POINTER 
 1D54  FC                    C  	CLD			;9-Aug-82/MLC - Good for next two 
                             C  				;LODWs. 
                             C  				;MUST FETCH FROM CODE SEGMENT 
 1D55  2E: AD                C  	LODS	WORD PTR ?CSLAB ;FETCH LOW WORD 
 1D57  92                    C  	XCHG	AX,DX 
                             C  				;MUST FETCH FROM CODE SEGMENT 
 1D58  2E: AD                C  	LODS	WORD PTR ?CSLAB ;FETCH HIGH WORD 
 1D5A  93                    C  	XCHG	AX,BX 
 1D5B  56                    C  	PUSH	SI		;SAVE COEFFICIENT POINTER 
 1D5C  E8 139F R             C  	CALL	$FADDS		;ADD IT IN 
 1D5F  5E                    C  	POP	SI		;GET POINTER BACK 
 1D60  EB E4                 C  	JMP	SHORT POL10 
 1D62                        C  POL30:				;CLEAR THE STACK 
 1D62  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $PUF	 PRINT-USING FOR FLOATING POINT N
				UMBERS 
                             C  ;**********************************************
				**************** 
                             C  ; 
                             C  ;       $PUF    THIS ROUTINE ACCEPTS EITHER SIN
				GLE OR DOUBLE 
                             C  ;               PRECISION FLOATING VALUES AND F
				ORMATS THEM 
                             C  ;               ACCORDING TO INPUT FORMATS. BOT
				H FIXED AND 
                             C  ;               "E" TYPE FORMATS ARE PRODUCED B
				Y THIS CODE 
                             C  ;       CALLING SEQUENCE:       CALL    $PUF 
                             C  ;               WITH FLOATING POINT VALUE IN TH
				E FAC, (BX) POINTING 
                             C  ;               TO THE NEXT PRINT POSITION IN T
				HE OUTPUT BUFFER 
                             C  ;               AND FORMAT SPECIFICATIONS IN AX
				, AND CX. 
                             C  ;               $FMTAX LOADED INTO (AX) WILL CO
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-125
$PUF	 PRINT-USING FOR FLOATING POINT NUMBERS                

				NTAIN COMMA COUNT 
                             C  ;               IN (AH) AND THE FOLLOWING FORMA
				T IN (AL): 
                             C  ;               BIT     7       =0 FREE FORMAT 
				OUTPUT, NUMBER DICTATES 
                             C  ;                               OUTPUT FORMAT 
                             C  ;                               =1 PRINT USING 
				OUTPUT. THE REMAINDER OF 
                             C  ;                               (AL) AND (CX) D
				ICTATE HOW THE NUMBER IS 
                             C  ;                               TO BE PRINTED 
                             C  ;                       6       IF =1 GROUP THE
				 DIGITS IN THE INTEGER 
                             C  ;                               PART IN GROUPS 
				OF THREE AND SEPARATE 
                             C  ;                               WITH COMMAS. 
                             C  ;                       5       IF =1 FILL THE 
				LEADING SPACES IN THE 
                             C  ;                               FIELD WITH ASTE
				RISKS "*" 
                             C  ;                       4       IF =1 OUTPUT TH
				E NUMBER WITH A FLOATING 
                             C  ;                               DOLLAR SIGN "$"
				 
                             C  ;                       3       IF =1 PRINT THE
				 SIGN OF THE NUMBER WITH 
                             C  ;                               A PLUS "+" IF P
				OSITIVE INSTEAD OF A SPC 
                             C  ;                       2       IF =1 PRINT THE
				 SIGN AFTER THE NUMBER 
                             C  ;                       1       UNUSED 
                             C  ;                       0       IF =1 PRINT THE
				 NUMBER IN SCIENTIFIC 
                             C  ;                               NOTATION AND IG
				NORE BIT 6. 
                             C  ;                               IF =0 USE FIXED
				 POINT NOTATION. 
                             C  ;               $FMTCX WILL HAVE THE FOLLOWING 
				FORMAT LOADED IN (CX) 
                             C  ;               (CH)    NUMBER PLACES IN FIELD 
				TO LEFT OF DECIMAL POINT 
                             C  ;                       (DOES NOT INCLUDE THE D
				ECIMAL POINT) 
                             C  ;               (CL)    NUMBER PLACES IN THE FI
				ELD TO THE RIGHT OF THE 
                             C  ;                       DECIMAL POINT (INCLUDES
				 DECIMAL POINT) 
                             C  ; 
                             C  ;**********************************************
				****************** 
                             C   
 1D63                        C  $PUF: 
 1D63  53                    C  	PUSH	BX		;SAVE OUTPUT BUFFER POINTER 
 1D64  D0 E8                 C  	SHR	AL,1		;CF=1 IF "E" FORMAT DESIRED 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-126
$PUF	 PRINT-USING FOR FLOATING POINT NUMBERS                

 1D66  73 03                 C  	JNB	PUF10		;IF FIXED PROCEED 
 1D68  E9 015E R             C  	JMP	$PUFE		;GO DO IT 
 1D6B                        C  PUF10: 
                             C  ;**********************************************
				******************** 
                             C  ;KNOW THAT A FIXED FORMAT IS DESIRED. THE FOLLO
				WING ANALYSIS WILL 
                             C  ;BE PERFORMED:  (1) SEE IF NO. IS .GE. 10^16 , 
				AND IF SO 
                             C  ;GO PRINT WITH $FOUT AND INSERT A LEADING "%". 
				(2) BRACKET THE 
                             C  ;PRINTABLE DIGITS IN THE INTEGER PART OF THE NU
				MBER WITH $FOTNV 
                             C  ;(3) SEE IF LEADING ZEROS ARE REQUIRED(THE POSI
				TIONS SPECIFIED 
                             C  ;TO THE LEFT OF THE DECIMAL POINT ARE MORE THAN
				 THE AVAILABLE 
                             C  ;DIGITS TO LEFT OF DECIMAL POINT). (4) SEE IF T
				HE SUM OF THE DIGITS 
                             C  ;ON THE LEFT PLUS THOSE ON THE RIGHT ARE LESS T
				HAN THE AVAILABLE 
                             C  ;DIGITS,I.E. WE HAVE MORE PRINTABLE DIGITS THAN
				 REQUIRED. IF THIS 
                             C  ;IS THE CASE WE MUST SHIFT THE NUMBER RIGHT SO 
				THAT WE CAN ROUND IT 
                             C  ;AT THE CORRECT POSITION. (5) PUT IN THE PRINTA
				BLE DIGITS. (6) SEE 
                             C  ;IF TRAILING ZEROS ARE REQUIRED(SPECIFIED DIGIT
				S TO THE RIGHT 
                             C  ;WERE IN EXCESS OF DIGITS AVAILABLE) 
                             C  ;**********************************************
				********************** 
 1D6B  BB 03E1 R             C  	MOV	BX,OFFSET $DP16 ;WILL FIRST SEE IF NO. TOO
				 LARGE 
 1D6E  E8 09BB R             C  	CALL	$MOVBF		;NO. MOVED TO DBUFF FOR COMPARISO
				N 
                             C  				;(IT WAS PREVIOUSLY IN CODE SEGMENT) 
 1D71  E8 0A38 R             C  	CALL	$VCOMP		;(FAC)-10^16(CF=1 IF OK) 
 1D74  72 09                 C  	JB	PUF30		;JUMP IF SMALL ENOUGH TO PROCESS 
                             C  ;**********************************************
				******************** 
                             C  ;NO. WAS TOO LARGE TO PRINT WITH FIXED FORMAT. 
				MUST PRINT IN FREE- 
                             C  ;FORMAT WITH $FOUT AND INSERT A LEADING "%" TO 
				INDICATE IT OVERFLOWED 
                             C  ;THE SPECIFIED PRINT FIELD 
                             C  ;**********************************************
				********************* 
 1D76  5B                    C  	POP	BX		;RECALL PRINT BUFFER POINTER 
 1D77  E8 1B3E R             C  	CALL	$FOUT		;PRINT IN FREE-FORMAT 
 1D7A  4B                    C  	DEC	BX		;POINT TO POSITION 1 
 1D7B  C6 07 25              C  	MOV	BYTE PTR 0[BX],LOW "%"  ;PUT IN OVERFLOW I
				NDICATOR 
 1D7E  C3                    C  	RET			;DONE 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-127
$PUF	 PRINT-USING FOR FLOATING POINT NUMBERS                

 1D7F                        C  PUF30: 
                             C  ;**********************************************
				********************** 
                             C  ;ALL WE KNOW AT THIS POINT IS THAT IT IS POSSIB
				LE TO PRINT THE 
                             C  ;NUMBER WITH A FIXED FORMAT, DO NOT KNOW THE SP
				ECIFIED FIXED FORMAT 
                             C  ;IS SUFFICIENT. WHAT WE WILL DO IS FORMAT THE N
				UMBER IN FIXED FORMAT 
                             C  ;AND THEN JUMP TO $PUFXE AND LET HIM DETERMINE 
				IF THE NUMBER WAS 
                             C  ;WITHIN THE SPECIFIED FORMAT. 
                             C  ;**********************************************
				********************** 
 1D7F  E8 08EE R             C  	CALL	$GETYP		;DETERMINE TYPE 
 1D82  B5 10                 C  	MOV	CH,LOW 20	;ASSUME DOUBLE PREC. (16 PRINTAB
				LE POS) 
 1D84  73 02                 C  	JNB	PUF40 
                             C   
                             C   
 1D86  B5 07                 C  	MOV	CH,LOW 7	;7 print positions if single prec
				ision 
                             C   
 1D88  E8 08BE R             C  PUF40:	CALL	$SIGNS		;SEE IF NO. IS ZERO 
 1D8B  74 03                 C  	JZ	PUF50		;IF SO DON'T CALL $FOTNV 
 1D8D  E8 1AC0 R             C  	CALL	$FOTNV		;BRACKET NO. SO ALL PRINTABLE DIG
				ITS 
                             C  				;IN THE INTEGER PART OF THE NUMBER AND 
                             C  				;RETURN COMPLEMENTING EXPONENT IN (AL) 
                             C  				;AND SF=1 IF THIS EXPONENT IS NEG. 
                             C  				;(THERE ARE DIGITS TO RIGHT OF D.P) 
 1D90  5B                    C  PUF50:	POP	BX		;GET OUTPUT BUFFER POINTER BACK 
 1D91  78 3F                 C  	JS	PUF80		;GO PRINT NO. WITH DIGITS TO RIGHT 
                             C  				;OF DECIMAL POINT 
                             C  ;**********************************************
				*********************** 
                             C  ;KNOW AT THIS POINT WE HAVE A NUMBER LESS THAN 
				10^16 THAT HAS NO 
                             C  ;PRINTABLE DIGITS TO RIGHT OF THE DECIMAL POINT
				. THEREFORE WE HAVE 
                             C  ;TO PUT IN LEADING ZEROS IF THE SPECIFIED PRINT
				 POSITIONS TO THE LEFT 
                             C  ;OF THE DECIMAL POINT ARE MORE THAN THE PRINTAB
				LE POSITIONS (CH) 
                             C  ;AND THE POSITIVE EXPONENT IN (AL) 
                             C  ;**********************************************
				********************** 
 1D93  8A D0                 C  	MOV	DL,AL		;SAVE THIS POSITIVE EXP. FOR LATER 
 1D95  02 C5                 C  	ADD	AL,CH		;THIS IS NECESSARY PRINT POSITIONS 
                             C  				;TO ACCOMODATE THIS NUMBER. 
 1D97  2A 06 0001 E          C  	SUB	AL,BYTE PTR $FMTCX+1	;SUBTRACT DIGITS TO L
				EFT 
 1D9B  79 05                 C  	JNS	PUF60		;NO LEADING ZEROS REQUIRED 
 1D9D  F6 D8                 C  	NEG	AL		;MUST MAKE (AL) POSITIVE FOR $FOTZ 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-128
$PUF	 PRINT-USING FOR FLOATING POINT NUMBERS                

 1D9F  E8 0145 R             C  	CALL	$FOTZ		;PUT IN (AL) LEADING ZEROS 
 1DA2  32 C9                 C  PUF60:	XOR	CL,CL		;ZERO CREATED ZEROS 
 1DA4  E8 1E61 R             C  	CALL	DPCOM		;SET-UP DECIMAL POINT AND COMMA CT
				. 
 1DA7  FF 36 0000 E          C  	PUSH	WORD PTR $FMTCX ;SAVE DECIMAL POINT INFO.
				 
 1DAB  52                    C  	PUSH	DX		;SAVE EXPONENT 
 1DAC  E8 19C4 R             C  	CALL	$FOTCV		;CONVERT THE BINARY NO. TO ASCII 
				DIGITS 
                             C  				;NOTE THAT $FOTCV WILL ONLY CONVERT 
                             C  				;THE PRINTABLE DIGITS. IF THERE WAS A 
                             C  				;NON-ZERO EXPONENT AS WELL WE MUST 
                             C  				;INSERT SOME ZEROS PRIOR TO THE DECIMAL 
                             C  				;POINT. FURTHER WE MUST PAY ATTENTION 
                             C  				;TO OUR COMMA COUNT WHILE INSERTING 
                             C  				;THESE ZEROS. 
 1DAF  5A                    C  	POP	DX		;RECALL EXPONENT 
 1DB0  8F 06 0000 E          C  	POP	WORD PTR $FMTCX ;RECALL DECIMAL POINT INFO
				. 
 1DB4  FF 36 0000 E          C  	PUSH	WORD PTR $FMTCX ;SAVE DESIRED POSITIONS L
				EFT/RT. 
 1DB8  32 C0                 C  	XOR	AL,AL		;WANT DL IN AL WITH APPROPRIATE SIG
				NS 
 1DBA  0A C2                 C  	OR	AL,DL		;DL=EXPONENT 
 1DBC  74 06                 C  	JZ	PUF70		;IF NO ZEROS PRIOR TO D.P. JUMP 
 1DBE  E8 0155 R             C  	CALL	$FOTZC		;PUT IN ZEROS AND PAY ATTENTION T
				O 
                             C  				;COMMA COUNT. 
 1DC1  E8 19A5 R             C  	CALL	$FOTED		;PUT IN DECIMAL POINT 
 1DC4  8F 06 0000 E          C  PUF70:	POP	WORD PTR $FMTCX ;RECALL DESIRED POSI
				TIONS LEFT/RT. 
 1DC8  FF 36 0000 E          C  	PUSH	WORD PTR $FMTCX ;AND SAVE AGAIN 
 1DCC  A0 0000 E             C  	MOV	AL,BYTE PTR $FMTCX	;FETCH NO. POSITIONS TO
				 RT. OF D.P. 
 1DCF  E9 1EED R             C  	JMP	$PUIZ		;GO PUT IN ANY REQUIRED TRAILING ZE
				ROS 
                             C  				;AND CHECK TO ASSURE FIELD SPECS. MET 
 1DD2                        C  PUF80: 
                             C  ;**********************************************
				********************** 
                             C  ;AT THIS POINT WE KNOW WE HAVE PRINTABLE DIGITS
				 TO THE RIGHT OF THE 
                             C  ;DECIMAL POINT . WE KNOW THIS BECAUSE $FOTNV WA
				S CALLED TO BRACKET 
                             C  ;THE NO. SUCH THAT THE PRINTABLE DIGITS WERE IN
				 THE INTEGER PART 
                             C  ;OF THE NUMBER AND THE COMPLEMENTING EXPONENT W
				AS IN (AL). FURTHER 
                             C  ;SF=1 WAS SET TO INDICATE (AL) WAS NEGATIVE. 
                             C  ;WE FURTHER NEED TO DETERMINE IF WE NEED TO ROU
				ND SOMEWHERE 
                             C  ;WITHIN THE PRINTABLE DIGITS. THIS WILL BE THE 
				CASE IF THE 
                             C  ;DIGITS TO BE PRINTED TO THE RIGHT IS LESS THAN
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-129
$PUF	 PRINT-USING FOR FLOATING POINT NUMBERS                

				 THOSE AVAILABLE 
                             C  ;TO THE RIGHT. (AL) HAS THOSE AVAILABLE TO THE 
				RIGHT, $FMTCX HAS 
                             C  ;THOSE DESIRED. 
                             C  ;**********************************************
				***************** 
 1DD2  8A D0                 C  	MOV	DL,AL		;SAVE THE COMPLEMENTING EXPONENT 
 1DD4  A0 0000 E             C  	MOV	AL,BYTE PTR $FMTCX	;FETCH DIGITS DESIRED T
				O RIGHT 
 1DD7  0A C0                 C  	OR	AL,AL		;IF NON-ZERO MUST SUBTRACT 1 
                             C  				;BECAUSE DECIMAL POINT INCLUDED 
 1DD9  74 02                 C  	JZ	PUF90		;PROCEED IF NO DIG. TO RT. DESIRED 
 1DDB  FE C8                 C  	DEC	AL		;TAKE OUT FOR DECIMAL POINT COUNT 
 1DDD  8A F0                 C  PUF90:	MOV	DH,AL		;SAVE DESIRED DIGITS TO RIGHT
				 COUNT 
 1DDF  02 C2                 C  	ADD	AL,DL		;SUBTRACT DIGITS AVAILABLE TO RT. 
                             C  				;(THIS IS A SUBTRACT BECAUSE (DL) IS 
                             C  				;THE NEGATIVE TO DIGITS TO RT.) 
 1DE1  8A C8                 C  	MOV	CL,AL		;WILL NEED THIS FOR LATER. IT 
                             C  				;IS THE NEGATIVE OF THE NUMBER 
                             C  				;OF DIGITS WE ARE ABOUT TO SHIFT 
                             C  				;OFF TO THE RIGHT 
 1DE3  78 06                 C  	JS	PUF100		;JUMP IF INTERNAL ROUNDING NECESSAR
				Y 
 1DE5  32 C0                 C  	XOR	AL,AL		;WILL NEED ALL PRINTABLE DIGITS 
 1DE7  8A C8                 C  	MOV	CL,AL		;NO DIGITS SHIFTED OFF 
 1DE9  EB 11                 C  	JMP	SHORT PUF110	;DO NOT NEED TO DIVIDE IF POS
				ITIVE 
 1DEB  50                    C  PUF100: PUSH	AX 
 1DEC  51                    C  	PUSH	CX		;SAVE GENERATED LEADING ZEROS 
 1DED  52                    C  	PUSH	DX		; 
 1DEE  53                    C  	PUSH	BX 
 1DEF  E8 0914 R             C  	CALL	$DIV10		;NEED TO ELIMINATE EXCESS PRINTAB
				LE 
 1DF2  5B                    C  	POP	BX 
 1DF3  5A                    C  	POP	DX 
 1DF4  59                    C  	POP	CX		;RECALL GENERATED LEADING ZEROS 
 1DF5  58                    C  	POP	AX		;RECALL EXCESS DIGITS 
 1DF6  FE C0                 C  	INC	AL		;BECAUSE AL WAS ORIGINALLY NEGATIVE 
 1DF8  78 F1                 C  	JS	PUF100		;CONTINUE FOR INTERNAL ROUNDING 
 1DFA  8A E1                 C  	MOV	AH,CL		;WILL NEED CREATED LEADING ZEROS 
                             C  				;LATER 
 1DFC                        C  PUF110: 
 1DFC  8A C2                 C  	MOV	AL,DL		;GET NEGATIVE EXPONENT 
 1DFE  2A C1                 C  	SUB	AL,CL		;ADD CREATED ZEROS 
 1E00  02 C5                 C  	ADD	AL,CH		;IF SF=1 THEN NO DIGITS TO LEFT 
 1E02  79 20                 C  	JNS	PUF120		;JUMP IF DIGITS TO LEFT OF DECIMAL
				 PT 
                             C  ;**********************************************
				******************** 
                             C  ;WE KNOW HERE THAT THE ENTIRE PRINTABLE DIGITS 
				GO TO THE RIGHT OF 
                             C  ;THE DECIMAL POINT. IF DIGITS WERE REQUESTED TO
				 THE LEFT THEN WE 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-130
$PUF	 PRINT-USING FOR FLOATING POINT NUMBERS                

                             C  ;NEED TO INSERT LEADING ZEROS 
                             C  ;**********************************************
				********************** 
 1E04  A0 0001 E             C  	MOV	AL,BYTE PTR $FMTCX+1	;DESIRED LEADING DIGI
				TS 
 1E07  E8 0145 R             C  	CALL	$FOTZ		;INSERT (AL) LEADING ZEROS 
 1E0A  C6 07 2E              C  	MOV	BYTE PTR 0[BX],LOW "."  ;PUT IN DECIMAL PO
				INT 
 1E0D  89 1E 0000 E          C  	MOV	WORD PTR $DPADR,BX	;*** Save DP position f
				or $FOTED, etc. *** 
 1E11  43                    C  	INC	BX		;NEXT BUFFER POSITION 
 1E12  32 C9                 C  	XOR	CL,CL		;COMMA COUNT TO ZERO 
                             C  ;**********************************************
				************ 
                             C  ;OK WE'VE PUT IN THE REQUIRED LEADING ZEROS PRI
				OR 
                             C  ;TO THE DECIMAL POINT. WE MAY FURTHER NEED TO P
				UT IN A FEW 
                             C  ;AFTER THE DECIMAL POINT. WE KNOW THAT THE EXPO
				NENT IS 
                             C  ;GREATER IN ABSOLUTE VALUE THAN THE NO. OF PRIN
				TABLE DIGITS. 
                             C  ;THE NUMBER OF LEADING ZEROS REQUIRE HERE THEN 
				IS ABS. 
                             C  ;VALUE OF THE EXPONENT LESS PRINTABLE DIGITS 
                             C  ;**********************************************
				************ 
 1E14  8A C6                 C  	MOV	AL,DH		;Get number of digits after decimal
				 point 
 1E16  2A C5                 C  	SUB	AL,CH		;Subtract number that will be print
				ed by $FOTCV 
 1E18  E8 0145 R             C  	CALL	$FOTZ		;PUT IN (AL) LEADING ZEROS 
 1E1B  33 C9                 C  	XOR	CX,CX		;*** No longer need comma & decimal
				 info *** 
 1E1D  52                    C  	PUSH	DX		;*** 8-Mar-82/ngt Fix                
				    *** 
 1E1E  FF 36 0000 E          C  	PUSH	WORD PTR $FMTCX ;*** Balance number of PU
				SHes and POPs   *** 
 1E22  EB 16                 C  	JMP	SHORT PUF140	;GO PUT IN THE DIGITS 
 1E24                        C  PUF120: 
                             C  ;**********************************************
				********************* 
                             C  ;WE KNOW HERE THAT THERE ARE DIGITS TO THE LEFT
				 OF THE DEC.PT. 
                             C  ;WE NEED TO DETERMINE IF LEADING ZEROS ARE REQU
				IRED. THEY WILL BE 
                             C  ;REQUIRED IF THE SPECIFIED DIGITS TO THE LEFT I
				S GREATER THAN 
                             C  ;THE NUMBER OF PRINTABLE DIGITS LESS THOSE TO T
				HE RIGHT. RECALL THAT 
                             C  ;EARLIER WE PUT THE NUMBER OF PRINTABLE DIGITS 
				IN (CH). DUE TO THE 
                             C  ;ABOVE CODE WE MAY HAVE INCREASED THE NUMBER OF
				 DIGITS AVAILABLE TO 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-131
$PUF	 PRINT-USING FOR FLOATING POINT NUMBERS                

                             C  ;THE LEFT BECAUSE WE SHIFTED THE NUMBER RIGHT B
				RINGING IN LEADING 
                             C  ;ZEROS. FOR EXAMPLE: IF WE GOT HERE WITH THE NU
				MBER 12.78575 $FOTNV 
                             C  ;WOULD HAVE 1278575. IN THE FAC AND -5 IN (AL),
				 IF FURTHER THE INPUT 
                             C  ;FORMAT HAD BEEN ########.## WE WOULD HAVE SHIF
				TED THE NUMBER 3 DIGITS 
                             C  ;RIGHT FOR ROUNDING PURPOSES LEAVING 1278.575 I
				N THE FAC AND -3 IN 
                             C  ;(CL). ONCE WE GO TO $FOTCV , HE SHALL PRODUCE 
				THE DIGITS 
                             C  ;00012.79 SO THE FORMULA FOR LEADING ZEROS IS: 
                             C  ;LEADING ZEROS=DESIRED DIGITS-[(CH)+(DL)-(CL)] 
                             C  ;               =DESIRED DIGITS-(CH)-(DL)+(CL) 
                             C  ;OR AS IN THIS EXAMPLE,LEADING ZEROS=8-[7+(-5)-
				(-3)]=3 
                             C  ;**********************************************
				*********************** 
 1E24  A0 0001 E             C  	MOV	AL,BYTE PTR $FMTCX+1	;FETCH DESIRED DIGITS
				 
 1E27  52                    C  	PUSH	DX		;SAVE DIGITS TO RIGHT 
 1E28  FF 36 0000 E          C  	PUSH	WORD PTR $FMTCX ;SAVE DIGITS TO LEFT/RIGH
				T 
 1E2C  2A C5                 C  	SUB	AL,CH		;SUBTRACT PRINTABLE DIGITS 
 1E2E  2A C2                 C  	SUB	AL,DL		;ADD DIGITS TO RIGHT 
 1E30  02 C1                 C  	ADD	AL,CL		;SUBTRACT CREATED LEADING ZEROS 
 1E32  78 03                 C  	JS	PUF130		;IF NO LEADING ZEROS REQUIRED JUMP 
 1E34  E8 0145 R             C  	CALL	$FOTZ		;PUT IN REQUIRED LEADING ZEROS 
 1E37  E8 1E61 R             C  PUF130: CALL	DPCOM		;SET UP DECIMAL POINT AND C
				OMMA CTS. 
 1E3A  FF 36 0000 E          C  PUF140: PUSH	WORD PTR $FMTCX ;SAVE DECIMAL POIN
				T INFO. 
 1E3E  E8 19C4 R             C  	CALL	$FOTCV		;CONVERT FAC TO ASCII DIGITS AND 
                             C  				;INSERT INTO OUTPUT BUFFER. DECIMAL 
                             C  				;POINT AND COMMA COUNTS ARE IN 
                             C  				;(CH)&(CL) RESPECTIVELY 
 1E41  8F 06 0000 E          C  	POP	WORD PTR $FMTCX ;Retrieve the right and le
				ft counts. 
                             C  				;($FMTCX:=digits to right of decimal 
                             C  				;point plus one for the decimal point, 
                             C  				;$FMTCX+1:=digits to left of decimal 
                             C  				;point.) 
 1E45  58                    C  	POP	AX		;RECALL DIGITS TO LEFT 
 1E46  5A                    C  	POP	DX		;RECALL DIGITS TO RIGHT 
 1E47  F6 06 0000 E FF       C  	TEST	BYTE PTR $FMTCX,LOW 377O	;Is the right si
				de count zero? 
                             C  				;(This count includes the point 
                             C  				;point itself.) 
 1E4C  75 07                 C  	JNZ	PUF150		;No, retain the decimal point. 
                             C  				;Go see if trailing zeroes are needed. 
 1E4E  8B 1E 0000 E          C  	MOV	BX,WORD PTR $DPADR	;Yes, get rid of the de
				cimal point 
                             C  				;by backing up the pointer so the 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-132
$PUF	 PRINT-USING FOR FLOATING POINT NUMBERS                

 1E52  E9 006C R             C  	JMP	$PUFXE		;GO DO FIX-UP 
 1E55                        C  PUF150: 
                             C  ;**********************************************
				******************* 
                             C  ;WE NEED TO NOW DETERMINE IF TRAILING ZEROS ARE
				 TO BE PRINTED 
                             C  ;THIS WILL BE THE CASE IF NO. DIGITS TO THE RIG
				HT (DL) IS LESS 
                             C  ;THAN THOSE REQUESTED (AL). 
                             C  ;**********************************************
				****************** 
 1E55  02 C2                 C  	ADD	AL,DL		;SUBTRACT DIGITS TO THE RIGHT 
 1E57  FE C8                 C  	DEC	AL		;BECAUSE DECIMAL POINT WAS INCLUDED 
 1E59  78 03                 C  	JS	PUF160		;GO DO FIX-UP 
 1E5B  E8 0145 R             C  	CALL	$FOTZ		;PUT IN TRAILING ZEROS 
 1E5E  E9 006C R             C  PUF160: JMP	$PUFXE		;GO DO FIX-UP 
                             C   
                             C   
                             C   
 1E61                        C  DPCOM:				;ROUTINE TO SET UP DECIMAL POINT AND 
				COMMA COUNTS 
 1E61  8A C5                 C  	MOV	AL,CH		;FETCH PRINTABLE DIGITS 
 1E63  02 C2                 C  	ADD	AL,DL		;SUBTRACT DIGITS TO RIGHT 
 1E65  2A C1                 C  	SUB	AL,CL		;ADD CREATED ZEROS 
 1E67  FE C0                 C  	INC	AL		;FOR SIGN 
 1E69  8A E8                 C  	MOV	CH,AL 
 1E6B  2C 03                 C  DPC10:	SUB	AL,LOW 3	;SUBTRACT OUT AL MULTIPLES 
				OF 3 
 1E6D  7F FC                 C  	JG	DPC10 
 1E6F  04 03                 C  	ADD	AL,LOW 3 
 1E71  8A C8                 C  	MOV	CL,AL		;COMMA COUNT NOW SET 
 1E73  A0 0000 E             C  	MOV	AL,BYTE PTR $FMTAX	;FETCH FORMAT FLAGS 
 1E76  24 40                 C  	AND	AL,LOW 100	;SEE IF COMMAS DESIRED 
 1E78  75 02                 C  	JNZ	DPC20 
 1E7A  8A C8                 C  	MOV	CL,AL		;ZERO COMMA COUNT 
 1E7C  C3                    C  DPC20:	RET 
                             C   
                             C  	SUBTTL	 $PUFOT  PRINT USING OUTPUT ROUTINE 
                             C  ;**********************************************
				***************** 
                             C  ; 
                             C  ;       $PUFOT  THIS ROUTINE PROVIDES TOP-LEVEL
				 CONTROL OF THE 
                             C  ;               PRINT USING OUTPUT FUNCTION. 
                             C  ;       CALLING SEQUENCE:       CALL    $PUFOT 
                             C  ;               WITH NUMBER TO BE OUTPUT IN THE
				 FAC AND FORMAT 
                             C  ;               SPECIFICATIONS IN (AL), AND (CX
				).(AL) IS SET AS 
                             C  ;               FOLLOWS: 
                             C  ;               BIT     7       =0 FREE FORMAT 
				OUTPUT, NUMBER DICTATES 
                             C  ;                               OUTPUT FORMAT 
                             C  ;                               =1 PRINT USING 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-133
$PUFOT  PRINT USING OUTPUT ROUTINE                          

				OUTPUT. THE REMAINDER OF 
                             C  ;                               (AL) AND (CX) D
				ICTATE HOW THE NUMBER IS 
                             C  ;                               TO BE PRINTED 
                             C  ;                       6       IF =1 GROUP THE
				 DIGITS IN THE INTEGER 
                             C  ;                               PART IN GROUPS 
				OF THREE AND SEPARATE 
                             C  ;                               WITH COMMAS. 
                             C  ;                       5       IF =1 FILL THE 
				LEADING SPACES IN THE 
                             C  ;                               FIELD WITH ASTE
				RISKS "*" 
                             C  ;                       4       IF =1 OUTPUT TH
				E NUMBER WITH A FLOATING 
                             C  ;                               DOLLAR SIGN "$"
				 
                             C  ;                       3       IF =1 PRINT THE
				 SIGN OF THE NUMBER WITH 
                             C  ;                               A PLUS "+" IF P
				OSITIVE INSTEAD OF A SPC 
                             C  ;                       2       IF =1 PRINT THE
				 SIGN AFTER THE NUMBER 
                             C  ;                       1       UNUSED 
                             C  ;                       0       IF =1 PRINT THE
				 NUMBER IN SCIENTIFIC 
                             C  ;                               NOTATION AND IG
				NORE BIT 6. 
                             C  ;                               IF =0 USE FIXED
				 POINT NOTATION. 
                             C  ;               (CH)    NUMBER PLACES IN FIELD 
				TO LEFT OF DECIMAL POINT 
                             C  ;                       (DOES NOT INCLUDE THE D
				ECIMAL POINT) 
                             C  ;               (CL)    NUMBER PLACES IN THE FI
				ELD TO THE RIGHT OF THE 
                             C  ;                       DECIMAL POINT (INCLUDES
				 DECIMAL POINT) 
                             C  ; 
                             C  ;**********************************************
				****************** 
                             C   
 1E7D                        C  PUFOUT: 
 1E7D                        C  $PUFOT: 
 1E7D  8A E0                 C  	MOV	AH,AL		;FETCH FORMAT SPECS. 
 1E7F  F6 C4 40              C  	TEST	AH,LOW 100	;ZF=0 IF COMMAS DESIRED 
 1E82  B4 03                 C  	MOV	AH,LOW 3	;IF COMMAS DESIRED 
 1E84  75 02                 C  	JNZ	PFO05		;JUMP IF COMMAS DESIRED 
 1E86  32 E4                 C  	XOR	AH,AH		;COMMAS NOT DESIRED 
 1E88  A3 0000 E             C  PFO05:	MOV	WORD PTR $FMTAX,AX	;SAVE COMMA COUNT
				 AND PFORMAT SPECS 
 1E8B  89 0E 0000 E          C  	MOV	WORD PTR $FMTCX,CX	;SAVE POSITIONS TO RT./
				LEFT 
                             C  				;OF DECIMAL POINT 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-134
$PUFOT  PRINT USING OUTPUT ROUTINE                          

 1E8F  8A E0                 C  	MOV	AH,AL		;FOR TESTING 
 1E91  BB 0001 E             C  	MOV	BX,OFFSET $FBUFF+1	;FETCH BUFFER POINTER 
 1E94  C6 07 20              C  	MOV	BYTE PTR 0[BX],LOW " "  ;MOVE IN SPACE FOR
				 POSSIBLE SIGN 
 1E97  F6 C4 08              C  	TEST	AH,LOW 10	;SEE IF "+" DESIRED 
 1E9A  74 03                 C  	JZ	PFO10		;JUMP IF NOT 
 1E9C  C6 07 2B              C  	MOV	BYTE PTR 0[BX],LOW "+"  ;MOVE IN PLUS 
 1E9F  53                    C  PFO10:	PUSH	BX		;SAVE BUFFER POINTER 
 1EA0  E8 08BE R             C  	CALL	$SIGNS		;DETERMINE SIGN OF NUMBER 
 1EA3  5B                    C  	POP	BX		;RECALL BUFFER POINTER 
 1EA4  79 08                 C  	JNS	PFO20		;JUMP IF POSITIVE 
 1EA6  C6 07 2D              C  	MOV	BYTE PTR 0[BX],LOW "-"  ;PUT IN MINUS SGN 
 1EA9  53                    C  	PUSH	BX		;SAVE BUFFER PTR. 
 1EAA  E8 0B1F R             C  	CALL	$VNEG		;NEGATE NO. SO WE WORK ONLY WITH 
 1EAD  5B                    C  	POP	BX		;RECALL BUFFER PTR. 
 1EAE  43                    C  PFO20:	INC	BX		;POINT TO NEXT BUFFER POSITION 
 1EAF  C6 07 30              C  	MOV	BYTE PTR 0[BX],LOW "0"  ;PUT IN ZERO IN CA
				SE NO IS ZERO 
 1EB2  E8 08EE R             C  	CALL	$GETYP		;SET COND CODES ACCORDING TO TYPE
				 
 1EB5  A1 0000 E             C  	MOV	AX,WORD PTR $FMTAX	;FETCH FORMAT SPECS 
 1EB8  8B 0E 0000 E          C  	MOV	CX,WORD PTR $FMTCX 
 1EBC  78 03                 C  	JS	PFO40		;IF INTEGER JUMP 
 1EBE  E9 1D63 R             C  	JMP	$PUF		;DO FLOATING POINT FORMATTING 
 1EC1  EB 01 90              C  PFO40:	JMP	$PUI		;PROCESS INTEGER 
                             C   
                             C  	SUBTTL	 $PUI	 PRINT USING FOR INTEGERS 
                             C  ;**********************************************
				************** 
                             C  ; 
                             C  ;       $PUI    PRINT THE INTEGER ACCORDING TO 
				THE FORMATS IN 
                             C  ;               $FMTCX (NO PLACES TO LEFT/RIGHT
				 OF DECIMAL POINT) 
                             C  ;               $FMTAX (AH)=0 OR 3 FOR COMMA IN
				SERTION AND (AL) 
                             C  ;               HAS THE FOLLOWING MEANING: 
                             C  ;               BIT     7       =0 FREE FORMAT 
				OUTPUT, NUMBER DICTATES 
                             C  ;                               OUTPUT FORMAT 
                             C  ;                               =1 PRINT USING 
				OUTPUT. THE REMAINDER OF 
                             C  ;                               (AL) AND (CX) D
				ICTATE HOW THE NUMBER IS 
                             C  ;                               TO BE PRINTED 
                             C  ;                       6       IF =1 GROUP THE
				 DIGITS IN THE INTEGER 
                             C  ;                               PART IN GROUPS 
				OF THREE AND SEPARATE 
                             C  ;                               WITH COMMAS. 
                             C  ;                       5       IF =1 FILL THE 
				LEADING SPACES IN THE 
                             C  ;                               FIELD WITH ASTE
				RISKS "*" 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-135
$PUI	 PRINT USING FOR INTEGERS                              

                             C  ;                       4       IF =1 OUTPUT TH
				E NUMBER WITH A FLOATING 
                             C  ;                               DOLLAR SIGN "$"
				 
                             C  ;                       3       IF =1 PRINT THE
				 SIGN OF THE NUMBER WITH 
                             C  ;                               A PLUS "+" IF P
				OSITIVE INSTEAD OF A SPC 
                             C  ;                       2       IF =1 PRINT THE
				 SIGN AFTER THE NUMBER 
                             C  ;                       1       UNUSED 
                             C  ;                       0       IF =1 PRINT THE
				 NUMBER IN SCIENTIFIC 
                             C  ;                               NOTATION AND IG
				NORE BIT 6. 
                             C  ;                               IF =0 USE FIXED
				 POINT NOTATION. 
                             C  ;       CALLING SEQUENCE:       CALL    $PUI 
                             C  ;               WITH THE AFOREMENTIONED INFORMA
				TION AVAILABLE 
                             C  ; 
                             C  ;**********************************************
				******************** 
                             C   
 1EC4  A1 0000 E             C  $PUI:	MOV	AX,WORD PTR $FMTAX	;FETCH PRINT DESCR
				IPTION DATA 
 1EC7  8A CC                 C  	MOV	CL,AH		;$FOTCI WILL NEED COMMA INFO 
                             C  				;IN (CL) 
 1EC9  B5 06                 C  	MOV	CH,LOW 6	;AT MOST 6 PLACES PRIOR TO DECIMA
				L PT 
 1ECB  D0 E8                 C  	SHR	AL,1		;SETS CF=1 IF "E" TYPE PRINT DESIRED
				 
 1ECD  8B 16 0000 E          C  	MOV	DX,WORD PTR $FMTCX	;FETCH PLACES TO LEFT/R
				IGHT OF DEC. PT 
 1ED1  73 0B                 C  	JNB	PI10		;IF NOT "E" FORMAT JUMP 
 1ED3  53                    C  	PUSH	BX		;SAVE BUFFER POINTER 
 1ED4  52                    C  	PUSH	DX		;SAVE PLACES TO LEFT/RIGHT OF DEC. PT
				 
 1ED5  E8 17E5 R             C  	CALL	$CSI		;CONVERT THE INTEGER TO S.P. 
 1ED8  32 C0                 C  	XOR	AL,AL		;MUST SET ZF=1 FOR $PUFE 
 1EDA  5A                    C  	POP	DX		;FETCH PLACES TO LEFT /RIGHT OF D.P. 
 1EDB  E9 015E R             C  	JMP	$PUFE		;GO FORMAT THE SINGLE PRECISION NO.
				 
 1EDE  8A C6                 C  PI10:	MOV	AL,DH		;FETCH PLACES TO LEFT OF D.P. 
 1EE0  2C 05                 C  	SUB	AL,LOW 5	;LET'S SEE IF LEADING ZEROS NEEDE
				D 
                             C  ;**********************************************
				********************* 
                             C  ;AT MOST 5 PRINT POSITIONS NEEDED FOR INTEGER (
				-32768,32767) SO IF 
                             C  ;DESIRED NO. PLACES ON LEFT IS MORE THAN 5 WE N
				EED TO FILL THESE 
                             C  ;POSITIONS WITH ASCII SPACES. 
                             C  ;**********************************************
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-136
$PUI	 PRINT USING FOR INTEGERS                              

				******************** 
 1EE2  78 03                 C  	JS	PI20		;JUMP IF LESS THAN 5 
 1EE4  E8 0145 R             C  	CALL	$FOTZ		;ZERO FILL (AL) POSITIONS 
 1EE7  52                    C  PI20:	PUSH	DX		;SAVE POSITIONS TO LEFT/RIGHT OF
				 D.P. 
 1EE8  E8 0000 R             C  	CALL	$FOTCI		;CONVERT THE INTEGER TO ASCII DIG
				ITS 
                             C  				;AND INSERT DECIMAL POINT AND COMMAS 
                             C  				;AS DESIRED 
 1EEB  58                    C  	POP	AX		;RECALL NO. PLACESTO LEFT/RIGHT OF D.P
				. 
 1EEC  50                    C  	PUSH	AX		;AND SAVE AGAIN 
 1EED  0A C0                 C  $PUIZ:	OR	AL,AL		;IF 0 THEN NO DECIMAL POINT DE
				SIRED 
 1EEF  75 01                 C  	JNZ	PI30		;IF DESIRED PROCEED 
 1EF1  4B                    C  	DEC	BX		;THIS WILL ELIMINATE DECIMAL POINT 
 1EF2  FE C8                 C  PI30:	DEC	AL		;MAY NEED TO INSERT ZEROS TO RIGH
				T 
                             C  				;OF DECIMAL POINT. 
 1EF4  78 06                 C  	JS	PI40		;JUMP IF NOT DESIRED 
 1EF6  E8 0145 R             C  	CALL	$FOTZ		;PUT (AL) ASCII ZEROS IN BUFFER 
 1EF9  C6 07 00              C  	MOV	BYTE PTR 0[BX],LOW 0	;RE-ESTABLISH END-OF-
				PRINT 
 1EFC  8F 06 0000 E          C  PI40:	POP	WORD PTR $FMTCX ;MAINTAIN DIGITS LEFT
				/RT. OF DP. 
 1F00  E9 006C R             C  	JMP	$PUFXE		;BE SURE FORMAT SPECS MET 
                             C   
                             C  	SUBTTL	 $RND	 PSEUDO-RANDOM NUMBER GENERATOR 
                             C  ;**********************************************
				******************** 
                             C  ; 
                             C  ;       $RND    GENERATE THE NEXT RANDOM NUMBER
				 IN THE 
                             C  ;               SEQUENCE. 
                             C  ; 
                             C  ;       CALLING SEQUENCE:       CALL    $RND 
                             C  ;               WITH THE PREVIOUS RANDOM NUMBER
				 IN $RNDX 
                             C  ;               AND DATA ITEMS $RNDA AND $RNDC 
				SET PROPERLY 
                             C  ;       METHOD: LINEAR CONGRUENTIAL FROM VOL. 2
				 CHAPTER 3 OF 
                             C  ;               KNUTH - THE ART OF COMPUTER PRO
				GRAMMING. 
                             C  ;               M=16,777,216 OR 2^24; [ A MOD 8
				 ]=5 AND 
                             C  ;               [ C MOD 8 ]=3 
                             C  ;               RND(N+1)=(RND(N)*A+C)MOD M 
                             C  ; 
                             C  ;               THE DATA ITEMS A AND C CORRESPO
				ND TO $RNDA 
                             C  ;               AND $RNDC RESPECTIVELY AND WERE
				 CAREFULLY 
                             C  ;               CHOSEN TO MEET THE RECIPE IN KN
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-137
$RND	 PSEUDO-RANDOM NUMBER GENERATOR                        

				UTH. 
                             C  ; 
                             C  ;**********************************************
				**************** 
                             C   
 1F03                        C  RND: 
 1F03  E8 08BE R             C  $RND:	CALL	$SIGNS		;FIND WHICH MODE REQUESTED 
 1F06  74 6E                 C  	JZ	OLDRN		;RETURN PREVIOUS NO.? 
 1F08  79 0C                 C  	JNS	RND10		;GO DO NEW SEED 
 1F0A  A1 0000 E             C  	MOV	AX,WORD PTR $FACLO	;FETCH NUMBER 
 1F0D  A3 0000 E             C  	MOV	WORD PTR $RNDX,AX	;AND INITIALIZE LAST RAN
				DOM # 
 1F10  A0 FFFF E             C  	MOV	AL,BYTE PTR $FAC-1 
 1F13  A2 0002 E             C  	MOV	BYTE PTR $RNDX+2,AL	;SO SEQUENCE STARTS AG
				AIN 
 1F16  A1 0000 E             C  RND10:	MOV	AX,WORD PTR $RNDX	;FETCH LOW 16 BITS
				 OF RNDX 
 1F19  2E: F7 26 059A R      C  	MUL	WORD PTR $RNDA	;MULTIPLY BY LOW BITS OF A 
 1F1E  8B F8                 C  	MOV	DI,AX		;SAVE LOW 16 BITS 
 1F20  8A CA                 C  	MOV	CL,DL		;SAVE UPPER 8 BITS 
 1F22  2E: A0 059C R         C  	MOV	AL,BYTE PTR $RNDA+2	;FETCH UPPER 8 BITS OF
				 A 
 1F26  32 E4                 C  	XOR	AH,AH		;CLEAR UPPER AX 
 1F28  F7 26 0000 E          C  	MUL	WORD PTR $RNDX	;MULTIPLY BY LOW RNDX 
 1F2C  02 C8                 C  	ADD	CL,AL		;ADD TO UPPER 8 BITS 
 1F2E  32 E4                 C  	XOR	AH,AH		;CLEAR UPPER AX 
 1F30  A0 0002 E             C  	MOV	AL,BYTE PTR $RNDX+2	;FETCH HIGH 8 BITS OF 
				RNDX 
 1F33  2E: F7 26 059A R      C  	MUL	WORD PTR $RNDA	;MULTIPLY BY LOW 16 OF A 
 1F38  02 C8                 C  	ADD	CL,AL		;ADD IN TO UPPER 8 
 1F3A  32 E4                 C  	XOR	AH,AH		;CLEAR OVERFLOW BYTE FOR NORM 
 1F3C  2E: 8B 16 059D R      C  	MOV	DX,WORD PTR $RNDC	;FETCH LOW 16 OF C 
 1F41  03 D7                 C  	ADD	DX,DI		;ADD IN LOW OF RND(N)*A 
 1F43  2E: 8A 1E 059F R      C  	MOV	BL,BYTE PTR $RNDC+2	;FETCH HIGH OF C 
 1F48  12 D9                 C  	ADC	BL,CL		;ADD WITH CARRY HIGH RND(N)*A 
 1F4A  88 26 0001 E          C  	MOV	BYTE PTR $FAC+1,AH	;SIGN IS POSITIVE 
 1F4E  B0 80                 C  	MOV	AL,LOW 200	;SO NORM WILL PRODUCE NO. 
                             C  				;LESS THAN 1 
 1F50  A2 0000 E             C  	MOV	BYTE PTR $FAC,AL 
 1F53  89 16 0000 E          C  	MOV	WORD PTR $RNDX,DX	;SAVE NEW RND(N+1) 
 1F57  88 1E 0002 E          C  	MOV	BYTE PTR $RNDX+2,BL 
 1F5B  B0 04                 C  	MOV	AL,LOW 4	;MUST SET VALTP TO SINGLE PREC. 
 1F5D  A2 0000 E             C  	MOV	BYTE PTR $VALTP,AL 
 1F60  E9 1CE4 R             C  	JMP	$NORMS 
 1F63                        C  NEWSD:				;DETERMINE NEW RANDOM NO. SEED 
 1F63  BB 0000 E             C  	MOV	BX,OFFSET $FBUFF	;WILL SUM THE FIRST 32 WD
				S OF 
 1F66  B9 0020               C  	MOV	CX,40		;RAM 
 1F69  03 07                 C  NEW10:	ADD	AX,WORD PTR 0[BX] 
 1F6B  43                    C  	INC	BX 
 1F6C  43                    C  	INC	BX 
 1F6D  E2 FA                 C  	LOOP	NEW10 
 1F6F  24 FE                 C  	AND	AL,LOW 376	;BE SURE BIT 0=0 SO AS TO NOT 
                             C  				;MATCH RND0 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-138
$RND	 PSEUDO-RANDOM NUMBER GENERATOR                        

 1F71  A3 0000 E             C  	MOV	WORD PTR $RNDX,AX 
 1F74  EB A0                 C  	JMP	SHORT RND10	;GO PROCEED AS USUAL 
 1F76                        C  OLDRN:				;RETURN THE PREVIOUS RANDOM NO. 
 1F76  8B 16 0000 E          C  	MOV	DX,WORD PTR $RNDX	;FETCH LOW 16 BITS 
 1F7A  8A 1E 0002 E          C  	MOV	BL,BYTE PTR $RNDX+2	;FETCH HIGH 8 BITS 
 1F7E  33 C0                 C  	XOR	AX,AX		;CLEAR OVERFLOW BYTE (AH) 
 1F80  B0 80                 C  	MOV	AL,LOW 200	;EXPONENT OF 0 
 1F82  A2 0000 E             C  	MOV	BYTE PTR $FAC,AL 
 1F85  88 26 0001 E          C  	MOV	BYTE PTR $FAC+1,AH	;POSITIVE SIGN 
 1F89  E9 1CE4 R             C  	JMP	$NORMS		;GO NORMALIZE 
                             C   
                             C  	SUBTTL	 $ROUND  DOUBLE PRECISION ROUND ROUTINE
				 
                             C  ;**********************************************
				******************* 
                             C  ; 
                             C  ;       $ROUND  ROUND THE DOUBLE PRECISION FLOA
				TING POINT NUMBER IN 
                             C  ;               $FAC+1 THRU $DFACL-1. 
                             C  ;       CALLING SEQUENCE:       CALL    $ROUND 
                             C  ;               WITH NUMBER IN $FAC TO BE ROUND
				ED 
                             C  ; 
                             C  ;**********************************************
				******************** 
                             C   
 1F8C                        C  $ROUND:			;DOUBLE PRECISION ROUND AND PACK 
 1F8C  BB FFFF E             C  	MOV	BX,OFFSET $DFACL-1 
 1F8F  81 07 0080            C  	ADD	WORD PTR 0[BX],200	;ADD TO HIGH BIT OV OVE
				RFLOW BYTE 
 1F93  B9 0003               C  	MOV	CX,3		;3 MORE BYTES TO LOOK AT POTENTIALLY
				 
 1F96  73 0E                 C  	JNB	RDD20		;IF CF=0 WE ARE DONE 
 1F98  43                    C  RDD10:	INC	BX 
 1F99  43                    C  	INC	BX 
 1F9A  FF 07                 C  	INC	WORD PTR 0[BX]	;IF THIS GETS ZF=1 THEN CAR
				RY 
 1F9C  75 08                 C  	JNZ	RDD20		;FINISHED WHEN ZF=0 
 1F9E  E2 F8                 C  	LOOP	RDD10 
 1FA0  FE 06 0000 E          C  	INC	BYTE PTR $FAC	;MUST INCREMENT EXPONENT 
 1FA4  D1 1F                 C  	RCR	WORD PTR 0[BX],1	;SET HIGH BYTE TO 200 
 1FA6                        C  RDD20: 
 1FA6  74 1B                 C  	JZ	RDD30		;OVERFLOW HOOK 
 1FA8  F6 06 FFFF E FF       C  	TEST	BYTE PTR $DFACL-1,LOW 377	;SEE IF OVERFLO
				W BYTE ZERO 
 1FAD  75 05                 C  	JNZ	$ROUNX 
 1FAF  80 26 0000 E FE       C  	AND	BYTE PTR $DFACL,LOW 376 ;MAKE ANSWER EVEN 
 1FB4                        C  $ROUNX: 
 1FB4  80 26 FFFF E 7F       C  	AND	BYTE PTR $FAC-1,LOW 177 ;CLEAR SIGN BIT 
 1FB9  A0 0001 E             C  	MOV	AL,BYTE PTR $FAC+1	;FETCH SIGN BYTE 
 1FBC  24 80                 C  	AND	AL,LOW 200	;CLEAR ALL BUT SIGN 
 1FBE  08 06 FFFF E          C  	OR	BYTE PTR $FAC-1,AL	;AND SET SIGN APPROPRIAT
				ELY 
 1FC2  C3                    C  	RET 
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-139
$ROUND  DOUBLE PRECISION ROUND ROUTINE                      

 1FC3  E9 0775 R             C  RDD30:	JMP	$OVFLS 
                             C   
                             C  	SUBTTL	 $ROUNS  INTEL 8086 ROUNDING SUBROUTINE
				 
                             C  ;**********************************************
				************* 
                             C  ; 
                             C  ;       $ROUNS  SINGLE PRECISION ROUNDING SUBRO
				UTINE 
                             C  ;       CALLING SEQUENCE:       CALL    $ROUNS 
                             C  ;       ASSUMPTIONS:    (BLDXAH)WILL BE ROUNDED
				 BY ADDING 
                             C  ;                       128 TO (AH) . IF CF (CA
				RRY) IS SET 
                             C  ;                       AND (AH) IS NON-ZERO AF
				TER THIS 
                             C  ;                       ADDITION (BLDX) WILL BE
				 INCREMENTED 
                             C  ;                       ONCE ROUNDING IS COMPLE
				TE, LOGIC WILL 
                             C  ;                       CONTINUE INTO PAKSP FOR
				 PACKING THE MANTISSA 
                             C  ;                       AND SIGN INTO THE FAC. 
                             C  ; 
                             C  ;**********************************************
				**************** 
                             C   
 1FC6  80 E4 E0              C  $ROUNS: AND	AH,LOW 340	;CLEAR SUPERFLUOUS BITS 
 1FC9  80 C4 80              C  $ROUNM: ADD	AH,LOW 200	;ADD TO MOST SIG. BIT OF
				 AH 
 1FCC  73 1B                 C  	JNB	PAKSP		;IF NO CARRY RETURN 
 1FCE  9C                    C  	PUSHF			;IF ZF=1 WANT TO ROUND TO EVEN 
 1FCF  42                    C  	INC	DX		;IF ZF=1 MUST INCREMENT BL 
 1FD0  75 11                 C  	JNZ	TSTEVN 
 1FD2  9D                    C  	POPF			;KNOW RESULT WILL BE EVEN 
 1FD3  FE C3                 C  	INC	BL		;IF ZF=1 MUST INCREMENT EXPONENT 
 1FD5  75 12                 C  	JNZ	PAKSP 
 1FD7  F9                    C  	STC			;CF=1 
 1FD8  D0 DB                 C  	RCR	BL,1		;THIS WILL SET HIGH BIT OF BL 
 1FDA  FE 06 0000 E          C  	INC	BYTE PTR $FAC	;IF THIS CAUSES ($FAC)=0 WE 
				HAVE 
                             C  				;OVERFLOW IN ROUNDING 
 1FDE  75 09                 C  	JNZ	PAKSP 
 1FE0  E9 0775 R             C  	JMP	$OVFLS 
 1FE3  9D                    C  TSTEVN: POPF			;IF ZF=1 MUST CLEAR LOW BIT OF D
				L 
 1FE4  75 03                 C  	JNZ	PAKSP		;GO PACK THE FAC 
 1FE6  80 E2 FE              C  	AND	DL,LOW 376	;CLEAR LOW BIT 
 1FE9                        C  PAKSP:				;PAK SINGLE PRECISION FAC. EXPONENT I
				S IN FAC,SIGN IN FAC+1 
                             C  				;THE MANTISSA IS IN (BLDX) 
 1FE9  BE FFFD E             C  	MOV	SI,OFFSET $FAC-3	;LOAD ADDRESS OF $FAC IN 
				SI 
 1FEC  89 14                 C  	MOV	WORD PTR 0[SI],DX	;MOVE LOWER MANTISSA WOR
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-140
$ROUNS  INTEL 8086 ROUNDING SUBROUTINE                      

				D IN 
 1FEE  46                    C  	INC	SI		;INCREMENT TO HIGH MANTISSA BYTE 
 1FEF  46                    C  	INC	SI		; 
 1FF0  8A 3E 0001 E          C  	MOV	BH,BYTE PTR $FAC+1	;FETCH SIGN 
 1FF4  81 E3 807F            C  	AND	BX,100177	;CLEAR ALL BUT SIGN IN BH SIGN I
				N BL 
 1FF8  0A DF                 C  	OR	BL,BH		;(BL) NOW IN CORRECT FORMAT 
 1FFA  88 1C                 C  	MOV	BYTE PTR 0[SI],BL	;PUT INTO FAC-1 
 1FFC  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $SIGD	 CALCULATE SIGNIFICANT DIGITS FO
				R $FOUT 
                             C  ;**********************************************
				**************** 
                             C  ; 
                             C  ;       $SIGD   WHEN $FOUT IS DETERMINING WHETH
				ER TO PRINT 
                             C  ;               A NUMBER IN SCIENTIFIC NOTATION
				 OR FIXED POINT 
                             C  ;               IT NEEDS TO KNOW THE NUMBER OF 
				SIGNIFICANT DIGITS 
                             C  ;               IF THE NUMBER IS LESS THAN .01 
				. 
                             C  ;               PRIOR TO CALLING $SIGD, $FOUT H
				AS BRACKETED THE 
                             C  ;               SIGNIFICANT DIGITS VIA $FOUNV. 
				THE NUMBER IN THE 
                             C  ;               FAC WILL BE AXXXXXX OR AXXXXXXX
				XXXXXXXX WHERE A IS 
                             C  ;               NON-ZERO. $SIGD'S JOB IS TO DET
				ERMINE HOW MANY OF 
                             C  ;               THESE X'S STARTING FROM THE RIG
				HT ARE ZERO 
                             C  ;               PRIOR TO A NON-ZERO X. FOR EACH
				 ZERO X, $SIGD WILL 
                             C  ;               INCREMENT (CL). 
                             C  ;       CALLING SEQUENCE:       CALL    $SIGD 
                             C  ; 
                             C  ;**********************************************
				********************* 
                             C   
 1FFD                        C  $SIGD:				;(CL)=(CL)+1 FOR EACH ZERO DIGIT STAR
				TING FROM 
                             C  				;THE RIGHT . ASSUMES $FOUNV HAS PREVIOUSLY 
				OPERATED. 
 1FFD  8B F1                 C  	MOV	SI,CX		;SAVE CX 
 1FFF  E8 0BB5 R             C  	CALL	$VPSHF		;PUSH EITHER 4 OR 8 BYTES OF $FAC
				 
                             C  				;ON THE STACK ACCORDING TO $VALTP 
 2002  8B CE                 C  	MOV	CX,SI		;MUSU MAINTAIN (CL) 
 2004  51                    C  	PUSH	CX 
                             C  ;**********************************************
				**************** 
                             C  ;FIRST THING WE'LL DO IS ROUND THE FAC AND MAKE
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-141
$SIGD	 CALCULATE SIGNIFICANT DIGITS FOR $FOUT               

				 SURE WE 
                             C  ;STILL HAVE AN INTEGER. 
                             C  ;**********************************************
				***************** 
                             C  ;**********************************************
				******************* 
                             C  ;IF WE ALREADY HAVE AN EXACT INTEGER DON'T WANT
				 TO ADD .5 HERE 
                             C  ;**********************************************
				******************* 
 2005  E8 08EE R             C  	CALL	$GETYP 
 2008  72 09                 C  	JB	SI31		;JUMP IF SINGLE PREC 
 200A  80 3E 0000 E B8       C  	CMP	BYTE PTR $FAC,LOW 270	;IF EQUAL OR SF=0 TH
				EN INTEGER ALREADY 
 200F  79 0F                 C  	JNS	SI20		;DON'T ADD .5 
 2011  EB 07                 C  	JMP	SHORT SI32	;PROCESS FAC NORMALLY 
 2013  80 3E 0000 E 98       C  SI31:	CMP	BYTE PTR $FAC,LOW 230	;IF SF=0 THEN I
				NTEGER ALREADY 
 2018  79 06                 C  	JNS	SI20 
 201A  E8 08FA R             C  SI32:	CALL	$VADDH		;ADD .5 TO FAC 
 201D  E8 0BEE R             C  	CALL	$VINT		;MAKE SURE WE STILL HAVE AN INTEGE
				R 
 2020                        C  SI20: 
 2020  BB 0000 E             C  	MOV	BX,OFFSET $ZLO	;FETCH ADDRESS OF Z INTO (B
				X) 
 2023  E8 0B76 R             C  	CALL	$VMVMF		;MOVE FAC TO Z , Z=INT(FAC+.5) 
 2026  59                    C  	POP	CX		;GET (CL) BACK 
 2027  51                    C  SI30:	PUSH	CX		;SAVE CX FOR LATER 
 2028  BF 0000 E             C  	MOV	DI,OFFSET $Z1LO ;GET ADDRESS OF Z1 
 202B  BB 0000 E             C  	MOV	BX,OFFSET $ZLO	;GET ADDRESS OF Z 
 202E  E8 0B65 R             C  	CALL	$VMOVM		;Z1=Z 
 2031  BB 0000 E             C  	MOV	BX,OFFSET $ZLO	;FETCH ADDRESS OF Z 
 2034  E8 0B93 R             C  	CALL	$VMVFM		;MOVE Z TO FAC 
 2037  E8 0914 R             C  	CALL	$DIV10		;FAC=Z/10 
 203A  E8 0BEE R             C  	CALL	$VINT		;FAC=INT(Z/10) 
 203D  BB 0000 E             C  	MOV	BX,OFFSET $ZLO 
 2040  E8 0B76 R             C  	CALL	$VMVMF		;Z=INT(Z/10) 
 2043  E8 091E R             C  	CALL	$MUL10		;FAC=INT(Z/10)*10 
 2046  BB FFFF E             C  	MOV	BX,OFFSET $Z1-1 ;ADDRESS OF Z1-1 
 2049  E8 08EE R             C  	CALL	$GETYP		;NEED TO DECREMENT BX IF S.P. 
 204C  73 03                 C  	JNB	SI35 
 204E  83 EB 04              C  	SUB	BX,4		;NOW (BX) POINTS TO S.P. 
 2051                        C  SI35: 
 2051  E8 0BAA R             C  	CALL	$VCMPM		;COMPARE TO FAC 
 2054  59                    C  	POP	CX		;GET SIGNIFICANT DIGIT COUNT BACK 
 2055  75 04                 C  	JNZ	SI40		;THROUGH WHEN NON-ZERO 
 2057  FE C1                 C  	INC	CL		;(CL)=(CL)+1 
 2059  EB CC                 C  	JMP	SHORT SI30	;LET'S GO SEE IF WE CAN FIND AN
				OTHER 
 205B  8B E9                 C  SI40:	MOV	BP,CX		;SAVE CX 
 205D  E8 0BD4 R             C  	CALL	$VPOPF		;RESTORE ORIGINAL FAC 
 2060  8B CD                 C  	MOV	CX,BP		;RESTORE CX 
                             C   
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Page     1-142
$SIGD	 CALCULATE SIGNIFICANT DIGITS FOR $FOUT               

 2062  C3                    C  	RET 
 2063                        C  CSEG	ENDS 
                             C  	END			;END MATH86.MAC 

Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-1
                                                             

Macros:

		N a m e			Lines

ACRLF  . . . . . . . . . . . . .  	   2
ADR  . . . . . . . . . . . . . .  	   1
CALLOS . . . . . . . . . . . . .  	   1
CHRGET . . . . . . . . . . . . .  	   1
COMPAR . . . . . . . . . . . . .  	   2
DC . . . . . . . . . . . . . . .  	   6
DJNZ . . . . . . . . . . . . . .  	   2
FSIGN  . . . . . . . . . . . . .  	   1
GETYPE . . . . . . . . . . . . .  	   1
INS86  . . . . . . . . . . . . .  	  13
INST . . . . . . . . . . . . . .  	   1
LDDR . . . . . . . . . . . . . .  	   8
LDIR . . . . . . . . . . . . . .  	   8
MOVRI  . . . . . . . . . . . . .  	   6
OUTCHR . . . . . . . . . . . . .  	   1
POPR . . . . . . . . . . . . . .  	   2
PUSHM  . . . . . . . . . . . . .  	   5
PUSHR  . . . . . . . . . . . . .  	   2
SYNCHK . . . . . . . . . . . . .  	   2

Segments and Groups:

                N a m e         	Size	Align	Combine Class

CSEG . . . . . . . . . . . . . .  	2063	PARA	PUBLIC	'CODESG'
DSEG . . . . . . . . . . . . . .  	0000	PARA	PUBLIC	'DATASG'

Symbols:            

                N a m e         	Type	Value	Attr         

ABSFN  . . . . . . . . . . . . .  	L NEAR	0B0A	CSEG	Global
ADD10  . . . . . . . . . . . . .  	L NEAR	1BCB	CSEG
ADD1D  . . . . . . . . . . . . .  	L NEAR	1BC7	CSEG
ADD20  . . . . . . . . . . . . .  	L NEAR	1BD2	CSEG
ALTAIR . . . . . . . . . . . . .  	Number	0000	
ANSI . . . . . . . . . . . . . .  	Number	0001	
ARYEXT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ARYTA2 . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ATN  . . . . . . . . . . . . . .  	L NEAR	0686	CSEG	Global
ATN10  . . . . . . . . . . . . .  	L NEAR	0696	CSEG
ATN100 . . . . . . . . . . . . .  	L NEAR	06F2	CSEG
ATN20  . . . . . . . . . . . . .  	L NEAR	06A7	CSEG
ATN200 . . . . . . . . . . . . .  	L NEAR	06FB	CSEG
ATN30  . . . . . . . . . . . . .  	L NEAR	06EC	CSEG

BASDEB . . . . . . . . . . . . .  	Number	0000	
BEEPSW . . . . . . . . . . . . .  	Number	0001	
BINCSW . . . . . . . . . . . . .  	Number	0000	
BLODSW . . . . . . . . . . . . .  	Number	0001	
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-2
                                                             

BLTU . . . . . . . . . . . . . .  	L NEAR	101F	CSEG	Global
BLTUC  . . . . . . . . . . . . .  	L NEAR	1022	CSEG	Global
BSERR  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
BUFLEN . . . . . . . . . . . . .  	Number	00FF	

CASSW  . . . . . . . . . . . . .  	Number	0000	
CDIV16 . . . . . . . . . . . . .  	L NEAR	1647	CSEG
CH10 . . . . . . . . . . . . . .  	L NEAR	0F9B	CSEG
CHKSTR . . . . . . . . . . . . .  	L NEAR	0F93	CSEG	Global
CHRGTR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CHSEAT . . . . . . . . . . . . .  	Number	0001	
CINT . . . . . . . . . . . . . .  	L NEAR	1809	CSEG
CK10 . . . . . . . . . . . . . .  	L NEAR	1266	CSEG
CLMWID . . . . . . . . . . . . .  	Number	000E	
CMPUTN . . . . . . . . . . . . .  	Number	0000	
CNOMAT . . . . . . . . . . . . .  	L NEAR	11F4	CSEG
COMMNT . . . . . . . . . . . . .  	Number	0000	
CON10  . . . . . . . . . . . . .  	L NEAR	0B00	CSEG
CONIA  . . . . . . . . . . . . .  	L NEAR	105B	CSEG	Global
CONSIH . . . . . . . . . . . . .  	L NEAR	0E7A	CSEG	Global
CONSSW . . . . . . . . . . . . .  	Number	0001	
CONTO  . . . . . . . . . . . . .  	Number	000F	
CONTRO . . . . . . . . . . . . .  	Number	0001	
COS  . . . . . . . . . . . . . .  	L NEAR	05B3	CSEG	Global
CPM  . . . . . . . . . . . . . .  	Number	0001	
CPM05  . . . . . . . . . . . . .  	L NEAR	0A92	CSEG
CPM06  . . . . . . . . . . . . .  	L NEAR	0A9A	CSEG
CPM10  . . . . . . . . . . . . .  	L NEAR	0AA0	CSEG
CPM110 . . . . . . . . . . . . .  	Number	0000	
CPM2 . . . . . . . . . . . . . .  	Number	0001	
CPM20  . . . . . . . . . . . . .  	L NEAR	0AA5	CSEG
CPM22  . . . . . . . . . . . . .  	L NEAR	0AA9	CSEG
CPM25  . . . . . . . . . . . . .  	L NEAR	0AB4	CSEG
CPM30  . . . . . . . . . . . . .  	L NEAR	0AB5	CSEG
CPM50  . . . . . . . . . . . . .  	L NEAR	0ABE	CSEG
CPM60  . . . . . . . . . . . . .  	L NEAR	0AC6	CSEG
CPM70  . . . . . . . . . . . . .  	L NEAR	0ACB	CSEG
CPM80  . . . . . . . . . . . . .  	L NEAR	0ACC	CSEG
CPM86  . . . . . . . . . . . . .  	Number	0000	
CPMA75 . . . . . . . . . . . . .  	Number	0000	
CPMADD . . . . . . . . . . . . .  	Number	0000	
CPMCON . . . . . . . . . . . . .  	Number	0000	
CPMLIF . . . . . . . . . . . . .  	Number	0000	
CPMMDS . . . . . . . . . . . . .  	Number	0000	
CPMPER . . . . . . . . . . . . .  	Number	0000	
CPMRSH . . . . . . . . . . . . .  	Number	0000	
CPMSBC . . . . . . . . . . . . .  	Number	0000	
CPMSER . . . . . . . . . . . . .  	Number	0000	
CRFIN  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CRONLY . . . . . . . . . . . . .  	Number	0000	
CURNCY . . . . . . . . . . . . .  	Number	0024	
CXRET  . . . . . . . . . . . . .  	L NEAR	182F	CSEG

DADD . . . . . . . . . . . . . .  	L NEAR	12E3	CSEG	Global
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-3
                                                             

DADDI  . . . . . . . . . . . . .  	L NEAR	1AAE	CSEG
DADDI1 . . . . . . . . . . . . .  	L NEAR	1AB7	CSEG
DATPSC . . . . . . . . . . . . .  	Number	0080	
DBLCHR . . . . . . . . . . . . .  	Number	0000	
DBLDIV . . . . . . . . . . . . .  	L NEAR	0772	CSEG
DBLTRN . . . . . . . . . . . . .  	Number	0000	
DC10 . . . . . . . . . . . . . .  	L NEAR	0AE4	CSEG
DCOMP  . . . . . . . . . . . . .  	L NEAR	10BE	CSEG	Global
DCXBRT . . . . . . . . . . . . .  	L NEAR	1033	CSEG	Global
DDIV . . . . . . . . . . . . . .  	L NEAR	1475	CSEG	Global
DDIV0  . . . . . . . . . . . . .  	L NEAR	14F5	CSEG
DDIV16 . . . . . . . . . . . . .  	L NEAR	14FB	CSEG
DDIVFA . . . . . . . . . . . . .  	L NEAR	1475	CSEG
DDOVFL . . . . . . . . . . . . .  	L NEAR	15B5	CSEG
DDRND  . . . . . . . . . . . . .  	L NEAR	1597	CSEG
DDSV . . . . . . . . . . . . . .  	L NEAR	15B8	CSEG
DEBUG  . . . . . . . . . . . . .  	Text  		
DINA10 . . . . . . . . . . . . .  	L NEAR	1BBC	CSEG
DINA20 . . . . . . . . . . . . .  	L NEAR	1BC5	CSEG
DINCEX . . . . . . . . . . . . .  	L NEAR	1593	CSEG
DINTA  . . . . . . . . . . . . .  	L NEAR	1BB8	CSEG
DINTNZ . . . . . . . . . . . . .  	L NEAR	1B7A	CSEG
DISK . . . . . . . . . . . . . .  	Number	0001	
DIV0 . . . . . . . . . . . . . .  	L NEAR	1644	CSEG
DIV0S  . . . . . . . . . . . . .  	L NEAR	078C	CSEG
DIV16  . . . . . . . . . . . . .  	L NEAR	164B	CSEG
DMC  . . . . . . . . . . . . . .  	Number	0000	
DMULT  . . . . . . . . . . . . .  	L NEAR	1873	CSEG	Global
DMXQUO . . . . . . . . . . . . .  	L NEAR	1561	CSEG
DNRMCHK  . . . . . . . . . . . .  	L NEAR	157F	CSEG
DNSTK1 . . . . . . . . . . . . .  	L NEAR	14EF	CSEG
DNT10  . . . . . . . . . . . . .  	L NEAR	1B96	CSEG
DNT15  . . . . . . . . . . . . .  	L NEAR	1BA1	CSEG
DNT20  . . . . . . . . . . . . .  	L NEAR	1BAC	CSEG
DODIV  . . . . . . . . . . . . .  	L NEAR	150D	CSEG
DOINF  . . . . . . . . . . . . .  	L NEAR	07B4	CSEG
DONE . . . . . . . . . . . . . .  	L NEAR	0D25	CSEG
DOS  . . . . . . . . . . . . . .  	Number	0000	
DOVCKJ . . . . . . . . . . . . .  	L NEAR	1470	CSEG
DPC10  . . . . . . . . . . . . .  	L NEAR	1E6B	CSEG
DPC20  . . . . . . . . . . . . .  	L NEAR	1E7C	CSEG
DPCOM  . . . . . . . . . . . . .  	L NEAR	1E61	CSEG
DRESTR . . . . . . . . . . . . .  	L NEAR	154D	CSEG
DRVPOS . . . . . . . . . . . . .  	Number	0000	
DSUB . . . . . . . . . . . . . .  	L NEAR	0E5E	CSEG	Global
DSUBI  . . . . . . . . . . . . .  	L NEAR	1A9A	CSEG
DSUBI1 . . . . . . . . . . . . .  	L NEAR	1AA4	CSEG
DUPONT . . . . . . . . . . . . .  	Number	0000	
DV010  . . . . . . . . . . . . .  	L NEAR	0795	CSEG
DV015  . . . . . . . . . . . . .  	L NEAR	07A6	CSEG
DV020  . . . . . . . . . . . . .  	L NEAR	07B3	CSEG
DV0ERR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DYNCOM . . . . . . . . . . . . .  	Number	0001	

Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-4
                                                             

EDIT80 . . . . . . . . . . . . .  	Number	0000	
ESCCTL . . . . . . . . . . . . .  	Number	0000	
EVENEX . . . . . . . . . . . . .  	L NEAR	0CD7	CSEG
EXA  . . . . . . . . . . . . . .  	L NEAR	1737	CSEG
EXB  . . . . . . . . . . . . . .  	L NEAR	173F	CSEG
EXIDY  . . . . . . . . . . . . .  	Number	0000	
EXIT1  . . . . . . . . . . . . .  	L NEAR	146D	CSEG
EXIT2  . . . . . . . . . . . . .  	L NEAR	1392	CSEG
EXP  . . . . . . . . . . . . . .  	L NEAR	1268	CSEG	Global
EXP100 . . . . . . . . . . . . .  	L NEAR	12B1	CSEG
EXP110 . . . . . . . . . . . . .  	L NEAR	12B4	CSEG
EXP115 . . . . . . . . . . . . .  	L NEAR	12BE	CSEG
EXP200 . . . . . . . . . . . . .  	L NEAR	12C7	CSEG

F4FX20 . . . . . . . . . . . . .  	L NEAR	10EF	CSEG
F4VM10 . . . . . . . . . . . . .  	L NEAR	1013	CSEG
FA20 . . . . . . . . . . . . . .  	L NEAR	13C6	CSEG
FA22 . . . . . . . . . . . . . .  	L NEAR	13D5	CSEG
FA23 . . . . . . . . . . . . . .  	L NEAR	13F0	CSEG
FA24 . . . . . . . . . . . . . .  	L NEAR	1402	CSEG
FA25 . . . . . . . . . . . . . .  	L NEAR	1415	CSEG
FA27 . . . . . . . . . . . . . .  	L NEAR	141C	CSEG
FA30 . . . . . . . . . . . . . .  	L NEAR	141D	CSEG
FA40 . . . . . . . . . . . . . .  	L NEAR	142A	CSEG
FA50 . . . . . . . . . . . . . .  	L NEAR	1452	CSEG
FA60 . . . . . . . . . . . . . .  	L NEAR	1458	CSEG
FA70 . . . . . . . . . . . . . .  	L NEAR	1464	CSEG
FA80 . . . . . . . . . . . . . .  	L NEAR	1467	CSEG
FA90 . . . . . . . . . . . . . .  	L NEAR	146A	CSEG
FADD . . . . . . . . . . . . . .  	L NEAR	0E6B	CSEG	Global
FADDS  . . . . . . . . . . . . .  	L NEAR	0F78	CSEG	Global
FADDX1 . . . . . . . . . . . . .  	L NEAR	12D3	CSEG
FADDX2 . . . . . . . . . . . . .  	L NEAR	12D6	CSEG
FADFLT . . . . . . . . . . . . .  	L NEAR	0FB3	CSEG
FAST . . . . . . . . . . . . . .  	Number	0001	
FC10 . . . . . . . . . . . . . .  	L NEAR	1781	CSEG
FC20 . . . . . . . . . . . . . .  	L NEAR	1784	CSEG
FC200  . . . . . . . . . . . . .  	L NEAR	17F0	CSEG
FC30 . . . . . . . . . . . . . .  	L NEAR	178D	CSEG
FCI10  . . . . . . . . . . . . .  	L NEAR	0005	CSEG
FCI20  . . . . . . . . . . . . .  	L NEAR	0014	CSEG
FCOMP  . . . . . . . . . . . . .  	L NEAR	0F8B	CSEG	Global
FCV05  . . . . . . . . . . . . .  	L NEAR	19F3	CSEG
FCV10  . . . . . . . . . . . . .  	L NEAR	1A07	CSEG
FCV20  . . . . . . . . . . . . .  	L NEAR	1A0E	CSEG
FCV40  . . . . . . . . . . . . .  	L NEAR	1A33	CSEG
FCV45  . . . . . . . . . . . . .  	L NEAR	1A4D	CSEG
FCV50  . . . . . . . . . . . . .  	L NEAR	1A5C	CSEG
FCV60  . . . . . . . . . . . . .  	L NEAR	1A61	CSEG
FCV70  . . . . . . . . . . . . .  	L NEAR	1A6E	CSEG
FD10 . . . . . . . . . . . . . .  	L NEAR	17D2	CSEG
FDD20  . . . . . . . . . . . . .  	L NEAR	1324	CSEG
FDD25  . . . . . . . . . . . . .  	L NEAR	1332	CSEG
FDD30  . . . . . . . . . . . . .  	L NEAR	1341	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-5
                                                             

FDD35  . . . . . . . . . . . . .  	L NEAR	134A	CSEG
FDD37  . . . . . . . . . . . . .  	L NEAR	1356	CSEG
FDD40  . . . . . . . . . . . . .  	L NEAR	135C	CSEG
FDD50  . . . . . . . . . . . . .  	L NEAR	135F	CSEG
FDD60  . . . . . . . . . . . . .  	L NEAR	136E	CSEG
FDD70  . . . . . . . . . . . . .  	L NEAR	1377	CSEG
FDD80  . . . . . . . . . . . . .  	L NEAR	1381	CSEG
FDD90  . . . . . . . . . . . . .  	L NEAR	1384	CSEG
FDD95  . . . . . . . . . . . . .  	L NEAR	1387	CSEG
FDIV . . . . . . . . . . . . . .  	L NEAR	0E75	CSEG	Global
FDIVT  . . . . . . . . . . . . .  	L NEAR	1073	CSEG	Global
FDS00  . . . . . . . . . . . . .  	L NEAR	15E2	CSEG
FDS05  . . . . . . . . . . . . .  	L NEAR	15E6	CSEG
FDS10  . . . . . . . . . . . . .  	L NEAR	15E9	CSEG
FEXIT1 . . . . . . . . . . . . .  	L NEAR	138A	CSEG
FFFI20 . . . . . . . . . . . . .  	L NEAR	16EA	CSEG
FFI10  . . . . . . . . . . . . .  	L NEAR	16E4	CSEG
FFI20  . . . . . . . . . . . . .  	L NEAR	1800	CSEG
FFM10  . . . . . . . . . . . . .  	L NEAR	07F2	CSEG
FFM100 . . . . . . . . . . . . .  	L NEAR	088B	CSEG
FFM11  . . . . . . . . . . . . .  	L NEAR	0801	CSEG
FFM15  . . . . . . . . . . . . .  	L NEAR	080D	CSEG
FFM16  . . . . . . . . . . . . .  	L NEAR	0811	CSEG
FFM17  . . . . . . . . . . . . .  	L NEAR	0816	CSEG
FFM18  . . . . . . . . . . . . .  	L NEAR	0825	CSEG
FFM19  . . . . . . . . . . . . .  	L NEAR	0831	CSEG
FFM20  . . . . . . . . . . . . .  	L NEAR	0837	CSEG
FFM30  . . . . . . . . . . . . .  	L NEAR	083B	CSEG
FFM40  . . . . . . . . . . . . .  	L NEAR	084D	CSEG
FFM50  . . . . . . . . . . . . .  	L NEAR	0850	CSEG
FFM60  . . . . . . . . . . . . .  	L NEAR	085C	CSEG
FFM70  . . . . . . . . . . . . .  	L NEAR	086B	CSEG
FFM80  . . . . . . . . . . . . .  	L NEAR	087A	CSEG
FFM90  . . . . . . . . . . . . .  	L NEAR	087C	CSEG
FI05 . . . . . . . . . . . . . .  	L NEAR	16DF	CSEG
FI10 . . . . . . . . . . . . . .  	L NEAR	17FB	CSEG
FI30 . . . . . . . . . . . . . .  	L NEAR	16FE	CSEG
FI35 . . . . . . . . . . . . . .  	L NEAR	1714	CSEG
FI40 . . . . . . . . . . . . . .  	L NEAR	1717	CSEG
FI50 . . . . . . . . . . . . . .  	L NEAR	1727	CSEG
FIN  . . . . . . . . . . . . . .  	L NEAR	0BFC	CSEG	Global
FIN05  . . . . . . . . . . . . .  	L NEAR	070A	CSEG
FIN20  . . . . . . . . . . . . .  	L NEAR	071A	CSEG
FIN25  . . . . . . . . . . . . .  	L NEAR	0730	CSEG
FIN30  . . . . . . . . . . . . .  	L NEAR	0734	CSEG
FIN40  . . . . . . . . . . . . .  	L NEAR	0747	CSEG
FIN45  . . . . . . . . . . . . .  	L NEAR	074A	CSEG
FIN50  . . . . . . . . . . . . .  	L NEAR	0750	CSEG
FIN55  . . . . . . . . . . . . .  	L NEAR	0751	CSEG
FIN80  . . . . . . . . . . . . .  	L NEAR	0752	CSEG
FINDBL . . . . . . . . . . . . .  	L NEAR	0C00	CSEG	Global
FINF . . . . . . . . . . . . . .  	L NEAR	0CA5	CSEG
FIVDSK . . . . . . . . . . . . .  	Number	0001	
FIVEO  . . . . . . . . . . . . .  	Number	0001	
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-6
                                                             

FIVLPT . . . . . . . . . . . . .  	Number	0001	
FIVMEM . . . . . . . . . . . . .  	Number	0001	
FIXER  . . . . . . . . . . . . .  	L NEAR	10E2	CSEG	Global
FKEYON . . . . . . . . . . . . .  	Number	0001	
FL10 . . . . . . . . . . . . . .  	L NEAR	0FB8	CSEG
FLOAT  . . . . . . . . . . . . .  	L NEAR	0E81	CSEG
FLOATR . . . . . . . . . . . . .  	L NEAR	0FA5	CSEG
FLT10  . . . . . . . . . . . . .  	L NEAR	1865	CSEG
FMD10  . . . . . . . . . . . . .  	L NEAR	1884	CSEG
FMD20  . . . . . . . . . . . . .  	L NEAR	1885	CSEG
FMS00  . . . . . . . . . . . . .  	L NEAR	1926	CSEG
FMS05  . . . . . . . . . . . . .  	L NEAR	1929	CSEG
FMS10  . . . . . . . . . . . . .  	L NEAR	194B	CSEG
FMS20  . . . . . . . . . . . . .  	L NEAR	1957	CSEG
FMS30  . . . . . . . . . . . . .  	L NEAR	1970	CSEG
FMS35  . . . . . . . . . . . . .  	L NEAR	197D	CSEG
FMS37  . . . . . . . . . . . . .  	L NEAR	1981	CSEG
FMULT  . . . . . . . . . . . . .  	L NEAR	0E8A	CSEG	Global
FN100  . . . . . . . . . . . . .  	L NEAR	0C7E	CSEG
FN20 . . . . . . . . . . . . . .  	L NEAR	0C07	CSEG
FN200  . . . . . . . . . . . . .  	L NEAR	0C91	CSEG
FN30 . . . . . . . . . . . . . .  	L NEAR	0C26	CSEG
FN40 . . . . . . . . . . . . . .  	L NEAR	0C2F	CSEG
FN400  . . . . . . . . . . . . .  	L NEAR	0C98	CSEG
FN50 . . . . . . . . . . . . . .  	L NEAR	0C39	CSEG
FN500  . . . . . . . . . . . . .  	L NEAR	0C9B	CSEG
FN55 . . . . . . . . . . . . . .  	L NEAR	0C3E	CSEG
FN60 . . . . . . . . . . . . . .  	L NEAR	0C43	CSEG
FN600  . . . . . . . . . . . . .  	L NEAR	0CA0	CSEG
FN70 . . . . . . . . . . . . . .  	L NEAR	0C4A	CSEG
FN80 . . . . . . . . . . . . . .  	L NEAR	0C59	CSEG
FN90 . . . . . . . . . . . . . .  	L NEAR	0C5F	CSEG
FN92 . . . . . . . . . . . . . .  	L NEAR	0C74	CSEG
FN94 . . . . . . . . . . . . . .  	L NEAR	0C76	CSEG
FN95 . . . . . . . . . . . . . .  	L WORD 	0C64	CSEG
FN96 . . . . . . . . . . . . . .  	L NEAR	0C79	CSEG
FN990  . . . . . . . . . . . . .  	L NEAR	0CB5	CSEG
FNDITV . . . . . . . . . . . . .  	L NEAR	11A3	CSEG
FNV10  . . . . . . . . . . . . .  	L NEAR	1AC5	CSEG
FNV20  . . . . . . . . . . . . .  	L NEAR	1ADD	CSEG
FNV30  . . . . . . . . . . . . .  	L NEAR	1AEE	CSEG
FNV40  . . . . . . . . . . . . .  	L NEAR	1B12	CSEG
FNV44  . . . . . . . . . . . . .  	L NEAR	1B0B	CSEG
FNV50  . . . . . . . . . . . . .  	L NEAR	1B13	CSEG
FO20 . . . . . . . . . . . . . .  	L NEAR	1B38	CSEG
FO50 . . . . . . . . . . . . . .  	L NEAR	1B62	CSEG
FOUINI . . . . . . . . . . . . .  	L NEAR	10A7	CSEG
FOUT . . . . . . . . . . . . . .  	L NEAR	1B3E	CSEG	Global
FOUTH  . . . . . . . . . . . . .  	L NEAR	0F6E	CSEG	Global
FOUTO  . . . . . . . . . . . . .  	L NEAR	0F64	CSEG	Global
FP10 . . . . . . . . . . . . . .  	L NEAR	0D3B	CSEG
FP20 . . . . . . . . . . . . . .  	L NEAR	0D44	CSEG
FP25 . . . . . . . . . . . . . .  	L NEAR	0D4B	CSEG
FP27 . . . . . . . . . . . . . .  	L NEAR	0D59	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-7
                                                             

FP30 . . . . . . . . . . . . . .  	L NEAR	0D75	CSEG
FP30A  . . . . . . . . . . . . .  	L NEAR	0DB9	CSEG
FP34 . . . . . . . . . . . . . .  	L NEAR	0DE6	CSEG
FP40 . . . . . . . . . . . . . .  	L NEAR	0DF7	CSEG
FP60 . . . . . . . . . . . . . .  	L NEAR	0E0C	CSEG
FPRNDUP  . . . . . . . . . . . .  	L NEAR	15A3	CSEG
FPWR . . . . . . . . . . . . . .  	L NEAR	0E8F	CSEG
FPWRND . . . . . . . . . . . . .  	L NEAR	0D0E	CSEG
FPWRQ  . . . . . . . . . . . . .  	L NEAR	1078	CSEG	Global
FPWRT  . . . . . . . . . . . . .  	L NEAR	107B	CSEG
FRCDBL . . . . . . . . . . . . .  	L NEAR	17C8	CSEG	Global
FRCINT . . . . . . . . . . . . .  	L NEAR	17F1	CSEG	Global
FRCSNG . . . . . . . . . . . . .  	L NEAR	1799	CSEG	Global
FRCSTR . . . . . . . . . . . . .  	L NEAR	0F93	CSEG	Global
FRQINT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FS10 . . . . . . . . . . . . . .  	L NEAR	17A3	CSEG
FSUB . . . . . . . . . . . . . .  	L NEAR	0E70	CSEG	Global
FTD05  . . . . . . . . . . . . .  	L NEAR	19A7	CSEG
FTD10  . . . . . . . . . . . . .  	L NEAR	19B5	CSEG
FTD20  . . . . . . . . . . . . .  	L NEAR	19BF	CSEG
FTH10  . . . . . . . . . . . . .  	L NEAR	003C	CSEG
FTH20  . . . . . . . . . . . . .  	L NEAR	0048	CSEG
FTH40  . . . . . . . . . . . . .  	L NEAR	0063	CSEG
FTH50  . . . . . . . . . . . . .  	L NEAR	006B	CSEG
FTN10  . . . . . . . . . . . . .  	L NEAR	1998	CSEG
FTZ10  . . . . . . . . . . . . .  	L NEAR	0149	CSEG
FTZ15  . . . . . . . . . . . . .  	L NEAR	014F	CSEG
FTZC10 . . . . . . . . . . . . .  	L NEAR	0152	CSEG
FX00 . . . . . . . . . . . . . .  	L NEAR	1750	CSEG
FX10 . . . . . . . . . . . . . .  	L NEAR	1755	CSEG
FX20 . . . . . . . . . . . . . .  	L NEAR	175B	CSEG
FX30 . . . . . . . . . . . . . .  	L NEAR	1766	CSEG
FZ10 . . . . . . . . . . . . . .  	L NEAR	00F1	CSEG
FZ20 . . . . . . . . . . . . . .  	L NEAR	00FB	CSEG
FZ30 . . . . . . . . . . . . . .  	L NEAR	010A	CSEG
FZ40 . . . . . . . . . . . . . .  	L NEAR	0110	CSEG
FZ45 . . . . . . . . . . . . . .  	L WORD 	0115	CSEG
FZ50 . . . . . . . . . . . . . .  	L NEAR	0129	CSEG
FZ60 . . . . . . . . . . . . . .  	L NEAR	012D	CSEG
FZ70 . . . . . . . . . . . . . .  	L NEAR	013A	CSEG
FZ90 . . . . . . . . . . . . . .  	L NEAR	0144	CSEG

GENBIN . . . . . . . . . . . . .  	Number	0001	
GENDSK . . . . . . . . . . . . .  	Number	0000	
GENIO  . . . . . . . . . . . . .  	Number	0001	
GESBC  . . . . . . . . . . . . .  	Number	0000	
GETBCD . . . . . . . . . . . . .  	L NEAR	108A	CSEG	Global
GIO86  . . . . . . . . . . . . .  	Number	0001	
GW . . . . . . . . . . . . . . .  	Number	0001	
GWCASS . . . . . . . . . . . . .  	Number	0000	
GWDBUG . . . . . . . . . . . . .  	Number	0000	

HEATH  . . . . . . . . . . . . .  	Number	0000	
HEXOCT . . . . . . . . . . . . .  	Number	0001	
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-8
                                                             

HGHBIT . . . . . . . . . . . . .  	Number	0001	
HIDBL  . . . . . . . . . . . . .  	L NEAR	1B18	CSEG

I8086  . . . . . . . . . . . . .  	Number	0001	
I8251  . . . . . . . . . . . . .  	Number	0000	
IAD10  . . . . . . . . . . . . .  	L NEAR	0EB6	CSEG
IADD . . . . . . . . . . . . . .  	L NEAR	0EAD	CSEG	Global
IBMLIK . . . . . . . . . . . . .  	Number	0001	
IBMTOK . . . . . . . . . . . . .  	Number	0001	
IC10 . . . . . . . . . . . . . .  	L NEAR	1102	CSEG
IC15 . . . . . . . . . . . . . .  	L NEAR	1106	CSEG
IC20 . . . . . . . . . . . . . .  	L NEAR	1107	CSEG
IC30 . . . . . . . . . . . . . .  	L NEAR	1109	CSEG
IC40 . . . . . . . . . . . . . .  	L NEAR	110C	CSEG
ICMPA  . . . . . . . . . . . . .  	L NEAR	10FA	CSEG	Global
ICOMP  . . . . . . . . . . . . .  	L NEAR	10F8	CSEG	Global
ICOMPS . . . . . . . . . . . . .  	L NEAR	10C5	CSEG
IDIV . . . . . . . . . . . . . .  	L NEAR	0EEC	CSEG	Global
IDIV10 . . . . . . . . . . . . .  	L NEAR	0EFE	CSEG
IDIV11 . . . . . . . . . . . . .  	L NEAR	0F10	CSEG
IDIV15 . . . . . . . . . . . . .  	L NEAR	0F1A	CSEG
IDV20  . . . . . . . . . . . . .  	L NEAR	0F2C	CSEG
IDV30  . . . . . . . . . . . . .  	L NEAR	0F36	CSEG
IM10 . . . . . . . . . . . . . .  	L NEAR	0ED7	CSEG
IMD05  . . . . . . . . . . . . .  	L NEAR	1111	CSEG
IMD10  . . . . . . . . . . . . .  	L NEAR	1116	CSEG
IMD15  . . . . . . . . . . . . .  	L NEAR	1126	CSEG
IMD17  . . . . . . . . . . . . .  	L NEAR	113E	CSEG
IMD20  . . . . . . . . . . . . .  	L NEAR	114C	CSEG
IMD30  . . . . . . . . . . . . .  	L NEAR	1156	CSEG
IMD40  . . . . . . . . . . . . .  	L NEAR	115C	CSEG
IMOD . . . . . . . . . . . . . .  	L NEAR	110D	CSEG	Global
IMULT  . . . . . . . . . . . . .  	L NEAR	0ECA	CSEG	Global
INCEXP . . . . . . . . . . . . .  	L NEAR	1678	CSEG
INEG . . . . . . . . . . . . . .  	L NEAR	0B2A	CSEG	Global
INEG2  . . . . . . . . . . . . .  	L NEAR	0F9C	CSEG	Global
INEGAD . . . . . . . . . . . . .  	L NEAR	0FA3	CSEG
INF10  . . . . . . . . . . . . .  	L NEAR	07C6	CSEG
INF20  . . . . . . . . . . . . .  	L NEAR	07D3	CSEG
INF30  . . . . . . . . . . . . .  	L NEAR	07DC	CSEG
INKEYF . . . . . . . . . . . . .  	Number	0001	
INLADD . . . . . . . . . . . . .  	Number	0000	
INPRT  . . . . . . . . . . . . .  	L NEAR	1096	CSEG	Global
INRART . . . . . . . . . . . . .  	L NEAR	1104	CSEG	Global
INSTSW . . . . . . . . . . . . .  	Number	0000	
INT  . . . . . . . . . . . . . .  	L NEAR	1BD4	CSEG	Global
INT10  . . . . . . . . . . . . .  	L NEAR	1C0C	CSEG
INT11  . . . . . . . . . . . . .  	L NEAR	1C12	CSEG
INT12  . . . . . . . . . . . . .  	L NEAR	1C18	CSEG
INT15  . . . . . . . . . . . . .  	L NEAR	1C21	CSEG
INT20  . . . . . . . . . . . . .  	L NEAR	1C29	CSEG
INT30  . . . . . . . . . . . . .  	L NEAR	1C36	CSEG
INTEL  . . . . . . . . . . . . .  	Number	0000	
INTFHW . . . . . . . . . . . . .  	Number	0000	
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-9
                                                             

INTFSW . . . . . . . . . . . . .  	Number	0000	
INTLEC . . . . . . . . . . . . .  	Number	0000	
INTROM . . . . . . . . . . . . .  	Number	0000	
INTXT  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
INVERT . . . . . . . . . . . . .  	L NEAR	0DAD	CSEG
INXHRT . . . . . . . . . . . . .  	L NEAR	1092	CSEG	Global
IS10 . . . . . . . . . . . . . .  	L NEAR	0EAB	CSEG
ISARY  . . . . . . . . . . . . .  	L NEAR	11D0	CSEG
ISC  . . . . . . . . . . . . . .  	Number	0000	
ISI10  . . . . . . . . . . . . .  	L NEAR	1044	CSEG
ISI15  . . . . . . . . . . . . .  	L NEAR	104B	CSEG
ISIGN  . . . . . . . . . . . . .  	L NEAR	1052	CSEG	Global
ISIGN1 . . . . . . . . . . . . .  	L NEAR	1051	CSEG
ISIS . . . . . . . . . . . . . .  	Number	0000	
ISIT . . . . . . . . . . . . . .  	L NEAR	1177	CSEG
ISUB . . . . . . . . . . . . . .  	L NEAR	0E94	CSEG	Global

JISKTN . . . . . . . . . . . . .  	Number	0000	

KANABS . . . . . . . . . . . . .  	Number	0000	
KANJFN . . . . . . . . . . . . .  	Number	0000	
KEYSTA . . . . . . . . . . . . .  	Number	0000	
KILLER . . . . . . . . . . . . .  	Number	0000	

LABKEY . . . . . . . . . . . . .  	Number	0001	
LEN2 . . . . . . . . . . . . . .  	Number	0001	
LEN3 . . . . . . . . . . . . . .  	Number	0001	
LENGTH . . . . . . . . . . . . .  	Number	0002	
LENMAT . . . . . . . . . . . . .  	L NEAR	118F	CSEG
LG100  . . . . . . . . . . . . .  	L NEAR	1C96	CSEG
LINLN  . . . . . . . . . . . . .  	Number	0050	
LINOUT . . . . . . . . . . . . .  	L NEAR	10A2	CSEG
LINPRT . . . . . . . . . . . . .  	L NEAR	109E	CSEG	Global
LISTEN . . . . . . . . . . . . .  	Number	0001	
LNGVAR . . . . . . . . . . . . .  	Number	0001	
LOG  . . . . . . . . . . . . . .  	L NEAR	1C40	CSEG	Global
LOG10  . . . . . . . . . . . . .  	L NEAR	1C59	CSEG
LOKHED . . . . . . . . . . . . .  	Number	0000	
LONGI  . . . . . . . . . . . . .  	Number	0000	
LOPFD0 . . . . . . . . . . . . .  	L NEAR	11BA	CSEG
LOPFD1 . . . . . . . . . . . . .  	L NEAR	11B0	CSEG	Global
LOPFDI . . . . . . . . . . . . .  	L NEAR	11C7	CSEG
LOPFND . . . . . . . . . . . . .  	L NEAR	11A7	CSEG	Global
LOPTOP . . . . . . . . . . . . .  	L NEAR	1161	CSEG
LPT3 . . . . . . . . . . . . . .  	Number	0000	
LPTLEN . . . . . . . . . . . . .  	Number	0084	
LPTSW  . . . . . . . . . . . . .  	Number	0001	

M1 . . . . . . . . . . . . . . .  	L NEAR	18A5	CSEG
M4 . . . . . . . . . . . . . . .  	L NEAR	18B0	CSEG
M4A  . . . . . . . . . . . . . .  	L NEAR	18C2	CSEG
M4B  . . . . . . . . . . . . . .  	L NEAR	18C7	CSEG
M4C  . . . . . . . . . . . . . .  	L NEAR	18D5	CSEG
M4D  . . . . . . . . . . . . . .  	L NEAR	18D7	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-10
                                                             

M5 . . . . . . . . . . . . . . .  	L NEAR	18E7	CSEG
M5A  . . . . . . . . . . . . . .  	L NEAR	190B	CSEG
M5AA . . . . . . . . . . . . . .  	L NEAR	18EE	CSEG
M5AB . . . . . . . . . . . . . .  	L NEAR	18FA	CSEG
M5B  . . . . . . . . . . . . . .  	L NEAR	1911	CSEG
M6 . . . . . . . . . . . . . . .  	L NEAR	1914	CSEG
MAF05  . . . . . . . . . . . . .  	L NEAR	09F0	CSEG
MAKINT . . . . . . . . . . . . .  	L NEAR	105E	CSEG	Global
MAXQUO . . . . . . . . . . . . .  	L NEAR	16A6	CSEG
MBF05  . . . . . . . . . . . . .  	L NEAR	09BE	CSEG
MBF10  . . . . . . . . . . . . .  	L NEAR	09C1	CSEG
MBF20  . . . . . . . . . . . . .  	L NEAR	09C4	CSEG
MDP10  . . . . . . . . . . . . .  	L NEAR	0757	CSEG
MDPTEN . . . . . . . . . . . . .  	L NEAR	0710	CSEG
MDS  . . . . . . . . . . . . . .  	Number	0000	
MDSISS . . . . . . . . . . . . .  	Number	0000	
MEMIMG . . . . . . . . . . . . .  	Number	0001	
ML05 . . . . . . . . . . . . . .  	L NEAR	0926	CSEG
ML10 . . . . . . . . . . . . . .  	L NEAR	092D	CSEG
MLLN2  . . . . . . . . . . . . .  	L NEAR	1C8D	CSEG
MOSTEK . . . . . . . . . . . . .  	Number	0000	
MOVAM  . . . . . . . . . . . . .  	L NEAR	09D9	CSEG
MOVE . . . . . . . . . . . . . .  	L NEAR	1080	CSEG	Global
MOVE1  . . . . . . . . . . . . .  	L NEAR	1005	CSEG	Global
MOVEM  . . . . . . . . . . . . .  	L NEAR	09DF	CSEG
MOVFM  . . . . . . . . . . . . .  	L NEAR	0F47	CSEG	Global
MOVFR  . . . . . . . . . . . . .  	L NEAR	0F3F	CSEG	Global
MOVMF  . . . . . . . . . . . . .  	L NEAR	0F59	CSEG	Global
MOVRF  . . . . . . . . . . . . .  	L NEAR	0F50	CSEG	Global
MOVRM  . . . . . . . . . . . . .  	L NEAR	1085	CSEG	Global
MOVVFM . . . . . . . . . . . . .  	L NEAR	100B	CSEG
MULSEG . . . . . . . . . . . . .  	Number	0001	

NAMBUF . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
NAMCNT . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
NAMLEN . . . . . . . . . . . . .  	Number	0028	
NASCOM . . . . . . . . . . . . .  	Number	0000	
NATROM . . . . . . . . . . . . .  	Number	0000	
NBANKS . . . . . . . . . . . . .  	Number	0001	
NCRBAS . . . . . . . . . . . . .  	Number	0000	
NCRCAS . . . . . . . . . . . . .  	Number	0000	
NCRDEB . . . . . . . . . . . . .  	Number	0000	
NCRELS . . . . . . . . . . . . .  	Number	0000	
NCRLPT . . . . . . . . . . . . .  	Number	0001	
NECBAS . . . . . . . . . . . . .  	Number	0000	
NEG  . . . . . . . . . . . . . .  	L NEAR	0B24	CSEG	Global
NEGNUM . . . . . . . . . . . . .  	L NEAR	0D26	CSEG
NEGR . . . . . . . . . . . . . .  	L NEAR	10CC	CSEG
NEW10  . . . . . . . . . . . . .  	L NEAR	1F69	CSEG
NEWSD  . . . . . . . . . . . . .  	L NEAR	1F63	CSEG
NG10 . . . . . . . . . . . . . .  	L NEAR	10E1	CSEG
NGBLDX . . . . . . . . . . . . .  	L NEAR	1C2A	CSEG
NMARY1 . . . . . . . . . . . . .  	L NEAR	11BF	CSEG
NMARY2 . . . . . . . . . . . . .  	L NEAR	11C0	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-11
                                                             

NMARY3 . . . . . . . . . . . . .  	L NEAR	11C1	CSEG
NMARY4 . . . . . . . . . . . . .  	L NEAR	11C4	CSEG
NMCOMT . . . . . . . . . . . . .  	Number	0002	
NMKEYF . . . . . . . . . . . . .  	Number	000A	
NMKEYT . . . . . . . . . . . . .  	Number	000E	
NMLINE . . . . . . . . . . . . .  	Number	0019	
NMLPT  . . . . . . . . . . . . .  	Number	0003	
NMPENT . . . . . . . . . . . . .  	Number	0001	
NMSTRT . . . . . . . . . . . . .  	Number	0004	
NOATDL . . . . . . . . . . . . .  	Number	0000	
NOCTLA . . . . . . . . . . . . .  	Number	0000	
NODOT  . . . . . . . . . . . . .  	Number	0000	
NOEDIT . . . . . . . . . . . . .  	Number	0000	
NOIOS  . . . . . . . . . . . . .  	Number	0000	
NONULL . . . . . . . . . . . . .  	Number	0000	
NOPEKS . . . . . . . . . . . . .  	Number	0000	
NOR10  . . . . . . . . . . . . .  	L NEAR	1CEB	CSEG
NOR15  . . . . . . . . . . . . .  	L NEAR	1D02	CSEG
NOR16  . . . . . . . . . . . . .  	L NEAR	1D09	CSEG
NOR17  . . . . . . . . . . . . .  	L NEAR	1D0D	CSEG
NOR20  . . . . . . . . . . . . .  	L NEAR	1D10	CSEG
NORD10 . . . . . . . . . . . . .  	L NEAR	1CA6	CSEG
NORD20 . . . . . . . . . . . . .  	L NEAR	1CAA	CSEG
NORD25 . . . . . . . . . . . . .  	L NEAR	1CB3	CSEG
NORD30 . . . . . . . . . . . . .  	L NEAR	1CBB	CSEG
NORD40 . . . . . . . . . . . . .  	L NEAR	1CDC	CSEG
NORD5  . . . . . . . . . . . . .  	L NEAR	1C9E	CSEG
NORD50 . . . . . . . . . . . . .  	L NEAR	1CE1	CSEG
NORMCHK  . . . . . . . . . . . .  	L NEAR	1668	CSEG
NOROMP . . . . . . . . . . . . .  	Number	0000	
NORUBT . . . . . . . . . . . . .  	Number	0000	
NOTFDD . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
NOTFNS . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
NOTIT0 . . . . . . . . . . . . .  	L NEAR	116B	CSEG
NOTIT1 . . . . . . . . . . . . .  	L NEAR	1166	CSEG
NOTIT2 . . . . . . . . . . . . .  	L NEAR	116E	CSEG
NOUSR  . . . . . . . . . . . . .  	Number	0000	
NOVARP . . . . . . . . . . . . .  	Number	0000	
NSTK1  . . . . . . . . . . . . .  	L NEAR	163B	CSEG
NUMLEV . . . . . . . . . . . . .  	Number	006E	
NUMTMP . . . . . . . . . . . . .  	Number	000A	
NUMTRP . . . . . . . . . . . . .  	Number	0015	
NZCOMP . . . . . . . . . . . . .  	L NEAR	0A20	CSEG

OEMRAM . . . . . . . . . . . . .  	Number	0000	
OLDRN  . . . . . . . . . . . . .  	L NEAR	1F76	CSEG
ONEARG . . . . . . . . . . . . .  	L NEAR	0660	CSEG
ONELIN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ONTEL  . . . . . . . . . . . . .  	Number	0000	
OUTDO  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
OVCHK  . . . . . . . . . . . . .  	L NEAR	1841	CSEG
OVCHKJ . . . . . . . . . . . . .  	L NEAR	163F	CSEG
OVERFLOW . . . . . . . . . . . .  	L NEAR	184B	CSEG
OVERR  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-12
                                                             

OVFLS  . . . . . . . . . . . . .  	L NEAR	077B	CSEG

PAKSP  . . . . . . . . . . . . .  	L NEAR	1FE9	CSEG
PALSIZ . . . . . . . . . . . . .  	Number	0000	
PANBAS . . . . . . . . . . . . .  	Number	0000	
PCS  . . . . . . . . . . . . . .  	Number	0000	
PFE10  . . . . . . . . . . . . .  	L NEAR	0167	CSEG
PFE100 . . . . . . . . . . . . .  	L NEAR	0236	CSEG
PFE110 . . . . . . . . . . . . .  	L NEAR	024F	CSEG
PFE20  . . . . . . . . . . . . .  	L NEAR	0177	CSEG
PFE30  . . . . . . . . . . . . .  	L NEAR	0186	CSEG
PFE40  . . . . . . . . . . . . .  	L NEAR	0194	CSEG
PFE45  . . . . . . . . . . . . .  	L NEAR	019E	CSEG
PFE50  . . . . . . . . . . . . .  	L NEAR	01A0	CSEG
PFE55  . . . . . . . . . . . . .  	L NEAR	01CB	CSEG
PFE57  . . . . . . . . . . . . .  	L NEAR	01D9	CSEG
PFE65  . . . . . . . . . . . . .  	L NEAR	01EC	CSEG
PFE66  . . . . . . . . . . . . .  	L NEAR	01EE	CSEG
PFE70  . . . . . . . . . . . . .  	L NEAR	0204	CSEG
PFE80  . . . . . . . . . . . . .  	L NEAR	0222	CSEG
PFE90  . . . . . . . . . . . . .  	L NEAR	0232	CSEG
PFO05  . . . . . . . . . . . . .  	L NEAR	1E88	CSEG
PFO10  . . . . . . . . . . . . .  	L NEAR	1E9F	CSEG
PFO20  . . . . . . . . . . . . .  	L NEAR	1EAE	CSEG
PFO40  . . . . . . . . . . . . .  	L NEAR	1EC1	CSEG
PFX10  . . . . . . . . . . . . .  	L NEAR	0076	CSEG
PFX20  . . . . . . . . . . . . .  	L NEAR	007C	CSEG
PFX30  . . . . . . . . . . . . .  	L NEAR	007D	CSEG
PFX40  . . . . . . . . . . . . .  	L NEAR	009E	CSEG
PFX50  . . . . . . . . . . . . .  	L NEAR	00BD	CSEG
PFX60  . . . . . . . . . . . . .  	L NEAR	00C0	CSEG
PFX70  . . . . . . . . . . . . .  	L NEAR	00CA	CSEG
PFX90  . . . . . . . . . . . . .  	L NEAR	00D3	CSEG
PI10 . . . . . . . . . . . . . .  	L NEAR	1EDE	CSEG
PI20 . . . . . . . . . . . . . .  	L NEAR	1EE7	CSEG
PI30 . . . . . . . . . . . . . .  	L NEAR	1EF2	CSEG
PI40 . . . . . . . . . . . . . .  	L NEAR	1EFC	CSEG
PLAYSW . . . . . . . . . . . . .  	Number	0001	
POL10  . . . . . . . . . . . . .  	L NEAR	1D46	CSEG
POL30  . . . . . . . . . . . . .  	L NEAR	1D62	CSEG
POPHRT . . . . . . . . . . . . .  	L NEAR	1059	CSEG	Global
POSBOVER . . . . . . . . . . . .  	L NEAR	183B	CSEG
POSEXP . . . . . . . . . . . . .  	L NEAR	075E	CSEG
PUF10  . . . . . . . . . . . . .  	L NEAR	1D6B	CSEG
PUF100 . . . . . . . . . . . . .  	L NEAR	1DEB	CSEG
PUF110 . . . . . . . . . . . . .  	L NEAR	1DFC	CSEG
PUF120 . . . . . . . . . . . . .  	L NEAR	1E24	CSEG
PUF130 . . . . . . . . . . . . .  	L NEAR	1E37	CSEG
PUF140 . . . . . . . . . . . . .  	L NEAR	1E3A	CSEG
PUF150 . . . . . . . . . . . . .  	L NEAR	1E55	CSEG
PUF160 . . . . . . . . . . . . .  	L NEAR	1E5E	CSEG
PUF30  . . . . . . . . . . . . .  	L NEAR	1D7F	CSEG
PUF40  . . . . . . . . . . . . .  	L NEAR	1D88	CSEG
PUF50  . . . . . . . . . . . . .  	L NEAR	1D90	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-13
                                                             

PUF60  . . . . . . . . . . . . .  	L NEAR	1DA2	CSEG
PUF70  . . . . . . . . . . . . .  	L NEAR	1DC4	CSEG
PUF80  . . . . . . . . . . . . .  	L NEAR	1DD2	CSEG
PUF90  . . . . . . . . . . . . .  	L NEAR	1DDD	CSEG
PUFOUT . . . . . . . . . . . . .  	L NEAR	1E7D	CSEG	Global
PURE . . . . . . . . . . . . . .  	Number	0001	
PUSHF  . . . . . . . . . . . . .  	L NEAR	0F80	CSEG	Global

QINT . . . . . . . . . . . . . .  	L NEAR	1C37	CSEG
QINTNZ . . . . . . . . . . . . .  	L NEAR	1BF2	CSEG
QINTX  . . . . . . . . . . . . .  	L NEAR	1BDF	CSEG
QUEUE  . . . . . . . . . . . . .  	Number	0001	

RDD10  . . . . . . . . . . . . .  	L NEAR	1F98	CSEG
RDD20  . . . . . . . . . . . . .  	L NEAR	1FA6	CSEG
RDD30  . . . . . . . . . . . . .  	L NEAR	1FC3	CSEG
RDL120 . . . . . . . . . . . . .  	L NEAR	0949	CSEG
REALIO . . . . . . . . . . . . .  	Number	0001	
REASON . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
REM2 . . . . . . . . . . . . . .  	L NEAR	1520	CSEG
REM3 . . . . . . . . . . . . . .  	L NEAR	152E	CSEG
REM4 . . . . . . . . . . . . . .  	L NEAR	153D	CSEG
RESTORE  . . . . . . . . . . . .  	L NEAR	1660	CSEG
RETJ . . . . . . . . . . . . . .  	L NEAR	1667	CSEG
RETRES . . . . . . . . . . . . .  	L NEAR	1560	CSEG
RMX  . . . . . . . . . . . . . .  	Number	0000	
RND  . . . . . . . . . . . . . .  	L NEAR	1F03	CSEG	Global
RND10  . . . . . . . . . . . . .  	L NEAR	1F16	CSEG
RNDMN2 . . . . . . . . . . . . .  	L NEAR	0FC2	CSEG	Global
RNDMON . . . . . . . . . . . . .  	L NEAR	0FBF	CSEG	Global
ROOTBT . . . . . . . . . . . . .  	L NEAR	0D0B	CSEG
ROUND  . . . . . . . . . . . . .  	L NEAR	167C	CSEG
ROUNDUP  . . . . . . . . . . . .  	L NEAR	1688	CSEG
RR . . . . . . . . . . . . . . .  	L NEAR	063E	CSEG
RR1  . . . . . . . . . . . . . .  	L NEAR	064A	CSEG
RR2  . . . . . . . . . . . . . .  	L NEAR	064D	CSEG
RR3  . . . . . . . . . . . . . .  	L NEAR	0653	CSEG
RSHACK . . . . . . . . . . . . .  	Number	0000	
RSTLES . . . . . . . . . . . . .  	Number	0001	
RTLP . . . . . . . . . . . . . .  	L NEAR	0CE7	CSEG

S  . . . . . . . . . . . . . . .  	L NEAR	1B20	CSEG
SAVE . . . . . . . . . . . . . .  	L NEAR	1694	CSEG
SBC  . . . . . . . . . . . . . .  	Number	0000	
SBC86  . . . . . . . . . . . . .  	Number	0000	
SCP  . . . . . . . . . . . . . .  	Number	0001	
SCRN86 . . . . . . . . . . . . .  	Number	0001	
SCRNIO . . . . . . . . . . . . .  	Number	0001	
SCROLT . . . . . . . . . . . . .  	Number	0001	
SDIVOVFL . . . . . . . . . . . .  	L NEAR	1641	CSEG
SES00  . . . . . . . . . . . . .  	L NEAR	1200	CSEG
SES05  . . . . . . . . . . . . .  	L NEAR	1220	CSEG
SES07  . . . . . . . . . . . . .  	L NEAR	1222	CSEG
SES10  . . . . . . . . . . . . .  	L NEAR	1233	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-14
                                                             

SES20  . . . . . . . . . . . . .  	L NEAR	1240	CSEG
SES30  . . . . . . . . . . . . .  	L NEAR	1243	CSEG
SG15 . . . . . . . . . . . . . .  	L NEAR	10CB	CSEG
SGN  . . . . . . . . . . . . . .  	L NEAR	106E	CSEG	Global
SGSATS . . . . . . . . . . . . .  	Number	0000	
SHORTJ . . . . . . . . . . . . .  	Number	0001	
SHRA11 . . . . . . . . . . . . .  	L NEAR	0972	CSEG
SHRA30 . . . . . . . . . . . . .  	L NEAR	098D	CSEG
SHRA40 . . . . . . . . . . . . .  	L NEAR	099F	CSEG
SHRD10 . . . . . . . . . . . . .  	L NEAR	1BAD	CSEG
SHST . . . . . . . . . . . . . .  	L NEAR	095A	CSEG
SHTCHN . . . . . . . . . . . . .  	Number	0000	
SHTERR . . . . . . . . . . . . .  	Number	0000	
SHTINS . . . . . . . . . . . . .  	Number	0000	
SHTLHM . . . . . . . . . . . . .  	Number	0000	
SHTLIN . . . . . . . . . . . . .  	Number	0000	
SHTPRO . . . . . . . . . . . . .  	Number	0000	
SHTREN . . . . . . . . . . . . .  	Number	0000	
SI20 . . . . . . . . . . . . . .  	L NEAR	2020	CSEG
SI30 . . . . . . . . . . . . . .  	L NEAR	2027	CSEG
SI31 . . . . . . . . . . . . . .  	L NEAR	2013	CSEG
SI32 . . . . . . . . . . . . . .  	L NEAR	201A	CSEG
SI35 . . . . . . . . . . . . . .  	L NEAR	2051	CSEG
SI40 . . . . . . . . . . . . . .  	L NEAR	205B	CSEG
SIGN . . . . . . . . . . . . . .  	L NEAR	08BE	CSEG	Global
SIGNAL . . . . . . . . . . . . .  	L NEAR	08E0	CSEG
SIGNC  . . . . . . . . . . . . .  	L NEAR	10B9	CSEG	Global
SIGNS  . . . . . . . . . . . . .  	L NEAR	10C7	CSEG	Global
SIN  . . . . . . . . . . . . . .  	L NEAR	05CB	CSEG	Global
SIN10  . . . . . . . . . . . . .  	L NEAR	05D4	CSEG
SIN20  . . . . . . . . . . . . .  	L NEAR	05E1	CSEG
SIN30  . . . . . . . . . . . . .  	L NEAR	05E4	CSEG
SIN31  . . . . . . . . . . . . .  	L NEAR	05EF	CSEG
SIN40  . . . . . . . . . . . . .  	L NEAR	0600	CSEG
SIN50  . . . . . . . . . . . . .  	L NEAR	0610	CSEG
SIN51  . . . . . . . . . . . . .  	L NEAR	061A	CSEG
SIN60  . . . . . . . . . . . . .  	L NEAR	062F	CSEG
SIN65  . . . . . . . . . . . . .  	L NEAR	0635	CSEG
SIN70  . . . . . . . . . . . . .  	L NEAR	063D	CSEG
SIS01  . . . . . . . . . . . . .  	L NEAR	08C6	CSEG
SIS05  . . . . . . . . . . . . .  	L NEAR	08D6	CSEG
SIS07  . . . . . . . . . . . . .  	L NEAR	08EB	CSEG
SIS10  . . . . . . . . . . . . .  	L NEAR	08ED	CSEG
SIXDIG . . . . . . . . . . . . .  	Number	0000	
SMALL  . . . . . . . . . . . . .  	Number	0000	
SPCDSK . . . . . . . . . . . . .  	Number	0000	
SPCNDS . . . . . . . . . . . . .  	Number	0000	
SQR  . . . . . . . . . . . . . .  	L NEAR	0CB6	CSEG	Global
STOULP . . . . . . . . . . . . .  	L NEAR	0894	CSEG
STREND . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
STRING . . . . . . . . . . . . .  	Number	0001	
STROUI . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STROUT . . . . . . . . . . . . .  	L NEAR	089E	CSEG	Global
STRSIZ . . . . . . . . . . . . .  	Number	0003	
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-15
                                                             

SUPRSH . . . . . . . . . . . . .  	Number	0001	
SWAPSW . . . . . . . . . . . . .  	Number	0001	

TAN  . . . . . . . . . . . . . .  	L NEAR	0666	CSEG	Global
TEK  . . . . . . . . . . . . . .  	Number	0000	
TEMP3  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
TIMSHR . . . . . . . . . . . . .  	Number	0000	
TMERR  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
TRAPER . . . . . . . . . . . . .  	L NEAR	07E1	CSEG
TRAPIT . . . . . . . . . . . . .  	L NEAR	07EA	CSEG
TRNCHR . . . . . . . . . . . . .  	Number	0000	
TRSER2 . . . . . . . . . . . . .  	Number	0000	
TRUANS . . . . . . . . . . . . .  	Number	0000	
TRUROM . . . . . . . . . . . . .  	Number	0001	
TSDISK . . . . . . . . . . . . .  	Number	0000	
TSLPT  . . . . . . . . . . . . .  	Number	0000	
TSTEVN . . . . . . . . . . . . .  	L NEAR	1FE3	CSEG
TSTFLG . . . . . . . . . . . . .  	L NEAR	0A73	CSEG

UFC10  . . . . . . . . . . . . .  	L NEAR	0A63	CSEG
UM10 . . . . . . . . . . . . . .  	L NEAR	0FE8	CSEG
UMULT  . . . . . . . . . . . . .  	L NEAR	0FDE	CSEG	Global

VALINT . . . . . . . . . . . . .  	L NEAR	1835	CSEG	Global
VALSNG . . . . . . . . . . . . .  	L NEAR	1068	CSEG	Global
VALTYP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
VCMP10 . . . . . . . . . . . . .  	L NEAR	0BB2	CSEG
VD10 . . . . . . . . . . . . . .  	L NEAR	1001	CSEG
VD15 . . . . . . . . . . . . . .  	L NEAR	1004	CSEG
VDFACS . . . . . . . . . . . . .  	L NEAR	0FF9	CSEG	Global
VIN05  . . . . . . . . . . . . .  	L NEAR	0BF4	CSEG
VIN10  . . . . . . . . . . . . .  	L NEAR	0BF9	CSEG
VINT . . . . . . . . . . . . . .  	L NEAR	0BEE	CSEG	Global
VM10 . . . . . . . . . . . . . .  	L NEAR	0B5F	CSEG
VMM10  . . . . . . . . . . . . .  	L NEAR	0B70	CSEG
VMOVAF . . . . . . . . . . . . .  	L NEAR	0FF2	CSEG	Global
VMOVE  . . . . . . . . . . . . .  	L NEAR	100D	CSEG	Global
VMOVFA . . . . . . . . . . . . .  	L NEAR	0FE9	CSEG	Global
VMOVFM . . . . . . . . . . . . .  	L NEAR	0FEC	CSEG	Global
VMOVMF . . . . . . . . . . . . .  	L NEAR	0FF5	CSEG	Global
VMVM1  . . . . . . . . . . . . .  	L NEAR	0B86	CSEG
VMVVFM . . . . . . . . . . . . .  	L NEAR	0FF8	CSEG
VN15 . . . . . . . . . . . . . .  	L NEAR	0B2D	CSEG
VN20 . . . . . . . . . . . . . .  	L NEAR	0B39	CSEG
VNEG . . . . . . . . . . . . . .  	L NEAR	0B1F	CSEG	Global
VPO17  . . . . . . . . . . . . .  	L NEAR	0BE5	CSEG
VPO20  . . . . . . . . . . . . .  	L NEAR	0BE6	CSEG
VPS10  . . . . . . . . . . . . .  	L NEAR	0BC0	CSEG
VPS20  . . . . . . . . . . . . .  	L NEAR	0BC4	CSEG
VS10 . . . . . . . . . . . . . .  	L NEAR	103F	CSEG
VSIGN  . . . . . . . . . . . . .  	L NEAR	1037	CSEG	Global

XCG10  . . . . . . . . . . . . .  	L NEAR	09AA	CSEG
XTNSYS . . . . . . . . . . . . .  	Number	0000	
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-16
                                                             

XTON . . . . . . . . . . . . . .  	L NEAR	0E19	CSEG
XTON10 . . . . . . . . . . . . .  	L NEAR	0E2E	CSEG
XTON20 . . . . . . . . . . . . .  	L NEAR	0E3B	CSEG
XTON30 . . . . . . . . . . . . .  	L NEAR	0E58	CSEG

Z80  . . . . . . . . . . . . . .  	Number	0001	
Z80MAC . . . . . . . . . . . . .  	Number	0001	
ZCMPBX . . . . . . . . . . . . .  	L NEAR	0A30	CSEG
ZCMPCK . . . . . . . . . . . . .  	L NEAR	0A17	CSEG
ZCMPRT . . . . . . . . . . . . .  	L NEAR	0A2F	CSEG
ZEREXP . . . . . . . . . . . . .  	L NEAR	0A7B	CSEG
ZERO . . . . . . . . . . . . . .  	L NEAR	08B4	CSEG	Global
ZERQUO . . . . . . . . . . . . .  	L NEAR	1548	CSEG

$AEXPS . . . . . . . . . . . . .  	L NEAR	11FC	CSEG
$ARG . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$ARGLO . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$ATAN  . . . . . . . . . . . . .  	L NEAR	0686	CSEG
$ATNC1 . . . . . . . . . . . . .  	L NEAR	0578	CSEG
$ATNC2 . . . . . . . . . . . . .  	L NEAR	0581	CSEG
$CATTY . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$CDS . . . . . . . . . . . . . .  	L NEAR	17D7	CSEG	Global
$CHKEL . . . . . . . . . . . . .  	L NEAR	1254	CSEG
$CHRGT . . . . . . . . . . . . .  	L NEAR	0E5B	CSEG
$CINC  . . . . . . . . . . . . .  	L NEAR	1800	CSEG
$CIND  . . . . . . . . . . . . .  	L NEAR	1800	CSEG
$CLROV . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$COMPM . . . . . . . . . . . . .  	L NEAR	0A80	CSEG
$CONI2 . . . . . . . . . . . . .  	L NEAR	0AEA	CSEG
$COS . . . . . . . . . . . . . .  	L NEAR	05B3	CSEG
$CSD . . . . . . . . . . . . . .  	L NEAR	17AA	CSEG	Global
$CSI . . . . . . . . . . . . . .  	L NEAR	17E5	CSEG	Global
$DADDH . . . . . . . . . . . . .  	L NEAR	08FF	CSEG
$DBUFF . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$DCMPA . . . . . . . . . . . . .  	L NEAR	0ACF	CSEG	Global
$DCMPM . . . . . . . . . . . . .  	L NEAR	0AD2	CSEG
$DDIV  . . . . . . . . . . . . .  	L NEAR	1483	CSEG
$DFACL . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$DHALF . . . . . . . . . . . . .  	L NEAR	0499	CSEG
$DINT  . . . . . . . . . . . . .  	L NEAR	1B65	CSEG
$DIV0M . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$DIV0S . . . . . . . . . . . . .  	L NEAR	0786	CSEG	Global
$DIV10 . . . . . . . . . . . . .  	L NEAR	0914	CSEG
$DP00  . . . . . . . . . . . . .  	L NEAR	0361	CSEG
$DP01  . . . . . . . . . . . . .  	L NEAR	0369	CSEG
$DP06  . . . . . . . . . . . . .  	L NEAR	0391	CSEG
$DP07  . . . . . . . . . . . . .  	L NEAR	0399	CSEG
$DP09  . . . . . . . . . . . . .  	L NEAR	03A9	CSEG
$DP16  . . . . . . . . . . . . .  	L NEAR	03E1	CSEG
$DPADR . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$DPM01 . . . . . . . . . . . . .  	L NEAR	0359	CSEG
$DROUND  . . . . . . . . . . . .  	L NEAR	1597	CSEG
$DZERO . . . . . . . . . . . . .  	L NEAR	08A7	CSEG	Global
$EXP . . . . . . . . . . . . . .  	L NEAR	1268	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-17
                                                             

$EXPCN . . . . . . . . . . . . .  	L NEAR	0546	CSEG	Global
$FAC . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FACLO . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FACM1 . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FADDD . . . . . . . . . . . . .  	L NEAR	12E3	CSEG
$FADDH . . . . . . . . . . . . .  	L NEAR	090B	CSEG
$FADDS . . . . . . . . . . . . .  	L NEAR	139F	CSEG	Global
$FBUFF . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FCERR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$FCI4  . . . . . . . . . . . . .  	L NEAR	0005	CSEG
$FCOMP . . . . . . . . . . . . .  	L NEAR	0A40	CSEG	Global
$FD  . . . . . . . . . . . . . .  	L NEAR	17C8	CSEG
$FDIVD . . . . . . . . . . . . .  	L NEAR	147D	CSEG
$FDIVS . . . . . . . . . . . . .  	L NEAR	15D6	CSEG	Global
$FI  . . . . . . . . . . . . . .  	L NEAR	17F1	CSEG	Global
$FIDIG . . . . . . . . . . . . .  	L NEAR	16B2	CSEG
$FIN . . . . . . . . . . . . . .  	L NEAR	0BFC	CSEG
$FINCH . . . . . . . . . . . . .  	L NEAR	04CB	CSEG
$FIND  . . . . . . . . . . . . .  	L NEAR	1776	CSEG
$FINDB . . . . . . . . . . . . .  	L NEAR	0C00	CSEG
$FINE  . . . . . . . . . . . . .  	L NEAR	0704	CSEG
$FINEX . . . . . . . . . . . . .  	L NEAR	172B	CSEG
$FINFC . . . . . . . . . . . . .  	L NEAR	1797	CSEG
$FINI  . . . . . . . . . . . . .  	L NEAR	178F	CSEG
$FINS  . . . . . . . . . . . . .  	L NEAR	1778	CSEG
$FLGOC . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$FLGOV . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FLT . . . . . . . . . . . . . .  	L NEAR	184E	CSEG	Global
$FMTAL . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FMTAX . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FMTCX . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FMULD . . . . . . . . . . . . .  	L NEAR	1873	CSEG
$FMULS . . . . . . . . . . . . .  	L NEAR	191D	CSEG	Global
$FODTB . . . . . . . . . . . . .  	L NEAR	04D5	CSEG
$FOFMT . . . . . . . . . . . . .  	L NEAR	07EB	CSEG
$FOITB . . . . . . . . . . . . .  	L NEAR	0524	CSEG
$FOSTB . . . . . . . . . . . . .  	L NEAR	051B	CSEG
$FOTAN . . . . . . . . . . . . .  	L NEAR	198D	CSEG
$FOTB  . . . . . . . . . . . . .  	L NEAR	0259	CSEG
$FOTCI . . . . . . . . . . . . .  	L NEAR	0000	CSEG	Global
$FOTCV . . . . . . . . . . . . .  	L NEAR	19C4	CSEG
$FOTED . . . . . . . . . . . . .  	L NEAR	19A5	CSEG
$FOTNV . . . . . . . . . . . . .  	L NEAR	1AC0	CSEG
$FOTZ  . . . . . . . . . . . . .  	L NEAR	0145	CSEG
$FOTZC . . . . . . . . . . . . .  	L NEAR	0155	CSEG
$FOTZS . . . . . . . . . . . . .  	L NEAR	00D4	CSEG
$FOUT  . . . . . . . . . . . . .  	L NEAR	1B3E	CSEG
$FOUT2 . . . . . . . . . . . . .  	L NEAR	1B4B	CSEG	Global
$FOUTH . . . . . . . . . . . . .  	L NEAR	0036	CSEG	Global
$FOUTO . . . . . . . . . . . . .  	L NEAR	002E	CSEG	Global
$FPWR  . . . . . . . . . . . . .  	L NEAR	0D29	CSEG	Global
$FS  . . . . . . . . . . . . . .  	L NEAR	1799	CSEG	Global
$FSUBD . . . . . . . . . . . . .  	L NEAR	12D7	CSEG	Global
$FSUBS . . . . . . . . . . . . .  	L NEAR	1393	CSEG	Global
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-18
                                                             

$FTDNT . . . . . . . . . . . . .  	L NEAR	1B70	CSEG
$GETYP . . . . . . . . . . . . .  	L NEAR	08EE	CSEG	Global
$IABS  . . . . . . . . . . . . .  	L NEAR	0B17	CSEG
$IN2PI . . . . . . . . . . . . .  	L NEAR	0592	CSEG
$INEG  . . . . . . . . . . . . .  	L NEAR	0B2A	CSEG
$INFMD . . . . . . . . . . . . .  	L NEAR	053A	CSEG
$INFPD . . . . . . . . . . . . .  	L NEAR	0532	CSEG
$INT . . . . . . . . . . . . . .  	L NEAR	1BD4	CSEG
$LG2E  . . . . . . . . . . . . .  	L NEAR	0542	CSEG
$LN2 . . . . . . . . . . . . . .  	L NEAR	04C7	CSEG
$LOG . . . . . . . . . . . . . .  	L NEAR	1C40	CSEG
$LOGP  . . . . . . . . . . . . .  	L NEAR	04A5	CSEG	Global
$LOGQ  . . . . . . . . . . . . .  	L NEAR	04B6	CSEG
$MLSP  . . . . . . . . . . . . .  	L NEAR	092D	CSEG
$MOVAC . . . . . . . . . . . . .  	L NEAR	09CF	CSEG
$MOVAF . . . . . . . . . . . . .  	L NEAR	09E7	CSEG
$MOVBF . . . . . . . . . . . . .  	L NEAR	09BB	CSEG
$MOVBS . . . . . . . . . . . . .  	L NEAR	09B3	CSEG
$MOVFA . . . . . . . . . . . . .  	L NEAR	09FA	CSEG	Global
$MOVFC . . . . . . . . . . . . .  	L NEAR	09D4	CSEG
$MOVFM . . . . . . . . . . . . .  	L NEAR	0BA1	CSEG	Global
$MOVFR . . . . . . . . . . . . .  	L NEAR	0A05	CSEG	Global
$MOVMF . . . . . . . . . . . . .  	L NEAR	0B88	CSEG	Global
$MOVRF . . . . . . . . . . . . .  	L NEAR	0A0E	CSEG	Global
$MUL10 . . . . . . . . . . . . .  	L NEAR	091E	CSEG
$NEG . . . . . . . . . . . . . .  	L NEAR	0B24	CSEG	Global
$NORMD . . . . . . . . . . . . .  	L NEAR	1C99	CSEG	Global
$NORMS . . . . . . . . . . . . .  	L NEAR	1CE4	CSEG	Global
$NUMB  . . . . . . . . . . . . .  	L NEAR	05A3	CSEG
$OHCNS . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$OVERR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$OVFLS . . . . . . . . . . . . .  	L NEAR	0775	CSEG
$OVMSG . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$POLY  . . . . . . . . . . . . .  	L NEAR	1D30	CSEG
$POLYX . . . . . . . . . . . . .  	L NEAR	1D17	CSEG
$POPA  . . . . . . . . . . . . .  	L NEAR	0BCC	CSEG	Global
$PUEXP . . . . . . . . . . . . .  	L NEAR	0860	CSEG
$PUF . . . . . . . . . . . . . .  	L NEAR	1D63	CSEG
$PUFE  . . . . . . . . . . . . .  	L NEAR	015E	CSEG
$PUFOT . . . . . . . . . . . . .  	L NEAR	1E7D	CSEG
$PUFXE . . . . . . . . . . . . .  	L NEAR	006C	CSEG
$PUI . . . . . . . . . . . . . .  	L NEAR	1EC4	CSEG
$PUIZ  . . . . . . . . . . . . .  	L NEAR	1EED	CSEG
$PUSHF . . . . . . . . . . . . .  	L NEAR	0BBD	CSEG
$QINT  . . . . . . . . . . . . .  	L NEAR	1C37	CSEG
$RDL . . . . . . . . . . . . . .  	L NEAR	0946	CSEG
$RND . . . . . . . . . . . . . .  	L NEAR	1F03	CSEG
$RND0  . . . . . . . . . . . . .  	L NEAR	05A0	CSEG
$RNDA  . . . . . . . . . . . . .  	L NEAR	059A	CSEG
$RNDC  . . . . . . . . . . . . .  	L NEAR	059D	CSEG
$RNDX  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$ROUND . . . . . . . . . . . . .  	L NEAR	1F8C	CSEG
$ROUNM . . . . . . . . . . . . .  	L NEAR	1FC9	CSEG
$ROUNS . . . . . . . . . . . . .  	L NEAR	1FC6	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 7/13/20 11:33:38

MATH86 8086 MATH PACK                                       Symbols-19
                                                             

$ROUNX . . . . . . . . . . . . .  	L NEAR	1FB4	CSEG
$RSUBM . . . . . . . . . . . . .  	L NEAR	0B01	CSEG
$S32KM . . . . . . . . . . . . .  	L NEAR	052E	CSEG
$SDIV  . . . . . . . . . . . . .  	L NEAR	15F7	CSEG
$SETDB . . . . . . . . . . . . .  	L NEAR	0B3E	CSEG
$SEXPS . . . . . . . . . . . . .  	L NEAR	11FF	CSEG
$SHALF . . . . . . . . . . . . .  	L NEAR	049D	CSEG
$SHDR  . . . . . . . . . . . . .  	L NEAR	0950	CSEG
$SHRA  . . . . . . . . . . . . .  	L NEAR	0961	CSEG
$SHRD  . . . . . . . . . . . . .  	L NEAR	1BAD	CSEG
$SHRM  . . . . . . . . . . . . .  	L NEAR	0953	CSEG
$SIGD  . . . . . . . . . . . . .  	L NEAR	1FFD	CSEG
$SIGNS . . . . . . . . . . . . .  	L NEAR	08BE	CSEG	Global
$SIN . . . . . . . . . . . . . .  	L NEAR	05CB	CSEG
$SINCN . . . . . . . . . . . . .  	L NEAR	0563	CSEG
$SNERR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$SQR . . . . . . . . . . . . . .  	L NEAR	0CB6	CSEG
$SQRH  . . . . . . . . . . . . .  	L NEAR	04A1	CSEG
$SRND  . . . . . . . . . . . . .  	L NEAR	167C	CSEG
$STPRN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$TAN . . . . . . . . . . . . . .  	L NEAR	0666	CSEG
$TMERR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$VABS  . . . . . . . . . . . . .  	L NEAR	0B0A	CSEG
$VADDH . . . . . . . . . . . . .  	L NEAR	08FA	CSEG
$VALNT . . . . . . . . . . . . .  	L NEAR	1835	CSEG
$VALTP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$VCMPM . . . . . . . . . . . . .  	L NEAR	0BAA	CSEG
$VCOMP . . . . . . . . . . . . .  	L NEAR	0A38	CSEG
$VINT  . . . . . . . . . . . . .  	L NEAR	0BEE	CSEG	Global
$VMOVM . . . . . . . . . . . . .  	L NEAR	0B65	CSEG
$VMVAM . . . . . . . . . . . . .  	L NEAR	0B57	CSEG
$VMVFM . . . . . . . . . . . . .  	L NEAR	0B93	CSEG
$VMVMF . . . . . . . . . . . . .  	L NEAR	0B76	CSEG
$VNEG  . . . . . . . . . . . . .  	L NEAR	0B1F	CSEG
$VPOPF . . . . . . . . . . . . .  	L NEAR	0BD4	CSEG
$VPSHF . . . . . . . . . . . . .  	L NEAR	0BB5	CSEG	Global
$XCGAF . . . . . . . . . . . . .  	L NEAR	09A0	CSEG
$Z1  . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$Z1LO  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$ZERO  . . . . . . . . . . . . .  	L NEAR	08B4	CSEG
$ZLO . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
?CSLAB . . . . . . . . . . . . .  	L NEAR	0050	CSEG


   6069 Source  Lines
   6071 Total   Lines
    999 Symbols

  17182 Bytes symbol space free

      0 Warning Errors
      0 Severe  Errors
