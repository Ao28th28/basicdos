Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-1
                                                            

                             C  	include	bios.inc 
                             C  	include	disk.inc	; Disk structures 
                             C  ; 
                             C  ; Media IDs 
                             C  ; 
 = 00FE                      C  MEDIA_160K	equ	0FEh 
 = 00FF                      C  MEDIA_320K	equ	0FFh 
 = 00FC                      C  MEDIA_180K	equ	0FCh 
 = 00FD                      C  MEDIA_360K	equ	0FDh 
 = 00F8                      C  MEDIA_HARD	equ	0F8h 
                             C   
                             C  ; 
                             C  ; The venerable BIOS Parameter Block. 
                             C  ; 
                             C  BPB		struc 
 0000  50 43 4A 53 2E 4F 52  C  BPB_OEM		db	"PCJS.ORG"	; 00h: OEM signature 
       47                    C  
 0008  ????                  C  BPB_SECBYTES	dw	?		; 08h: bytes per sector (eg,
				 0x200) 
 000A  ??                    C  BPB_CLUSSECS	db	?		; 0Ah: sectors per cluster (
				eg, 1) 
 000B  ????                  C  BPB_RESSECS	dw	?		; 0Bh: reserved sectors (befo
				re FAT) 
 000D  ??                    C  BPB_FATS	db	?		; 0Dh: FAT copies (eg, 2) 
 000E  ????                  C  BPB_DIRENTS	dw	?		; 0Eh: root directory entries
				 
 0010  ????                  C  BPB_DISKSECS	dw	?		; 10h: number of sectors on 
				disk 
 0012  ??                    C  BPB_MEDIA	db	?		; 12h: media ID; should match F
				AT ID 
 0013  ????                  C  BPB_FATSECS	dw	?		; 13h: sectors per FAT (eg, 1
				) 
 0015  ????                  C  BPB_TRACKSECS	dw	?		; 15h: sectors per track (e
				g, 8) 
 0017  ????                  C  BPB_DRIVEHEADS	dw	?		; 17h: number of heads (eg
				, 1) 
 0019  ????????              C  BPB_HIDDENSECS	dd	?		; 19h: number of hidden se
				ctors 
 001D  ????????              C  BPB_LARGESECS	dd	?		; 1Dh: if TOTALSECS is 0 (s
				ee DOS 3.31) 
                             C  ; 
                             C  ; BPB extensions 
                             C  ; 
 0021  ??                    C  BPB_DRIVE	db	?		; 21h: physical drive # 
 0022  ????                  C  BPB_LBAROOT	dw	?		; 22h: LBA of 1st root dir se
				ctor 
 0024  ????                  C  BPB_LBADATA	dw	?		; 24h: LBA of 1st data sector
				 
 0026                        C  BPB		ends 
                             C   
                             C  DIRENT		struc 
 0000  000B[                 C  DIR_NAME	db	11 dup (?)	; filename: 
            ??               C  
                         ]   C  
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-2
                                                            

                             C  
                             C  					; 1st byte = E5 -> free entry 
                             C  					;	   = 00 -> end of directory 
 000B  ??                    C  DIR_ATTR	db	?		; attribute bits (see below) 
 000C  000A[                 C  DIR_PAD		db	10 dup (?)	; reserved for expansion
				 
            ??               C  
                         ]   C  
                             C  
 0016  ????                  C  DIR_TIME	dw	?		; time of last write (see below)
				 
 0018  ????                  C  DIR_DATE	dw	?		; date of last write (see below)
				 
 001A  ????                  C  DIR_CLN		dw	?		; first cluster number of file 
 001C  ????                  C  DIR_SIZE_L	dw	?		; low 16 bits of file size 
 001E  ????                  C  DIR_SIZE_H	dw	?		; high 16 bits of file size 
 0020                        C  DIRENT		ends 
                             C   
 = 0020                      C  DIRENT_SIZE	EQU	(size DIRENT)	; Size of directo
				ry entry in bytes 
                             C  ; 
                             C  ;   Time:   Bits 0-4 = seconds/2, bits 5-10 = m
				inute, 11-15 = hour 
                             C  ;   Date:   Bits 0-4 = day, bits 5-8 = month, b
				its 9-15 = year-1980 
                             C  ; 
 = 0001                      C  ATTR_READ_ONLY	equ	00000001b	; write protect at
				tribute 
 = 0002                      C  ATTR_HIDDEN	equ	00000010b	; hidden file attribu
				te 
 = 0004                      C  ATTR_SYSTEM	equ	00000100b	; system file attribu
				te 
 = 0008                      C  ATTR_VOLUME_ID	equ	00001000b	; volume name attr
				ibute 
 = 0010                      C  ATTR_DIRECTORY	equ	00010000b	; directory attrib
				ute 
 = 0020                      C  ATTR_ARCHIVE	equ	00100000b	; backup attribute 
                             C   
                             C  	include	macros.inc 
 = 0008                      C  PCJS_MULTIPLIER	EQU	8 
                             C   
                             C  ASSERTEQ	macro	v1,v2 
                             C  		IFE	v1 EQ v2 
                             C  		IF1 
                             C  		%out	v1 NE v2 
                             C  		ENDIF 
                             C  		ENDIF 
                             C  		endm 
                             C   
                             C  ; 
                             C  ; Standard PC BIOS vectors (the first few are r
				eally just 8086 vectors) 
                             C  ; 
                             C  ; Page numbers are from the first IBM 5150 Tech
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-3
                                                            

				nical Reference Manual (1981) 
                             C  ; 
 = 0000                      C  INT_DIV		EQU	00h	; #DE (divide error) 
 = 0001                      C  INT_STEP	EQU	01h	; #DB (debug aka single-step) 
 = 0002                      C  INT_NMI		EQU	02h	; NMI 
 = 0003                      C  INT_BP		EQU	03h	; #BP (breakpoint) 
 = 0004                      C  INT_OV		EQU	04h	; #OF (overflow) 
 = 0005                      C  INT_PRTSC	EQU	05h	; PRINT_SCREEN (p. A-79) 
 = 0010                      C  INT_VIDEO	EQU	10h	; VIDEO_IO (p. A-43) 
 = 0011                      C  INT_EQUIP	EQU	11h	; EQUIPMENT_DETERMINATION (p.
				 A-67) 
 = 0012                      C  INT_MEMORY	EQU	12h	; MEMORY_SIZE_DETERMINE (p. 
				A-67) 
 = 0013                      C  INT_DISK	EQU	13h	; DISKETTE_IO (p. A-32) 
 = 0014                      C  INT_COM		EQU	14h	; RS232_IO (p. A-20) 
 = 0015                      C  INT_CASSETTE	EQU	15h	; CASSETTE_IO (p. A-68) 
 = 0016                      C  INT_KBD		EQU	16h	; KEYBOARD_IO (p. A-23) 
 = 0017                      C  INT_LPT		EQU	17h	; PRINTER_IO (p. A-42) 
 = 0018                      C  INT_BASIC	EQU	18h	; 
 = 0019                      C  INT_REBOOT	EQU	19h	; BOOT_STRAP (p. A-20) 
 = 001A                      C  INT_TIME	EQU	1Ah	; TIME_OF_DAY (p. A-77) 
 = 001B                      C  INT_BREAK	EQU	1Bh	; CTRL_BREAK 
 = 001C                      C  INT_TICK	EQU	1Ch	; TIMER TICK 
 = 001D                      C  INT_VPT		EQU	1Dh	; VIDEO PARAMETER TABLE 
 = 001E                      C  INT_DPT		EQU	1Eh	; DISKETTE PARAMETER TABLE 
 = 001F                      C  INT_VGCDATA	EQU	1Fh	; VIDEO GRAPHICS CHARACTER 
				DATA 
                             C   
                             C  ; 
                             C  ; INT_VIDEO functions 
                             C  ; 
 = 000E                      C  VIDEO_TTYOUT	EQU	0Eh	; AL = char, BH = display 
				page 
                             C   
                             C  ; 
                             C  ; INT_DISK functions 
                             C  ; 
 = 0002                      C  DISK_READ	EQU	02h	; 
 = 0008                      C  DISK_GETPARMS	EQU	08h	; DL = 80h; returns DL = 
				# drives (if carry clear) 
                             C   
                             C  ; 
                             C  ; INT_KBD functions 
                             C  ; 
 = 0000                      C  KBD_READ	EQU	00h	; returns char code in AL, sca
				n code in AH 
 = 0001                      C  KBD_CHECK	EQU	01h	; returns ZF set if no key 
                             C   
                             C  ; 
                             C  ; INT_TIME functions 
                             C  ; 
 = 0000                      C  TIME_GETTICKS	EQU	00h	; returns CX:DX, and AL !
				= 0 if wrapped 
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-4
                                                            

                             C   
                             C  ; 
                             C  ; Diskette Parameter Table (11 bytes pointed by
				 INT_DSKPARMS (1Eh)) 
                             C  ; 
                             C  ; Early utilities (like SPEEDUP; see https://ww
				w.pcjs.org/blog/2017/07/21/) 
                             C  ; changed: 
                             C  ; 
                             C  ;	DPT_SPECIFY1:	from CFh to DFh (step rate from
				 8ms to 6ms) 
                             C  ;	DPT_HEADSETTLE:	from 19h to 00h (head settle 
				from 25ms to 0ms) 
                             C  ; 
                             C  DPT		STRUC 
 0000  ??                    C  DP_SPECIFY1	DB	?	; CFh: SRT=C, HD UNLOAD=0F (1S
				T SPECIFY BYTE) 
 0001  ??                    C  DP_SPECIFY2	DB	?	; 02h: HD LOAD=1, MODE=DMA (2N
				D SPECIFY BYTE) 
 0002  ??                    C  DP_MOTOROFF	DB	?	; 25h: WAIT AFTER OPN TIL MOTO
				R OFF 
 0003  ??                    C  DP_BPS		DB	?	; 02h: 512 BYTES/SECTOR 
 0004  ??                    C  DP_SPT		DB	?	; 08h: EOT (LAST SECTOR ON TRACK) 
 0005  ??                    C  DP_GAP		DB	?	; 2Ah: GAP LENGTH 
 0006  ??                    C  DP_DTL		DB	?	; FFh: DTL 
 0007  ??                    C  DP_GAP3		DB	?	; 50h: GAP LENGTH FOR FORMAT 
 0008  ??                    C  DP_FILL		DB	?	; F6h: FILL BYTE FOR FORMAT 
 0009  ??                    C  DP_HEADSETTLE	DB	?	; 19h: HEAD SETTLE TIME (MS)
				 
 000A  ??                    C  DP_MOTORON	DB	?	; 04h: MOTOR-ON START TIME (1/8
				 SECS) 
 000B                        C  DPT		ENDS 
                             C   
                             C  ; 
                             C  ; ROM BIOS DATA AREA 
                             C  ; 
                             C  ; We assume that all 256 bytes from 40:00h to 4
				0:FFh are used or reserved. 
                             C  ; 
                             C  ; I've also made the strategic decision to NOT 
				use segment value 40h to access 
                             C  ; ROM BIOS data, as 00h is more useful. 
                             C  ; 
 0000                        C  BIOS_DATA	SEGMENT AT 00h 
 0000  0100[                 C  IVT		DD    256 DUP(?); 
            ????????         C  
                         ]   C  
                             C  
 0400  0004[                 C  RS232_BASE	DW	4 DUP(?); 400h: ADDRESSES OF RS23
				2 ADAPTERS 
            ????             C  
                         ]   C  
                             C  
 0408  0004[                 C  PRINTER_BASE	DW	4 DUP(?); 408h: ADDRESSES OF PR
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-5
                                                            

				INTERS 
            ????             C  
                         ]   C  
                             C  
 0410  ????                  C  EQUIP_FLAG	DW	?	; 400h: INSTALLED HARDWARE 
                             C  ; 
                             C  ; EQUIP_FLAG bits 
                             C  ; 
 = C000                      C  EQ_NUM_PRINT	EQU	0C000h	; NUMBER OF PRINTERS AT
				TACHED 
 = 1000                      C  EQ_GAME_CTRL	EQU	1000h	; GAME I/O ATTACHED 
 = 0E00                      C  EQ_NUM_RS232	EQU	0E00h	; NUMBER OF RS232 CARDS 
				ATTACHED 
 = 00C0                      C  EQ_NUM_DRIVES	EQU	00C0h	; NUMBER OF DISKETTE DR
				IVES (00=1, 01=2, 10=3, 
                             C  				;	11=4) ONLY IF IPL_DRIVE SET 
 = 0030                      C  EQ_VIDEO_MODE	EQU	0030h	; INITIAL VIDEO MODE (0
				0=UNUSED, 01=40X25 COLOR, 
                             C  				;	10=80X25 COLOR, 11=80X25 MONO) 
 = 00C0                      C  EQ_RAM_SIZE	EQU	00C0h	; PLANAR RAM SIZE (00=16K
				,01=32K,10=48K,11=64K) 
 = 0001                      C  EQ_IPL_DRIVE	EQU	0001h	; IPL (Initial Program L
				oad) FROM DISKETTE (ie, 
                             C  				;	diskette drives exist) 
                             C   
 0412  ??                    C  MFG_TEST	DB	?	; 402h: INITIALIZATION FLAG 
 0413  ????                  C  MEMORY_SIZE	DW	?	; 403h: MEMORY SIZE IN K BYTES
				 
 0415  ????                  C  IO_RAM_SIZE	DW	?	; 405h: MEMORY IN I/O CHANNEL 
 0417  ??                    C  KB_FLAG		DB	?	; 407h: FIRST BYTE OF KEYBOARD ST
				ATUS 
                             C  ; 
                             C  ; KB_FLAG bits 
                             C  ; 
 = 0080                      C  INS_STATE	EQU	80h	; INSERT STATE IS ACTIVE 
 = 0040                      C  CAPS_STATE	EQU	40h	; CAPS LOCK STATE HAS BEEN T
				OGGLED 
 = 0020                      C  NUM_STATE	EQU	20h	; NUM LOCK STATE HAS BEEN TOG
				GLED 
 = 0010                      C  SCROLL_STATE	EQU	10h	; SCROLL LOCK STATE HAS BE
				EN TOGGLED 
 = 0008                      C  ALT_SHIFT	EQU	08h	; ALTERNATE SHIFT KEY DEPRESS
				ED 
 = 0004                      C  CTL_SHIFT	EQU	04h	; CONTROL SHIFT KEY DEPRESSED
				 
 = 0002                      C  LEFT_SHIFT	EQU	02h	; LEFT SHIFT KEY DEPRESSED 
 = 0001                      C  RIGHT_SHIFT	EQU	01h	; RIGHT SHIFT KEY DEPRESSED
				 
                             C   
 0418  ??                    C  KB_FLAG_1	DB	?	; 418h: SECOND BYTE OF KEYBOARD 
				STATUS 
 0419  ??                    C  ALT_INPUT	DB	?	; 419h: STORAGE FOR ALTERNATE KE
				YPAD ENTRY 
 041A  ????                  C  BUFFER_HEAD	DW	?	; 41Ah: POINTER TO HEAD OF KEY
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-6
                                                            

				BOARD BUFFER 
 041C  ????                  C  BUFFER_TAIL	DW	?	; 41Ch: POINTER TO TAIL OF KEY
				BOARD BUFFER 
 041E  0010[                 C  KB_BUFFER	DW     16 DUP(?); 41Eh: ROOM FOR 15 E
				NTRIES 
            ????             C  
                         ]   C  
                             C  
                             C   
 043E  ??                    C  SEEK_STATUS	DB	?	; 43Eh: DRIVE RECALIBRATION ST
				ATUS 
                             C                          	;	BIT 3-0 = DRIVE 3-0 
				NEEDS RECAL BEFORE 
                             C                          	;	NEXT SEEK IF BIT IS 
				= 0 
 = 0080                      C  INT_FLAG	EQU	80h	;	INTERRUPT OCCURRENCE FLAG 
 043F  ??                    C  MOTOR_STATUS	DB	?	; 43Fh: MOTOR STATUS 
                             C  				;	BIT 3-0 = DRIVE 3-0 IS CURRENTLY RUNNING 
                             C  				;	BIT 7 = CURRENT OPERATION IS A WRITE, REQ
				UIRES DELAY 
 0440  ??                    C  MOTOR_COUNT	DB	?	; 440h: TIME OUT COUNTER FOR D
				RIVE TURN OFF 
                             C                          	;	37 = TWO SECONDS OF 
				COUNTS FOR MOTOR TURN OFF 
 0441  ??                    C  DISKETTE_STATUS	DB	?	; 441h: SINGLE BYTE OF RET
				URN CODE INFO FOR STATUS 
                             C  ; 
                             C  ; DISKETTE_STATUS bits 
                             C  ; 
 = 0080                      C  TIME_OUT	EQU	80h	; ATTACHMENT FAILED TO RESPOND
				 
 = 0040                      C  BAD_SEEK	EQU	40h	; SEEK OPERATION FAILED 
 = 0020                      C  BAD_NEC		EQU	20h	; NEC CONTROLLER HAS FAILED 
 = 0010                      C  BAD_CRC		EQU	10h	; BAD CRC ON DISKETTE READ 
 = 0009                      C  DMA_BOUNDARY	EQU	09h	; ATTEMPT TO DMA ACROSS 64
				K BOUNDARY 
 = 0008                      C  BAD_DMA		EQU	08h	; DMA OVERRUN ON OPERATION 
 = 0004                      C  RECORD_NOT_FND	EQU	04h	; REQUESTED SECTOR NOT F
				OUND 
 = 0003                      C  WRITE_PROTECT	EQU	03h	; WRITE ATTEMPTED ON WRIT
				E PROT DISK 
 = 0002                      C  BAD_ADDR_MARK	EQU	02h	; ADDRESS MARK NOT FOUND 
 = 0001                      C  BAD_CMD		EQU	01h	; BAD COMMAND PASSED TO DISKET
				TE I/O 
                             C   
 0442  0007[                 C  NEC_STATUS	DB	7 DUP(?); 442h: STATUS BYTES FROM
				 NEC 
            ??               C  
                         ]   C  
                             C  
                             C  ; 
                             C  ; VIDEO DISPLAY DATA AREA 
                             C  ; 
 0449  ??                    C  CRT_MODE	DB	?	; 449h: CURRENT CRT MODE 
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-7
                                                            

 044A  ????                  C  CRT_COLS	DW	?	; 44Ah: NUMBER OF COLUMNS ON SCRE
				EN 
 044C  ????                  C  CRT_LEN		DW	?	; 44Ch: LENGTH OF REGEN IN BYTES 
 044E  ????                  C  CRT_START	DW	?	; 44Eh: STARTING ADDRESS IN REGE
				N BUFFER 
 0450  0008[                 C  CURSOR_POSN	DW	8 DUP(?); 450h: CURSOR FOR EACH 
				OF UP TO 8 PAGES 
            ????             C  
                         ]   C  
                             C  
 0460  ????                  C  CURSOR_MODE	DW	?	; 460h: CURRENT CURSOR MODE SE
				TTING 
 0462  ??                    C  ACTIVE_PAGE	DB	?	; 462h: CURRENT PAGE BEING DIS
				PLAYED 
 0463  ????                  C  ADDR_6845	DW	?	; 463h: BASE ADDRESS FOR ACTIVE 
				DISPLAY CARD 
 0465  ??                    C  CRT_MODE_SET	DB	?	; 465h: CURRENT SETTING OF TH
				E 3X8 REGISTER 
 0466  ??                    C  CRT_PALLETTE	DB	?	; 466h: CURRENT PALLETTE SETT
				ING COLOR CARD 
                             C  ; 
                             C  ; CASSETTE DATA AREA 
                             C  ; 
 0467  ????                  C  EDGE_CNT	DW	?	; 467h: PC: TIME COUNT AT DATA ED
				GE (word) 
 0469  ????                  C  CRC_REG		DW	?	; 469h: PC: CRC REGISTER (word) 
 046B  ??                    C  LAST_VAL	DB	?	; 46Bh: PC: LAST INPUT VALUE (byt
				e) 
                             C  ; 
                             C  ; TIMER DATA AREA 
                             C  ; 
 046C  ????                  C  TIMER_LOW	DW	?	; 46Ch: LOW WORD OF TIMER COUNT 
 046E  ????                  C  TIMER_HIGH	DW	?	; 46Eh: HIGH WORD OF TIMER COUN
				T 
 0470  ??                    C  TIMER_OFL	DB	?	; 470h: TIMER HAS ROLLED OVER SI
				NCE LAST READ 
                             C  ; 
                             C  ; SYSTEM DATA AREA 
                             C  ; 
 0471  ??                    C  BIOS_BREAK	DB	?	; 471h: BIT 7 = 1 IF BREAK KEY 
				HAS BEEN DEPRESSED 
                             C  ; 
                             C  ; RESET_FLAG is the traditional end of the RBDA
				, as originally defined by the IBM PC 
                             C  ; 
 0472  ????                  C  RESET_FLAG	DW	?	; 472h: SET TO 0x1234 IF KEYBOA
				RD RESET UNDERWAY 
                             C   
 0474  008C[                 C  		DB    	8Ch DUP(?) 
            ??               C  
                         ]   C  
                             C  
                             C  ; 
                             C  ; Define BASIC-DOS low memory usage, starting a
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-8
                                                            

				t offset 500h. 
                             C  ; 
                             C  ; Unfortunately, there's a byte at 500h (STATUS
				_BYTE) used by the ROM BIOS 
                             C  ; PRINT_SCREEN function, and apparently the ROM
				 BASIC can use bytes from 510h 
                             C  ; through 51Dh.  There was also a DOS conventio
				n for using the byte at 504h 
                             C  ; to indicate whether the diskette drive in a s
				ingle-drive system was operating 
                             C  ; as drive A (00h) or drive B (01h). 
                             C  ; 
                             C  ; Some DOS boot sectors would read the first di
				rectory sector into 500h, 
                             C  ; which would result in the starting clusters o
				f IO.SYS and MSDOS.SYS residing 
                             C  ; in 51Ah and 53Ah, respectively.  Other boot s
				ectors would create an 11-byte 
                             C  ; copy of the BIOS Diskette Parameters Table at
				 522h.  We do the latter only. 
                             C  ; 
 0500  0004[                 C  		db	4 dup (?)	; 500h: reserved 
            ??               C  
                         ]   C  
                             C  
 0504  ??                    C  LOGICAL_DRIVE	db	?		; 504h: (00h for A: or 01h 
				for B:) 
 0505  001D[                 C  		db	29 dup (?)	; reserved 
            ??               C  
                         ]   C  
                             C  
 0522  ??                    C  DPT_ACTIVE	DPT	<>		; 522h: active DPT 
 0523  ??                    C  
 0524  ??                    C  
 0525  ??                    C  
 0526  ??                    C  
 0527  ??                    C  
 0528  ??                    C  
 0529  ??                    C  
 052A  ??                    C  
 052B  ??                    C  
 052C  ??                    C  
                             C  
                             C  ; 
                             C  ; We're going to move the boot sector from BOOT
				_SECTOR_HI to BOOT_SECTOR_LO, 
                             C  ; which overlaps where we'll maintain BPB_ACTIV
				E. 
                             C  ; 
 = 7C00                      C  BOOT_SECTOR_HI	equ	7C00h 
 = 052D                      C  BOOT_SECTOR_LO	equ	052Dh 
 052D  0003[                 C  BOOT_SECTOR	db	3 dup (?)	; 52Dh 
            ??               C  
                         ]   C  
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-9
                                                            

                             C  
 0530  50 43 4A 53 2E 4F 52  C  BPB_ACTIVE	BPB	<>		; 530h: active BPB 
       47                    C  
 0538  ????                  C  
 053A  ??                    C  
 053B  ????                  C  
 053D  ??                    C  
 053E  ????                  C  
 0540  ????                  C  
 0542  ??                    C  
 0543  ????                  C  
 0545  ????                  C  
 0547  ????                  C  
 0549  ????????              C  
 054D  ????????              C  
 0551  ??                    C  
 0552  ????                  C  
 0554  ????                  C  
                             C  
 0556  0200[                 C  FAT_SECTOR	db	512 dup (?)	; 556h 
            ??               C  
                         ]   C  
                             C  
 0756  0200[                 C  DIR_SECTOR	db	512 dup (?)	; 756h 
            ??               C  
                         ]   C  
                             C  
 0956  EEEE                  C  		dw	0EEEEh		; 956h (random marker) 
 0958  0094[                 C  		dw	148 dup (?)	; 958h 
            ????             C  
                         ]   C  
                             C  
 = 0A80                      C  BIOS_STACK	equ	$		; A80h 
 = 0A80                      C  BIOS_DATA_END	equ	0A80h		; A80h (must be on a p
				aragraph boundary) 
                             C   
 0A80                        C  BIOS_DATA	ENDS 
                                 
                                 
 0000                           CODE    segment 
                                 
 052D                           	org	BOOT_SECTOR_LO 
                                        ASSUME	CS:CODE, DS:BIOS_DATA, ES:BIOS_D
				ATA, SS:NOTHING 
                                 
 052D  FC                       	cld 
 052E  EB 26                    	jmp	short move 
                                 
 0530  50 43 4A 53 2E 4F 52     mybpb:	BPB	<,512,1,1,2,64,320,MEDIA_160K,1,8,1,
				0,0,0,3,7> 
       47                       
 0538  0200                     
 053A  01                       
 053B  0001                     
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-10
                                                            

 053D  02                       
 053E  0040                     
 0540  0140                     
 0542  FE                       
 0543  0001                     
 0545  0008                     
 0547  0001                     
 0549  00 00 00 00              
 054D  00 00 00 00              
 0551  00                       
 0552  0003                     
 0554  0007                     
                                
                                 
                                ; 
                                ; We assume DS and ES are zero on entry; the st
				ack is apparently at 30:100h. 
                                ; 
 0556  BF 0522 R                move:	mov	di,offset DPT_ACTIVE	; ES:DI -> DPT_A
				CTIVE 
 0559  06                       	push	es 
 055A  57                       	push	di 
 055B  1E                       	push	ds 
 055C  C5 36 0078               	lds	si,ds:[INT_DPT*4]	; DS:SI -> original tabl
				e (in ROM) 
                                	ASSUME	DS:NOTHING 
 0560  B9 000B                  	mov	cx,size DPT 
 0563  F3/ A4                   	rep	movsb 
 0565  1F                       	pop	ds 
                                	ASSUME	DS:BIOS_DATA 
 0566  C6 06 0522 R DF          	mov	[DPT_ACTIVE].DP_SPECIFY1,0DFh	; change ste
				p rate to 6ms 
 056B  C6 06 052B R 00          	mov	[DPT_ACTIVE].DP_HEADSETTLE,0	; change head
				 settle time to 0ms 
 0570  8F 06 0078               	pop	ds:[INT_DPT*4] 
 0574  8F 06 007A               	pop	ds:[INT_DPT*4+2]	; update INT_DPT vector 
 0578  BE 7C00                  	mov	si,BOOT_SECTOR_HI	; now move boot sector d
				own 
 057B  B9 0200                  	mov	cx,512 
                                ;	mov	di,offset BOOT_SECTOR	; BOOT_SECTOR now f
				ollows DPT_ACTIVE 
 057E  F3/ A4                   	rep	movsb 
 0580  B8 00A8                  	mov	ax,BIOS_DATA_END SHR 4 
 0583  50                       	push	ax 
 0584  2B C0                    	sub	ax,ax 
 0586  50                       	push	ax 
 0587  B8 058C R                	mov	ax,offset boot 
 058A  FF E0                    	jmp	ax 
                                 
 058C                           boot	proc	far 
 058C  BE 06CE R                	mov	si,offset product 
 058F  E8 065D R                	call	print 
 0592  80 3E 0542 R F8          	cmp	[mybpb].BPB_MEDIA,MEDIA_HARD 
 0597  74 1A                    	je	load			; we're a hard disk, so just boot 
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-11
                                                            

 0599  B4 08                    	mov	ah,DISK_GETPARMS	; get hard drive paramete
				rs 
 059B  B2 80                    	mov	dl,80h 
 059D  CD 13                    	int	INT_DISK		; 
 059F  72 12                    	jc	load			; failed (could be an original PC) 
 05A1  84 D2                    	test	dl,dl			; any hard drives? 
 05A3  74 0E                    	jz	load			; no 
 05A5  BE 06FA R                	mov	si,offset prompt 
 05A8  E8 065D R                	call	print 
 05AB  B8 0010                  	mov	ax,2 * PCJS_MULTIPLIER	; AX = 2 seconds 
 05AE  E8 0691 R                	call	waitsec			; wait for key 
 05B1  E3 30                    	jcxz	hdboot			; jump if no key pressed 
 05B3  BE 0530 R                load:	mov	si,offset mybpb 
 05B6  BB 071E R                	mov	bx,offset BIO_FILE	; DS:BX -> file name 
 05B9  BD 0A80                  	mov	bp,BIOS_DATA_END	; BP -> target address 
 05BC  8B 54 22                 	mov	dx,[si].BPB_LBAROOT	; DX = root dir LBA 
 05BF  8B C2                    dir:	mov	ax,dx			; AX = LBA 
 05C1  B1 01                    	mov	cl,1 
 05C3  BF 0756 R                	mov	di,offset DIR_SECTOR 
 05C6  E8 067D R                	call	read_sectors		; return dir sector (ES:DI)
				 
 05C9  72 0D                    	jc	err 
 05CB  E8 0610 R                find:	call	find_dirent		; return matching DIREN
				T (DS:BX) 
 05CE  72 08                    	jc	err			; end of directory entries 
 05D0  74 21                    	jz	read			; match! 
 05D2  42                       	inc	dx			; DX = next dir LBA 
 05D3  3B 54 24                 	cmp	dx,[si].BPB_LBADATA	; exhausted root dir? 
 05D6  72 E7                    	jb	dir			; not yet 
 05D8  BE 06DF R                err:	mov	si,offset errmsg 
 05DB  E8 065D R                	call	print 
 05DE  E8 06B2 R                	call	wait 
 05E1  CD 19                    	int	INT_REBOOT 
                                ; 
                                ; There's a hard disk and no response, so boot 
				from hard disk instead. 
                                ; 
 05E3  B8 0201                  hdboot:	mov	ax,0201h		; AH = 02h (READ), AL = 1
				 sector 
 05E6  41                       	inc	cx			; CH = CYL 0, CL = SEC 1 
 05E7  BA 0080                  	mov	dx,0080h		; DH = HEAD 0, DL = DRIVE 80h 
 05EA  BB 7C00                  	mov	bx,BOOT_SECTOR_HI	; ES:BX -> BOOT_SECTOR_H
				I 
 05ED  CD 13                    	int	13h			; read it 
 05EF  72 E7                    	jc	err 
 05F1  FF E3                    	jmp	bx			; jump to the hard disk boot sector 
                                ; 
                                ; We found the DIRENT (at BX) of BIO_FILE, so l
				oad it and launch it. 
                                ; 
 05F3  8B FD                    read:	mov	di,bp 
 05F5  8B 47 1A                 next:	mov	ax,[bx].DIR_CLN		; AX = cluster numbe
				r 
 05F8  E8 0663 R                	call	read_cluster		; read cluster into ES:DI 
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-12
                                                            

 05FB  72 DB                    	jc	err 
 05FD  F7 64 08                 	mul	[si].BPB_SECBYTES	; AX = number of sectors
				 read 
 0600  03 F8                    	add	di,ax			; adjust next read address 
 0602  29 47 1C                 	sub	[bx].DIR_SIZE_L,ax	; reduce file size 
 0605  76 05                    	jbe	done			; size exhausted 
 0607  FF 47 1A                 	inc	[bx].DIR_CLN		; otherwise, read next clust
				er 
 060A  EB E9                    	jmp	next			; (the clusters must be contiguous)
				 
 060C  BA 05CB R                done:	mov	dx,offset find		; DX = entry point fo
				r loading next file 
 060F  CB                       	ret 
                                boot	endp 
                                 
                                ;;;;;;;; 
                                ; 
                                ; Find DIRENT in sector at ES:DI using filename
				 at DS:BX 
                                ; 
                                ; Modifies: AX, BX, CX 
                                ; 
                                ; Returns: zero flag set if match (see BX), car
				ry set if end of directory 
                                ; 
 0610                           find_dirent proc near 
 0610  56                       	push	si 
 0611  57                       	push	di 
 0612  8B 44 08                 	mov	ax,[si].BPB_SECBYTES 
 0615  03 C7                    	add	ax,di		; AX -> end of sector data 
 0617  80 3D 00                 f1:	cmp	byte ptr [di],0 
 061A  F9                       	stc			; more future-proofing: 
 061B  74 17                    	je	f9		; 0 indicates end of allocated entries 
 061D  8B F3                    	mov	si,bx 
 061F  B9 000B                  	mov	cx,11 
 0622  F3/ A6                   	repe	cmpsb 
 0624  74 0B                    	jz	f8 
 0626  03 F9                    	add	di,cx 
 0628  83 C7 15                 	add	di,size DIRENT - 11 
 062B  3B F8                    	cmp	di,ax 
 062D  72 E8                    	jb	f1 
 062F  EB 03                    	jmp	short f9 
 0631  8D 5D F5                 f8:	lea	bx,[di-11] 
 0634  5F                       f9:	pop	di 
 0635  5E                       	pop	si 
 0636  C3                       	ret 
                                find_dirent endp 
                                 
                                ;;;;;;;; 
                                ; 
                                ; Get CHS from LBA in AX, using BPB in DS:SI 
                                ; 
                                ; Modifies: AX, CX, DX 
                                ; 
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-13
                                                            

                                ; Returns: CH = cylinder, CL = sector, DH = hea
				d, DL = drive 
                                ; 
 0637                           get_chs	proc	near 
                                ; 
                                ; If our BPB had a pre-computed BPB_CYLSECS, we
				 could avoid the CX calculation. 
                                ; 
 0637  91                       	xchg	cx,ax 
 0638  8A 44 15                 	mov	al,byte ptr [si].BPB_TRACKSECS 
 063B  F6 64 17                 	mul	byte ptr [si].BPB_DRIVEHEADS 
 063E  91                       	xchg	cx,ax		; CX = sectors per cylinder 
 063F  2B D2                    	sub	dx,dx		; DX:AX is LBA 
 0641  F7 F1                    	div	cx		; AX = cylinder, DX = remaining sector
				s 
 0643  86 C4                    	xchg	al,ah		; AH = cylinder, AL = cylinder bit
				s 8-9 
 0645  D0 C8                    	ror	al,1		; future-proofing: saving cylinder b
				its 8-9 
 0647  D0 C8                    	ror	al,1 
 0649  91                       	xchg	cx,ax		; CH = cylinder 
 064A  92                       	xchg	ax,dx		; AX = remaining sectors from last
				 divide 
 064B  F6 74 15                 	div	byte ptr [si].BPB_TRACKSECS 
 064E  8A F0                    	mov	dh,al		; DH = head (quotient of last divid
				e) 
 0650  0A CC                    	or	cl,ah		; CL = sector (remainder of last div
				ide) 
 0652  41                       	inc	cx		; LBA are zero-based, sector IDs are 1
				-based 
 0653  8A 54 21                 	mov	dl,[si].BPB_DRIVE 
 0656  C3                       	ret 
                                get_chs	endp 
                                 
                                ;;;;;;;; 
                                ; 
                                ; Print the null-terminated string at DS:SI 
                                ; 
                                ; Modifies: AX, BX 
                                ; 
                                ; Returns: Nothing 
                                ; 
 0657                           printl	proc	near 
 0657  B4 0E                    	mov	ah,VIDEO_TTYOUT 
 0659  B7 00                    	mov	bh,0 
 065B  CD 10                    	int	INT_VIDEO 
 065D                           print	label	near 
 065D  AC                       	lodsb 
 065E  84 C0                    	test	al,al 
 0660  75 F5                    	jnz	printl 
 0662  C3                       	ret 
                                printl	endp 
                                 
                                ;;;;;;;; 
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-14
                                                            

                                ; 
                                ; Read cluster AX into memory at ES:DI 
                                ; 
                                ; Modifies: AX 
                                ; 
                                ; Returns: carry flag set on error (see AH), cl
				ear otherwise (AX sectors read) 
                                ; 
 0663                           read_cluster proc near 
 0663  51                       	push	cx 
 0664  52                       	push	dx 
 0665  2D 0002                  	sub	ax,2 
 0668  72 10                    	jb	rc9 
 066A  2B C9                    	sub	cx,cx 
 066C  8A 4C 0A                 	mov	cl,[si].BPB_CLUSSECS 
 066F  F7 E1                    	mul	cx 
 0671  03 44 24                 	add	ax,[si].BPB_LBADATA 
 0674  E8 067D R                	call	read_sectors 
 0677  72 01                    	jc	rc9 
                                ; 
                                ; The ROM claims that, on success, AL will (nor
				mally) contain the number of 
                                ; sectors actually read, but I'm not seeing tha
				t, so I'll just copy CL into AL. 
                                ; 
 0679  91                       	xchg	ax,cx 
 067A  5A                       rc9:	pop	dx 
 067B  59                       	pop	cx 
 067C  C3                       	ret 
                                read_cluster endp 
                                 
                                ;;;;;;;; 
                                ; 
                                ; Read CL sectors into ES:DI using LBA in AX an
				d BPB in DS:SI 
                                ; 
                                ; Modifies: AX 
                                ; 
                                ; Returns: carry clear if successful, set if er
				ror (see AH for reason) 
                                ; 
 067D                           read_sectors proc near 
 067D  53                       	push	bx 
 067E  51                       	push	cx 
 067F  52                       	push	dx 
 0680  8A D9                    	mov	bl,cl 
 0682  E8 0637 R                	call	get_chs 
 0685  8A C3                    	mov	al,bl 
 0687  B4 02                    	mov	ah,DISK_READ 
 0689  8B DF                    	mov	bx,di 
 068B  CD 13                    	int	INT_DISK 
 068D  5A                       	pop	dx 
 068E  59                       	pop	cx 
 068F  5B                       	pop	bx 
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-15
                                                            

 0690  C3                       	ret 
                                read_sectors endp 
                                 
                                ;;;;;;;; 
                                ; 
                                ; Wait the number of seconds in AX, or until a 
				key is pressed. 
                                ; 
                                ; Modifies: AX, CX, DX 
                                ; 
                                ; Returns: CX = char code (lo), scan code (hi);
				 0 if no key pressed 
                                ; 
 0691                           waitsec	proc	near 
 0691  BA 00B6                  	mov	dx,182		; 18.2 ticks per second 
 0694  F7 E2                    	mul	dx		; DX:AX = ticks to wait * 10 
 0696  B9 000A                  	mov	cx,10 
 0699  F7 F1                    	div	cx 
 069B  50                       	push	ax		; AX is ticks to wait 
 069C  B4 00                    	mov	ah,TIME_GETTICKS 
 069E  CD 1A                    	int	INT_TIME	; CX:DX is initial tick count 
 06A0  58                       	pop	ax 
 06A1  03 C2                    	add	ax,dx		; add AX 
 06A3  8B D1                    	mov	dx,cx 
 06A5  83 D2 00                 	adc	dx,0		; DX:AX is target tick count 
 06A8  52                       w1:	push	dx 
 06A9  50                       	push	ax 
 06AA  B4 01                    	mov	ah,KBD_CHECK 
 06AC  CD 16                    	int	INT_KBD 
 06AE  74 09                    	jz	w2 
 06B0  58                       	pop	ax 
 06B1  5A                       	pop	dx 
 06B2                           wait	label	near 
 06B2  B4 00                    	mov	ah,KBD_READ 
 06B4  CD 16                    	int	INT_KBD 
 06B6  91                       	xchg	cx,ax		; CL = char code, CH = scan code 
 06B7  EB 0E                    	jmp	short w9 
 06B9  B4 00                    w2:	mov	ah,TIME_GETTICKS 
 06BB  CD 1A                    	int	INT_TIME	; CX:DX is updated tick count 
 06BD  58                       	pop	ax		; subtract target value on the stack 
 06BE  2B D0                    	sub	dx,ax 
 06C0  5A                       	pop	dx 
 06C1  1B CA                    	sbb	cx,dx		; as long as the target value is bi
				gger 
 06C3  72 E3                    	jc	w1		; carry will be set 
 06C5  2B C9                    	sub	cx,cx		; no key was pressed in time 
 06C7  BE 06DC R                w9:	mov	si,offset crlf 
 06CA  E8 065D R                	call	print 
 06CD  C3                       	ret 
                                waitsec	endp 
                                 
                                ; 
                                ; Strings 
                                ; 
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Page     1-16
                                                            

 06CE  42 41 53 49 43 2D 44     product		db	"BASIC-DOS 0.01" 
       4F 53 20 30 2E 30 31     
                                
 06DC  0D 0A 00                 crlf		db	13,10,0 
 06DF  55 6E 61 62 6C 65 20     errmsg		db	"Unable to boot from disk",13,10,0 
       74 6F 20 62 6F 6F 74     
       20 66 72 6F 6D 20 64     
       69 73 6B 0D 0A 00        
 06FA  50 72 65 73 73 20 61     prompt		db	"Press any key to boot from diskette
				",0 
       6E 79 20 6B 65 79 20     
       74 6F 20 62 6F 6F 74     
       20 66 72 6F 6D 20 64     
       69 73 6B 65 74 74 65     
       00                       
 071E  49 42 4D 42 49 4F 20     BIO_FILE	db	"IBMBIO  COM",0 
       20 43 4F 4D 00           
                                 
 072A                           CODE	ends 
                                 
                                	end 

Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Symbols-1
                                                             

Macros:

		N a m e			Lines

ASSERTEQ . . . . . . . . . . . .  	   5

Structures and Records:

                N a m e                 Width   # fields
                                        Shift   Width   Mask    Initial

BPB  . . . . . . . . . . . . . .  	0026	0010
  BPB_OEM  . . . . . . . . . . .  	0000
  BPB_SECBYTES . . . . . . . . .  	0008
  BPB_CLUSSECS . . . . . . . . .  	000A
  BPB_RESSECS  . . . . . . . . .  	000B
  BPB_FATS . . . . . . . . . . .  	000D
  BPB_DIRENTS  . . . . . . . . .  	000E
  BPB_DISKSECS . . . . . . . . .  	0010
  BPB_MEDIA  . . . . . . . . . .  	0012
  BPB_FATSECS  . . . . . . . . .  	0013
  BPB_TRACKSECS  . . . . . . . .  	0015
  BPB_DRIVEHEADS . . . . . . . .  	0017
  BPB_HIDDENSECS . . . . . . . .  	0019
  BPB_LARGESECS  . . . . . . . .  	001D
  BPB_DRIVE  . . . . . . . . . .  	0021
  BPB_LBAROOT  . . . . . . . . .  	0022
  BPB_LBADATA  . . . . . . . . .  	0024
DIRENT . . . . . . . . . . . . .  	0020	0008
  DIR_NAME . . . . . . . . . . .  	0000
  DIR_ATTR . . . . . . . . . . .  	000B
  DIR_PAD  . . . . . . . . . . .  	000C
  DIR_TIME . . . . . . . . . . .  	0016
  DIR_DATE . . . . . . . . . . .  	0018
  DIR_CLN  . . . . . . . . . . .  	001A
  DIR_SIZE_L . . . . . . . . . .  	001C
  DIR_SIZE_H . . . . . . . . . .  	001E
DPT  . . . . . . . . . . . . . .  	000B	000B
  DP_SPECIFY1  . . . . . . . . .  	0000
  DP_SPECIFY2  . . . . . . . . .  	0001
  DP_MOTOROFF  . . . . . . . . .  	0002
  DP_BPS . . . . . . . . . . . .  	0003
  DP_SPT . . . . . . . . . . . .  	0004
  DP_GAP . . . . . . . . . . . .  	0005
  DP_DTL . . . . . . . . . . . .  	0006
  DP_GAP3  . . . . . . . . . . .  	0007
  DP_FILL  . . . . . . . . . . .  	0008
  DP_HEADSETTLE  . . . . . . . .  	0009
  DP_MOTORON . . . . . . . . . .  	000A
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Symbols-2
                                                             

Segments and Groups:

                N a m e         	Size	Align	Combine Class

BIOS_DATA  . . . . . . . . . . .  	0A80	AT	0000	
CODE . . . . . . . . . . . . . .  	072A	PARA	NONE	

Symbols:            

                N a m e         	Type	Value	Attr         

ACTIVE_PAGE  . . . . . . . . . .  	L BYTE 	0462	BIOS_DATA
ADDR_6845  . . . . . . . . . . .  	L WORD 	0463	BIOS_DATA
ALT_INPUT  . . . . . . . . . . .  	L BYTE 	0419	BIOS_DATA
ALT_SHIFT  . . . . . . . . . . .  	Number	0008	
ATTR_ARCHIVE . . . . . . . . . .  	Number	0020	
ATTR_DIRECTORY . . . . . . . . .  	Number	0010	
ATTR_HIDDEN  . . . . . . . . . .  	Number	0002	
ATTR_READ_ONLY . . . . . . . . .  	Number	0001	
ATTR_SYSTEM  . . . . . . . . . .  	Number	0004	
ATTR_VOLUME_ID . . . . . . . . .  	Number	0008	

BAD_ADDR_MARK  . . . . . . . . .  	Number	0002	
BAD_CMD  . . . . . . . . . . . .  	Number	0001	
BAD_CRC  . . . . . . . . . . . .  	Number	0010	
BAD_DMA  . . . . . . . . . . . .  	Number	0008	
BAD_NEC  . . . . . . . . . . . .  	Number	0020	
BAD_SEEK . . . . . . . . . . . .  	Number	0040	
BIOS_BREAK . . . . . . . . . . .  	L BYTE 	0471	BIOS_DATA
BIOS_DATA_END  . . . . . . . . .  	Number	0A80	
BIOS_STACK . . . . . . . . . . .  	NEAR 	0A80	BIOS_DATA
BIO_FILE . . . . . . . . . . . .  	L BYTE 	071E	CODE
BOOT . . . . . . . . . . . . . .  	F PROC	058C	CODE	Length = 0084
BOOT_SECTOR  . . . . . . . . . .  	L BYTE 	052D	BIOS_DATA	Length = 0003
BOOT_SECTOR_HI . . . . . . . . .  	Number	7C00	
BOOT_SECTOR_LO . . . . . . . . .  	Number	052D	
BPB_ACTIVE . . . . . . . . . . .  	L 0026	0530	BIOS_DATA
BUFFER_HEAD  . . . . . . . . . .  	L WORD 	041A	BIOS_DATA
BUFFER_TAIL  . . . . . . . . . .  	L WORD 	041C	BIOS_DATA

CAPS_STATE . . . . . . . . . . .  	Number	0040	
CRC_REG  . . . . . . . . . . . .  	L WORD 	0469	BIOS_DATA
CRLF . . . . . . . . . . . . . .  	L BYTE 	06DC	CODE
CRT_COLS . . . . . . . . . . . .  	L WORD 	044A	BIOS_DATA
CRT_LEN  . . . . . . . . . . . .  	L WORD 	044C	BIOS_DATA
CRT_MODE . . . . . . . . . . . .  	L BYTE 	0449	BIOS_DATA
CRT_MODE_SET . . . . . . . . . .  	L BYTE 	0465	BIOS_DATA
CRT_PALLETTE . . . . . . . . . .  	L BYTE 	0466	BIOS_DATA
CRT_START  . . . . . . . . . . .  	L WORD 	044E	BIOS_DATA
CTL_SHIFT  . . . . . . . . . . .  	Number	0004	
CURSOR_MODE  . . . . . . . . . .  	L WORD 	0460	BIOS_DATA
CURSOR_POSN  . . . . . . . . . .  	L WORD 	0450	BIOS_DATA	Length = 0008

DIR  . . . . . . . . . . . . . .  	L NEAR	05BF	CODE
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Symbols-3
                                                             

DIRENT_SIZE  . . . . . . . . . .  	Number	0020	
DIR_SECTOR . . . . . . . . . . .  	L BYTE 	0756	BIOS_DATA	Length = 0200
DISKETTE_STATUS  . . . . . . . .  	L BYTE 	0441	BIOS_DATA
DISK_GETPARMS  . . . . . . . . .  	Number	0008	
DISK_READ  . . . . . . . . . . .  	Number	0002	
DMA_BOUNDARY . . . . . . . . . .  	Number	0009	
DONE . . . . . . . . . . . . . .  	L NEAR	060C	CODE
DPT_ACTIVE . . . . . . . . . . .  	L 000B	0522	BIOS_DATA

EDGE_CNT . . . . . . . . . . . .  	L WORD 	0467	BIOS_DATA
EQUIP_FLAG . . . . . . . . . . .  	L WORD 	0410	BIOS_DATA
EQ_GAME_CTRL . . . . . . . . . .  	Number	1000	
EQ_IPL_DRIVE . . . . . . . . . .  	Number	0001	
EQ_NUM_DRIVES  . . . . . . . . .  	Number	00C0	
EQ_NUM_PRINT . . . . . . . . . .  	Number	C000	
EQ_NUM_RS232 . . . . . . . . . .  	Number	0E00	
EQ_RAM_SIZE  . . . . . . . . . .  	Number	00C0	
EQ_VIDEO_MODE  . . . . . . . . .  	Number	0030	
ERR  . . . . . . . . . . . . . .  	L NEAR	05D8	CODE
ERRMSG . . . . . . . . . . . . .  	L BYTE 	06DF	CODE

F1 . . . . . . . . . . . . . . .  	L NEAR	0617	CODE
F8 . . . . . . . . . . . . . . .  	L NEAR	0631	CODE
F9 . . . . . . . . . . . . . . .  	L NEAR	0634	CODE
FAT_SECTOR . . . . . . . . . . .  	L BYTE 	0556	BIOS_DATA	Length = 0200
FIND . . . . . . . . . . . . . .  	L NEAR	05CB	CODE
FIND_DIRENT  . . . . . . . . . .  	N PROC	0610	CODE	Length = 0027

GET_CHS  . . . . . . . . . . . .  	N PROC	0637	CODE	Length = 0020

HDBOOT . . . . . . . . . . . . .  	L NEAR	05E3	CODE

INS_STATE  . . . . . . . . . . .  	Number	0080	
INT_BASIC  . . . . . . . . . . .  	Number	0018	
INT_BP . . . . . . . . . . . . .  	Number	0003	
INT_BREAK  . . . . . . . . . . .  	Number	001B	
INT_CASSETTE . . . . . . . . . .  	Number	0015	
INT_COM  . . . . . . . . . . . .  	Number	0014	
INT_DISK . . . . . . . . . . . .  	Number	0013	
INT_DIV  . . . . . . . . . . . .  	Number	0000	
INT_DPT  . . . . . . . . . . . .  	Number	001E	
INT_EQUIP  . . . . . . . . . . .  	Number	0011	
INT_FLAG . . . . . . . . . . . .  	Number	0080	
INT_KBD  . . . . . . . . . . . .  	Number	0016	
INT_LPT  . . . . . . . . . . . .  	Number	0017	
INT_MEMORY . . . . . . . . . . .  	Number	0012	
INT_NMI  . . . . . . . . . . . .  	Number	0002	
INT_OV . . . . . . . . . . . . .  	Number	0004	
INT_PRTSC  . . . . . . . . . . .  	Number	0005	
INT_REBOOT . . . . . . . . . . .  	Number	0019	
INT_STEP . . . . . . . . . . . .  	Number	0001	
INT_TICK . . . . . . . . . . . .  	Number	001C	
INT_TIME . . . . . . . . . . . .  	Number	001A	
INT_VGCDATA  . . . . . . . . . .  	Number	001F	
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Symbols-4
                                                             

INT_VIDEO  . . . . . . . . . . .  	Number	0010	
INT_VPT  . . . . . . . . . . . .  	Number	001D	
IO_RAM_SIZE  . . . . . . . . . .  	L WORD 	0415	BIOS_DATA
IVT  . . . . . . . . . . . . . .  	L DWORD	0000	BIOS_DATA	Length = 0100

KBD_CHECK  . . . . . . . . . . .  	Number	0001	
KBD_READ . . . . . . . . . . . .  	Number	0000	
KB_BUFFER  . . . . . . . . . . .  	L WORD 	041E	BIOS_DATA	Length = 0010
KB_FLAG  . . . . . . . . . . . .  	L BYTE 	0417	BIOS_DATA
KB_FLAG_1  . . . . . . . . . . .  	L BYTE 	0418	BIOS_DATA

LAST_VAL . . . . . . . . . . . .  	L BYTE 	046B	BIOS_DATA
LEFT_SHIFT . . . . . . . . . . .  	Number	0002	
LOAD . . . . . . . . . . . . . .  	L NEAR	05B3	CODE
LOGICAL_DRIVE  . . . . . . . . .  	L BYTE 	0504	BIOS_DATA

MEDIA_160K . . . . . . . . . . .  	Number	00FE	
MEDIA_180K . . . . . . . . . . .  	Number	00FC	
MEDIA_320K . . . . . . . . . . .  	Number	00FF	
MEDIA_360K . . . . . . . . . . .  	Number	00FD	
MEDIA_HARD . . . . . . . . . . .  	Number	00F8	
MEMORY_SIZE  . . . . . . . . . .  	L WORD 	0413	BIOS_DATA
MFG_TEST . . . . . . . . . . . .  	L BYTE 	0412	BIOS_DATA
MOTOR_COUNT  . . . . . . . . . .  	L BYTE 	0440	BIOS_DATA
MOTOR_STATUS . . . . . . . . . .  	L BYTE 	043F	BIOS_DATA
MOVE . . . . . . . . . . . . . .  	L NEAR	0556	CODE
MYBPB  . . . . . . . . . . . . .  	L NEAR	0530	CODE

NEC_STATUS . . . . . . . . . . .  	L BYTE 	0442	BIOS_DATA	Length = 0007
NEXT . . . . . . . . . . . . . .  	L NEAR	05F5	CODE
NUM_STATE  . . . . . . . . . . .  	Number	0020	

PCJS_MULTIPLIER  . . . . . . . .  	Number	0008	
PRINT  . . . . . . . . . . . . .  	L NEAR	065D	CODE
PRINTER_BASE . . . . . . . . . .  	L WORD 	0408	BIOS_DATA	Length = 0004
PRINTL . . . . . . . . . . . . .  	N PROC	0657	CODE	Length = 000C
PRODUCT  . . . . . . . . . . . .  	L BYTE 	06CE	CODE
PROMPT . . . . . . . . . . . . .  	L BYTE 	06FA	CODE

RC9  . . . . . . . . . . . . . .  	L NEAR	067A	CODE
READ . . . . . . . . . . . . . .  	L NEAR	05F3	CODE
READ_CLUSTER . . . . . . . . . .  	N PROC	0663	CODE	Length = 001A
READ_SECTORS . . . . . . . . . .  	N PROC	067D	CODE	Length = 0014
RECORD_NOT_FND . . . . . . . . .  	Number	0004	
RESET_FLAG . . . . . . . . . . .  	L WORD 	0472	BIOS_DATA
RIGHT_SHIFT  . . . . . . . . . .  	Number	0001	
RS232_BASE . . . . . . . . . . .  	L WORD 	0400	BIOS_DATA	Length = 0004

SCROLL_STATE . . . . . . . . . .  	Number	0010	
SEEK_STATUS  . . . . . . . . . .  	L BYTE 	043E	BIOS_DATA

TIMER_HIGH . . . . . . . . . . .  	L WORD 	046E	BIOS_DATA
TIMER_LOW  . . . . . . . . . . .  	L WORD 	046C	BIOS_DATA
TIMER_OFL  . . . . . . . . . . .  	L BYTE 	0470	BIOS_DATA
Microsoft (R) Macro Assembler  Version 4.00                 5/24/20 14:53:05

                                                            Symbols-5
                                                             

TIME_GETTICKS  . . . . . . . . .  	Number	0000	
TIME_OUT . . . . . . . . . . . .  	Number	0080	

VIDEO_TTYOUT . . . . . . . . . .  	Number	000E	

W1 . . . . . . . . . . . . . . .  	L NEAR	06A8	CODE
W2 . . . . . . . . . . . . . . .  	L NEAR	06B9	CODE
W9 . . . . . . . . . . . . . . .  	L NEAR	06C7	CODE
WAIT . . . . . . . . . . . . . .  	L NEAR	06B2	CODE
WAITSEC  . . . . . . . . . . . .  	N PROC	0691	CODE	Length = 003D
WRITE_PROTECT  . . . . . . . . .  	Number	0003	


    579 Source  Lines
    582 Total   Lines
    206 Symbols

  40888 Bytes symbol space free

      0 Warning Errors
      0 Severe  Errors
